head     1.70;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.70
date     91.01.01.21.18.18;  author robertb;  state Exp;
branches ;
next     1.69;

1.69
date     90.12.29.16.29.06;  author robertb;  state Exp;
branches ;
next     1.68;

1.68
date     90.11.15.19.28.00;  author robertb;  state Exp;
branches ;
next     1.67;

1.67
date     90.09.29.21.01.14;  author robertb;  state Exp;
branches ;
next     1.66;

1.66
date     90.08.19.21.21.53;  author robertb;  state Exp;
branches ;
next     1.65;

1.65
date     90.07.01.12.26.36;  author robertb;  state Exp;
branches ;
next     1.64;

1.64
date     90.06.30.17.57.51;  author robertb;  state Exp;
branches ;
next     1.63;

1.63
date     90.03.22.10.58.51;  author jrb;  state Exp;
branches ;
next     1.62;

1.62
date     90.02.23.15.32.19;  author andrew;  state Exp;
branches ;
next     1.61;

1.61
date     90.02.23.09.37.14;  author andrew;  state Exp;
branches ;
next     1.60;

1.60
date     90.02.21.11.06.08;  author andrew;  state Exp;
branches ;
next     1.59;

1.59
date     90.02.20.11.41.06;  author andrew;  state Exp;
branches ;
next     1.58;

1.58
date     90.02.07.17.03.34;  author davidl;  state Exp;
branches ;
next     1.57;

1.57
date     90.02.07.16.04.45;  author andrew;  state Exp;
branches ;
next     1.56;

1.56
date     90.01.05.13.01.19;  author jrb;  state Exp;
branches ;
next     1.55;

1.55
date     89.12.20.09.06.09;  author donhar;  state Exp;
branches ;
next     1.54;

1.54
date     89.12.19.15.38.37;  author andrew;  state Exp;
branches ;
next     1.53;

1.53
date     89.12.19.13.29.25;  author donhar;  state Exp;
branches ;
next     1.52;

1.52
date     89.12.07.14.54.00;  author andrew;  state Exp;
branches ;
next     1.51;

1.51
date     89.12.06.12.30.02;  author davidl;  state Exp;
branches ;
next     1.50;

1.50
date     89.12.05.09.23.20;  author donhar;  state Exp;
branches ;
next     1.49;

1.49
date     89.11.27.12.33.44;  author davidl;  state Exp;
branches ;
next     1.48;

1.48
date     89.11.22.10.42.06;  author andrew;  state Exp;
branches ;
next     1.47;

1.47
date     89.11.18.16.49.43;  author davidl;  state Exp;
branches ;
next     1.46;

1.46
date     89.11.17.10.38.56;  author valeries;  state Exp;
branches ;
next     1.45;

1.45
date     89.11.17.08.07.13;  author davidl;  state Exp;
branches ;
next     1.44;

1.44
date     89.11.17.08.01.16;  author valeries;  state Exp;
branches ;
next     1.43;

1.43
date     89.11.16.21.57.46;  author donhar;  state Exp;
branches ;
next     1.42;

1.42
date     89.11.16.21.55.43;  author donhar;  state Exp;
branches ;
next     1.41;

1.41
date     89.11.14.08.35.28;  author davidl;  state Exp;
branches ;
next     1.40;

1.40
date     89.11.12.16.42.41;  author paulg;  state Exp;
branches ;
next     1.39;

1.39
date     89.11.11.16.43.35;  author davidl;  state Exp;
branches ;
next     1.38;

1.38
date     89.11.10.17.00.01;  author davidl;  state Exp;
branches ;
next     1.37;

1.37
date     89.11.09.17.18.22;  author davidl;  state Exp;
branches ;
next     1.36;

1.36
date     89.11.08.13.30.23;  author davidl;  state Exp;
branches ;
next     1.35;

1.35
date     89.11.08.10.32.15;  author davidl;  state Exp;
branches ;
next     1.34;

1.34
date     89.11.06.19.15.18;  author davidl;  state Exp;
branches ;
next     1.33;

1.33
date     89.11.02.12.42.56;  author davidl;  state Exp;
branches ;
next     1.32;

1.32
date     89.11.02.08.56.28;  author davidl;  state Exp;
branches ;
next     1.31;

1.31
date     89.10.27.14.31.30;  author davidl;  state Exp;
branches ;
next     1.30;

1.30
date     89.10.25.19.18.07;  author davidl;  state Exp;
branches ;
next     1.29;

1.29
date     89.10.24.13.30.08;  author donhar;  state Exp;
branches ;
next     1.28;

1.28
date     89.10.24.12.27.50;  author donhar;  state Exp;
branches ;
next     1.27;

1.27
date     89.10.19.13.28.07;  author davidl;  state Exp;
branches ;
next     1.26;

1.26
date     89.10.10.12.22.10;  author paulg;  state Exp;
branches ;
next     1.25;

1.25
date     89.10.07.10.26.36;  author paulg;  state Exp;
branches ;
next     1.24;

1.24
date     89.09.27.13.16.31;  author davidl;  state Exp;
branches ;
next     1.23;

1.23
date     89.09.27.09.33.59;  author davidl;  state Exp;
branches ;
next     1.22;

1.22
date     89.09.27.09.27.29;  author davidl;  state Exp;
branches ;
next     1.21;

1.21
date     89.09.26.21.38.59;  author paulg;  state Exp;
branches ;
next     1.20;

1.20
date     89.09.26.11.02.31;  author paulg;  state Exp;
branches ;
next     1.19;

1.19
date     89.09.26.10.40.53;  author paulg;  state Exp;
branches ;
next     1.18;

1.18
date     89.09.21.19.52.49;  author paulg;  state Exp;
branches ;
next     1.17;

1.17
date     89.09.21.16.10.24;  author davidl;  state Exp;
branches ;
next     1.16;

1.16
date     89.09.21.11.30.56;  author davidl;  state Exp;
branches ;
next     1.15;

1.15
date     89.09.21.10.43.58;  author paulg;  state Exp;
branches ;
next     1.14;

1.14
date     89.09.21.10.20.15;  author paulg;  state Exp;
branches ;
next     1.13;

1.13
date     89.09.21.09.05.52;  author paulg;  state Exp;
branches ;
next     1.12;

1.12
date     89.09.18.08.06.28;  author paulg;  state Exp;
branches ;
next     1.11;

1.11
date     89.09.11.10.46.36;  author davidl;  state Exp;
branches ;
next     1.10;

1.10
date     89.09.08.16.18.10;  author paulg;  state Exp;
branches ;
next     1.9;

1.9
date     89.09.08.07.00.42;  author davidl;  state Exp;
branches ;
next     1.8;

1.8
date     89.09.07.06.50.18;  author paulg;  state Exp;
branches ;
next     1.7;

1.7
date     89.08.20.18.08.40;  author paulg;  state Exp;
branches ;
next     1.6;

1.6
date     89.08.20.17.54.13;  author paulg;  state Exp;
branches ;
next     1.5;

1.5
date     89.08.19.12.33.37;  author paulg;  state Exp;
branches ;
next     1.4;

1.4
date     89.08.11.15.06.48;  author davidl;  state Exp;
branches ;
next     1.3;

1.3
date     89.08.09.09.31.04;  author davidl;  state Exp;
branches ;
next     1.2;

1.2
date     89.08.04.10.17.53;  author davidl;  state Exp;
branches ;
next     1.1;

1.1
date     89.07.30.23.07.55;  author paulg;  state Exp;
branches ;
next     ;


desc
@@


1.70
log
@Now call remote_close() no matter what, because we may have gotten
the lock, but not been able to attach.
@
text
@/* Top level for GDB, the GNU debugger.
   Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.

   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/main.c,v 1.69 90/12/29 16:29:06 robertb Exp $
   $Locker:  $

This file is part of GDB.

GDB is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GDB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GDB; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */



/* 
 * Changes made by Tektronix are marked by TEK_HACK, TEK_PROG_HACK, 
 * and GHSFORTRAN.
 * Changes made by Data General are marked by DG_HACK.  Compiling without these
 * #defines should be equivalent to compiling vanilla 3.2, more or less.
 *
 * The changes done by Tektronix fit into three catagories:
 *	TEK_HACK -- these were done just to get GDB to work in our environment,
 *		    including work done to support the Green Hills C compiler.
 *	TEK_PROG_HACK -- These were done to extend GDB by adding programming
 *			 support: things like if-elif-else-endif, while, and
 *			 arguments to user defined commands.
 *	GHSFORTRAN -- These changes make (will make) GDB work with the Green
 *		      Hills Fortran compiler.
 *
 *
 * In addition, I/O routines were renamed so that I/O could be directed
 * to/from the X interface if used.  See the files ui.c and ui.h for
 * more information.  Here are the routines renamed:
 *    Old name:			Renamed to:
 *	fprintf			ui_fprintf
 *	printf			ui_fprintf(stdout
 *	putchar			ui_putchar
 *	putc			ui_putc
 *	fputc			ui_putc
 *	fputs			ui_fputs
 *	puts			ui_puts
 *	gets			ui_gets
 *	fgets			ui_fgets
 *	fflush			ui_fflush
 *	system			ui_system
 *	wait			ui_wait
 *	error			ui_badnews(-1
 *	fatal			ui_badnews(1
 *	getc, fgetc		replaced with ui_gets, ui_fgets
 * These changes are not demarcated by ifdef.   
 *
 *					November 16, 1989
 */

#if	defined (DG_HACK) && defined (USG)
/* changed name of getwd to getwoid to avoid syscall confilicts -- jfs */
#endif /* not DG_HACK or not USG */

#include "defs.h"
#include "command.h"
#include "param.h"
#include "ui.h"

#ifdef USG
#include <sys/types.h>
#include <unistd.h>
#endif

#include <sys/file.h>
#include <stdio.h>
#include <setjmp.h>
#include <signal.h>
#include <sys/stat.h>
#include <fcntl.h>

#ifdef SET_STACK_LIMIT_HUGE
#include <sys/time.h>
#include <sys/resource.h>
#include <ctype.h>

int original_stack_limit;
#endif

/* If this definition isn't overridden by the header files, assume
   that isatty and fileno exist on this system.  */
#ifndef ISATTY
#define ISATTY(FP)	(isatty (fileno (FP)))
#endif

/* Version number of GDB, as a string.  */

extern char *version;

/*
 * Declare all cmd_list_element's
 */

/* Chain containing all defined commands.  */

struct cmd_list_element *cmdlist;

/* Chain containing all defined info subcommands.  */

struct cmd_list_element *infolist;
struct cmd_list_element *info_cmd;

/* Chain containing all defined enable subcommands. */

struct cmd_list_element *enablelist;
struct cmd_list_element *enable_cmd;

/* Chain containing all defined disable subcommands. */

struct cmd_list_element *disablelist;
struct cmd_list_element *disable_cmd;

/* Chain containing all defined delete subcommands. */

struct cmd_list_element *deletelist;
struct cmd_list_element *gdbdelete_cmd;

/* Chain containing all defined "enable breakpoint" subcommands. */

struct cmd_list_element *enablebreaklist;
struct cmd_list_element *enablebreak_cmd;

/* Chain containing all defined set subcommands */

struct cmd_list_element *setlist;
struct cmd_list_element *set_cmd;

/* Chain containing all defined \"set history\".  */

struct cmd_list_element *sethistlist;
struct cmd_list_element *sethist_cmd;

/* Chain containing all defined \"unset history\".  */

struct cmd_list_element *unsethistlist;
struct cmd_list_element *unsethist_cmd;

/* stdio stream that command input is being read from.  */

FILE *instream;

/* Current working directory.  */

char *current_directory;

/* The directory name is actually stored here (usually).  */
static char dirbuf[MAXPATHLEN];

/* Stack of currently executing source files. */
struct source_stack_structure
{
  struct source_stack_structure *next;
  FILE *previous_instream;
  char file[1];		/* is actually longer than this */
} *source_stack = 0;

/* The number of lines on a page, and the number of spaces
   in a line.  */
int linesize, pagesize;

#ifdef TEK_HACK
/* Nonzero if we should repeat the previous command on empty input line */

int autorepeat = 1;

/* Pointer to 'echo' command; checked in execute_command */
static struct cmd_list_element *echo_p;
#endif /* TEK_HACK */

/* Nonzero if we should refrain from using an X window.  */

int inhibit_windows = 0;

#ifdef TEK_HACK
/* One if using the X user interface. DL 8/2/89 */
int usingX = 0;
#endif /* TEK_HACK */

/* Function to call before reading a command, if nonzero.
   The function receives two args: an input stream,
   and a prompt string.  */
   
void (*window_hook) ();

/* Last signal that the inferior received (why it stopped).  */
extern int stop_signal;

extern int frame_file_full_name;
int xgdb_verbose;

void free_command_lines ();
char *gdb_readline ();
char *command_line_input ();
static void initialize_main ();
static void initialize_cmd_lists ();
void command_loop ();
static void source_command ();
static void quit_command ();
static void print_gdb_version ();
static void float_handler ();
static void cd_command ();

extern int errno;
char *getenv ();

/* gdb prints this when reading a command interactively */
#ifdef TEK_PROG_HACK
char *gbl_prompt;

extern char *macro_expand ();
extern struct cmd_list_element *my_lookup_cmd();
extern void free_macro_expansion ();
extern struct command_line *read_command_lines ();
extern struct cleanup *push_match_expansions ();
extern struct cleanup *push_def_expansions ();
extern void nested_define_command ();
extern void nested_document_command ();
extern void nested_while_command ();

extern char *index();

#else /* not TEK_PROG_HACK */
static char *prompt;
#endif /* not TEK_PROG_HACK */

/* Buffer used for reading command lines, and the size
   allocated for it so far.  */

char *line;
int linesize;


/* Signal to catch ^Z typed while reading a command: SIGTSTP or SIGCONT.  */

#ifndef STOP_SIGNAL
#ifdef SIGTSTP
#define STOP_SIGNAL SIGTSTP
#endif
#endif

/* This is how `error' returns to command level.  */

jmp_buf to_top_level;

void
return_to_top_level ()
{
  quit_flag = 0;
  immediate_quit = 0;
  clear_breakpoint_commands ();
  clear_momentary_breakpoints ();
  disable_current_display ();
  do_cleanups (0);
#ifdef TEK_PROG_HACK
  clear_cond_stack ();
  update_prompt (2);
#endif /* TEK_PROG_HACK */
  longjmp (to_top_level, 1);
}

/* Call FUNC with arg ARG, catching any errors.
   If there is no error, return the value returned by FUNC.
   If there is an error, return zero after printing ERRSTRING
    (which is in addition to the specific error message already printed).  */

int
catch_errors (func, arg, errstring)
     int (*func) ();
     int arg;
     char *errstring;
{
  jmp_buf saved;
  int val;
  struct cleanup *saved_cleanup_chain;

  saved_cleanup_chain = save_cleanups ();

  bcopy (to_top_level, saved, sizeof (jmp_buf));

  if (setjmp (to_top_level) == 0)
    val = (*func) (arg);
  else
    {
      ui_fprintf (stderr, "%s\n", errstring);
      val = 0;
    }

  restore_cleanups (saved_cleanup_chain);

  bcopy (saved, to_top_level, sizeof (jmp_buf));
  return val;
}

/* Handler for SIGHUP.  */

static void
disconnect ()
{
  kill_inferior_fast ();
  signal (SIGHUP, SIG_DFL);
  kill (getpid (), SIGHUP);
}

/* Clean up on error during a "source" command (or execution of a
   user-defined command).
   Close the file opened by the command
   and restore the previous input stream.  */

/* Clean up on error during a "source" command (or execution of a
   user-defined command).
   Close the file opened by the command
   and restore the previous input stream.  */

#ifndef TEK_PROG_HACK
static
#endif /* not TEK_PROG_HACK */
void
source_cleanup (stream)
     FILE *stream;
{
  /* Instream may be 0; set to it when executing user-defined command. */
  if (instream)
    fclose (instream);
  instream = stream;
}

static void
source_stack_cleanup (s)
	struct source_stack_structure *s;
{
  /* Discard source_stack_structures until we get to where we want to be. */
  while (s != source_stack)
    {
      register struct source_stack_structure *t = source_stack->next;

      source_cleanup(source_stack->previous_instream);
      free(source_stack);
      source_stack = t;
    }
}

int
main (argc, argv, envp)
     int argc;
     char **argv;
     char **envp;
{
  extern void request_quit ();
  int count;
  int inhibit_gdbinit = 0;
  int quiet = 0;
  int batch = 0;
  register int i;
  char *p;
  extern char *rindex();
#ifdef TEK_HACK
  int emulate_dbx = 0;
  char *source_command_file = NULL;
#endif /* TEK_HACK */

  quit_flag = 0;
  linesize = 100;
  line = (char *) xmalloc (linesize);
  instream = stdin;

  getwoid (dirbuf);
  current_directory = dirbuf;

#ifdef SET_STACK_LIMIT_HUGE
  {
    struct rlimit rlim;

    /* Set the stack limit huge so that alloca (particularly stringtab
     * in dbxread.c) does not fail. */
    getrlimit (RLIMIT_STACK, &rlim);
    original_stack_limit = rlim.rlim_cur;
    rlim.rlim_cur = rlim.rlim_max;
    setrlimit (RLIMIT_STACK, &rlim);
  }
#endif /* SET_STACK_LIMIT_HUGE */

  /* Look for flag arguments.  */

#ifdef TEK_HACK
	/*
	 * Process command line for user interface options
         */

  p = rindex(argv[0], '/');
  if (!p) p = argv[0];
  while (*p == '.' || *p == '/') p++;
  if ((*p == 'x')
  || (*p == 'X')) {
          usingX = 1;
  }
#endif /* TEK_HACK */

  for (i = 1; i < argc; i++)
    {
      if (!strcmp (argv[i], "-q") || !strcmp (argv[i], "-quiet"))
	quiet = 1;
      else if (!strcmp (argv[i], "-nx"))
	inhibit_gdbinit = 1;
#ifdef TEK_HACK
      else if (!strcmp (argv[i], "-na"))
	autorepeat = 0;
      else if (!strcmp (argv[i], "-dbx"))
	emulate_dbx = 1;
#endif /* TEK_HACK */
      else if (!strcmp (argv[i], "-nw"))
	inhibit_windows = 1;
      else if (!strcmp (argv[i], "-batch"))
	batch = 1, quiet = 1, usingX = 0;
      else if (!strcmp (argv[i], "-fullname"))
	frame_file_full_name = 1;
      else if (!strcmp (argv[i], "-xgdb_verbose"))
	xgdb_verbose = 1;
#ifdef TEK_HACK
      else if ((!strcmp (argv[i], "-c")) && usingX) {
   /* Workaround for the fact that the X toolkit intrinsics will see '-c' as
    * an abbreviation for '-color' and try to use it.  So we'll simply replace
    * '-c' with '-core' before the toolkit knows about it.
    */
        argv[i] = savestring("-core", 5);
        i++;
      }
#endif /* TEK_HACK */
      else if (argv[i][0] == '-')
	i++;
    }

  /* Run the init function of each source file */

  initialize_cmd_lists ();	/* This needs to be done first */
  initialize_all_files ();
  initialize_main ();		/* But that omits this file!  Do it now */
  initUsrInt (usingX, &argc, argv);

  signal (SIGINT, request_quit);
  signal (SIGQUIT, SIG_IGN);
  if (signal (SIGHUP, SIG_IGN) != SIG_IGN)
    signal (SIGHUP, disconnect);
  signal (SIGFPE, float_handler);

  if (!quiet)
    print_gdb_version ();


  /* Process the command line arguments.  */

  count = 0;
  for (i = 1; i < argc; i++)
    {
      register char *arg = argv[i];
      /* Args starting with - say what to do with the following arg
	 as a filename.  */
      if (arg[0] == '-')
	{
	  extern void exec_file_command (), symbol_file_command ();
	  extern void core_file_command (), directory_command ();
	  extern void tty_command ();

	  if (!strcmp (arg, "-q") || !strcmp (arg, "-nx")
#ifdef TEK_HACK
              || !strcmp (arg, "-na") || !strcmp (arg, "-dbx")
#endif /* TEK_HACK */
	      || !strcmp (arg, "-quiet") || !strcmp (arg, "-batch")
	      || !strcmp (arg, "-fullname") || !strcmp (arg, "-nw")
	      || !strcmp (arg, "-xgdb_verbose"))
	    /* Already processed above */
	    continue;

	  if (++i == argc)
	    ui_fprintf (stderr, "No argument follows \"%s\".\n", arg);
	  if (!setjmp (to_top_level))
	    {
	      /* -s foo: get syms from foo.  -e foo: execute foo.
		 -se foo: do both with foo.  -c foo: use foo as core dump.  */
	      if (!strcmp (arg, "-se"))
		{
		  exec_file_command (argv[i], !batch);
		  symbol_file_command (argv[i], !batch);
		}
	      else if (!strcmp (arg, "-s") || !strcmp (arg, "-symbols"))
		symbol_file_command (argv[i], !batch);
	      else if (!strcmp (arg, "-e") || !strcmp (arg, "-exec"))
		exec_file_command (argv[i], !batch);
	      else if (!strcmp (arg, "-c") || !strcmp (arg, "-core"))
		core_file_command (argv[i], !batch);
	      /* -x foo: execute commands from foo.  */
	      else if (!strcmp (arg, "-x") || !strcmp (arg, "-command")
		       || !strcmp (arg, "-commands"))
#ifdef TEK_HACK
  /* We may want to read in dbx emulation file before anything else */
                source_command_file = savestring(argv[i], strlen(argv[i]));
#else
		source_command (argv[i]);
#endif /* TEK_HACK */
	      /* -d foo: add directory `foo' to source-file directory
		         search-list */
	      else if (!strcmp (arg, "-d") || !strcmp (arg, "-dir")
		       || !strcmp (arg, "-directory"))
		directory_command (argv[i], 0);
	      /* -cd FOO: specify current directory as FOO.
		 GDB remembers the precise string FOO as the dirname.  */
	      else if (!strcmp (arg, "-cd"))
		{
		  cd_command (argv[i], 0);
		  init_source_path ();
		}
	      /* -t /def/ttyp1: use /dev/ttyp1 for inferior I/O.  */
	      else if (!strcmp (arg, "-t") || !strcmp (arg, "-tty"))
		tty_command (argv[i], 0);
	      else
		ui_badnews(-1,"Unknown command-line switch: \"%s\"\n", arg);
	    }
	}
      else
	{
	  /* Args not thus accounted for
	     are treated as, first, the symbol/executable file
	     and, second, the core dump file.  */
	  count++;
	  if (!setjmp (to_top_level))
	    switch (count)
	      {
	      case 1:
		exec_file_command (arg, !batch);
		symbol_file_command (arg, !batch);
		break;

	      case 2:
		core_file_command (arg, !batch);
		break;

	      case 3:
		ui_fprintf (stderr, "Excess command line args ignored. (%s%s)\n",
			 arg, (i == argc - 1) ? "" : " ...");
	      }
	}
    } /* end 'for' */
  {
    struct stat homebuf, cwdbuf;
    char *homedir, *homeinit;

    /* Read init file, if it exists in home directory  */
    homedir = getenv ("HOME");

#ifdef TEK_HACK
  /* Now we read all the command files in.  The order is:
   *    1. dbx emulation files, if desired (-dbx)
   *    2. any files specified by name (-x)
   *    3. gdbinit file, unless not present or inhibited (-nx)
   */
	homeinit = (char *) alloca (strlen (getenv ("HOME")) + 20);
        if (emulate_dbx) {
           sprintf(homeinit, "%s/gdb-dbx_script", getenv ("HOME"));
           if (access(homeinit, R_OK) == 0) {
		emulate_dbx = 0;
		ui_fprintf(stdout,"Reading %s for dbx emulation script.\n",
			homeinit);
		if (!setjmp (to_top_level))
		    source_command(homeinit);
           }
  	   else if (access("./gdb-dbx_script", R_OK) == 0) {
   		ui_fprintf(stdout,"Reading ./gdb-dbx_script for dbx emulation script.\n");
		if (!setjmp (to_top_level))
   		    source_command ("./gdb-dbx_script");
           }
           else if (access("/usr/local/bin/gnu/gdb-dbx_script", R_OK) == 0) {
   		ui_fprintf(stdout,"Reading /usr/local/bin/gnu/gdb-dbx_script for dbx emulation script.\n");
		if (!setjmp (to_top_level))
   		    source_command ("/usr/local/bin/gnu/gdb-dbx_script");
           }
           else if (access("/usr/local/bin/gdb-dbx_script", R_OK) == 0) {
   	      ui_fprintf(stdout,"Reading /usr/local/bin/gdb-dbx_script for dbx emulation script.\n");
		if (!setjmp (to_top_level))
   		    source_command ("/usr/local/bin/gdb-dbx_script");
           }
       	   else if (access("/usr/local/gdb-dbx_script", R_OK) == 0) {
   	ui_fprintf(stdout,"Reading /usr/local/gdb-dbx_script for dbx emulation script.\n");
		if (!setjmp (to_top_level))
   		    source_command ("/usr/local/gdb-dbx_script");
        }
        else ui_fprintf(stderr, "Can't find gdb-dbx_script to use in setting up dbx emulation.\n");
     }
/* Now read -x file, if any */
     if (source_command_file) {
	if (!setjmp (to_top_level))
	    source_command(source_command_file);
        free(source_command_file);
     }
/* Finally, read .gdbinit file if not inhibitied */
#endif /* TEK_HACK */
    if (homedir)
      {
#ifndef TEK_HACK
	homeinit = (char *) alloca (strlen (getenv ("HOME")) + 20);
#endif
	strcpy (homeinit, getenv ("HOME"));
	strcat (homeinit, "/.gdbinit");
	if (!inhibit_gdbinit && access (homeinit, R_OK) == 0)
	  if (!setjmp (to_top_level))
	    source_command (homeinit);

	/* Do stats; no need to do them elsewhere since we'll only
	   need them if homedir is set.  Make sure that they are
	   zero in case one of them fails (guarantees that they
	   won't match if either exits).  */
	
	bzero (&homebuf, sizeof (struct stat));
	bzero (&cwdbuf, sizeof (struct stat));
	
	stat (homeinit, &homebuf);
	stat ("./.gdbinit", &cwdbuf); /* We'll only need this if
					 homedir was set.  */
    
    /* Read the input file in the current directory, *if* it isn't
       the same file (it should exist, also).  */

    if (!homedir
	|| bcmp ((char *) &homebuf,
		 (char *) &cwdbuf,
		 sizeof (struct stat)))
      if (!inhibit_gdbinit && access (".gdbinit", R_OK) == 0)
	if (!setjmp (to_top_level))
	  source_command (".gdbinit");
  }


  if (batch)
    ui_badnews(1,"Attempt to read commands from stdin in batch mode.");

  if (!quiet) {
    ui_fprintf(stdout, "Type \"help\" for a list of commands.\n");
    ui_fflush(stdout);
  }
  ui_doneinit();
 }

  /* The command loop.  */

  while (1)
    {
      if (!setjmp (to_top_level))
	{
	  command_loop ();
        }
      clearerr (stdin);		/* Don't get hung if C-d is typed.  */
    }
}


/* Execute the line P as a command.
   Pass FROM_TTY as second argument to the defining function.  */

void
#ifdef TEK_PROG_HACK
execute_command (c, p, from_tty)
     register struct cmd_list_element *c;
#else /* not TEK_PROG_HACK */
execute_command (p, from_tty)
#endif /* not TEK_PROG_HACK */
     char *p;
     int from_tty;
{
#ifndef TEK_PROG_HACK
  register struct cmd_list_element *c;
#endif /* not TEK_PROG_HACK */
  register struct command_line *cmdlines;

  free_all_values ();
  while (*p == ' ' || *p == '\t') p++;
#ifdef TEK_PROG_HACK
  if ((! c) && *p)
      c = my_lookup_cmd (&p, cmdlist, "", 0, 1);
  if (c)
#else /* not TEK_PROG_HACK */
  if (*p)
#endif /* not TEK_PROG_HACK */
    {
#ifndef TEK_PROG_HACK
      c = lookup_cmd (&p, cmdlist, "", 0, 1);

/* Added to insure no reference through null pointer.  DL 8/1/89 */
      if (c == NULL) return;
#endif /* not TEK_PROG_HACK */
#ifdef TEK_HACK 
/* Allow commands separated by a colon */
      if (*p && c != echo_p) {
	char *semicolon = index(p, ';');

        if (semicolon) {
            char *newp = savestring(p, strlen(p));
            char *ldquote = index(newp, '"');
	    char *newcmd;
            char *rdquote;
/* If the semicolon is within double quotes, it's part of a macro 
 * definition or some other quoted string; ignore it.
 */
            semicolon = index(newp, ';');
            newcmd = semicolon + 1;
            if (ldquote) {
                if (*(ldquote + 1))
		  rdquote = index(ldquote + 1, '"');
            }
	    if ((!ldquote) || semicolon < ldquote || semicolon > rdquote) {
		*semicolon = '\0';
    		while (*newcmd && (*newcmd == ' ' || 
		    *newcmd == '\t')) newcmd++;
    		if (*newcmd) {
			execute_command(c, newp, from_tty);
			execute_command(0, newcmd, from_tty);
                        free(newp);
			return;
	    	}
	   }
           free(newp);
        }
      }
#endif /* TEK_HACK */ 

      if (c->function == 0)
	ui_badnews(-1,"That is not a command, just a help topic.");
      else if (c->class == (int) class_user)
	{
	  struct cleanup *old_chain;
          char *tem;
	  
#ifndef TEK_PROG_HACK
	  if (*p)
	    ui_badnews(-1,"User-defined commands cannot take arguments (yet).");
#endif /* not TEK_PROG_HACK */
	  cmdlines = (struct command_line *) c->function;
	  if (cmdlines == (struct command_line *) 0)
	    /* Null command */
	    return;

	  /* Set the instream to 0, indicating execution of a
	     user-defined function.  */
#ifdef TEK_PROG_HACK

          if (skip_execute (c))
            return;
          tem = macro_expand (p, c);
          (void) make_cleanup (free_macro_expansion, tem);
	  if (cmdlines->cmd == (struct cmd_list_element *) INVALID_CORE_ADDR)
	    {
	      if (cmdlines->next == (struct command_line *)0)
		/* Null command (with delimiters!?) */
		return;
	      old_chain = push_def_expansions (c->name, tem, cmdlines->line);
	      cmdlines = cmdlines->next;
	    }
	  else
	    old_chain = push_def_expansions (c->name, tem, 0);
          (void) push_match_expansions ();
	  (void) make_cleanup (source_cleanup, instream);
#else /* not TEK_PROG_HACK */
	  old_chain =  make_cleanup (source_cleanup, instream);
#endif /* not TEK_PROG_HACK */
	  instream = (FILE *) 0;
	  while (cmdlines)
	    {
#ifdef TEK_PROG_HACK
	      execute_command (cmdlines->cmd, cmdlines->line, 0);
#else /* not TEK_PROG_HACK */
	      execute_command (cmdlines->line, 0);
#endif /* not TEK_PROG_HACK */
	      cmdlines = cmdlines->next;
	    }
	  do_cleanups (old_chain);
	}
#ifdef TEK_PROG_HACK
      else if (skip_execute (c))
        return;
      else if (c->class == (int) class_nested)
        (*c->function) (p, from_tty);
      else
        {
          char *tem;
          tem = macro_expand (p, c);
          (void) make_cleanup (free_macro_expansion, tem);
          (*c->function) (*tem ? tem : 0, from_tty);
        }
#else /* not TEK_PROG_HACK */
      else 
        /* Pass null arg rather than an empty one.  */
        (*c->function) (*p ? p : 0, from_tty);
#endif /* not TEK_PROG_HACK */
    }
}

static void
do_nothing ()
{
}

/* Read commands from `instream' and execute them
   until end of file.  */
void
command_loop ()
{
  register char *p;

  struct cleanup *old_chain;
  while (!feof (instream))
    {
#ifdef TEK_PROG_HACK /* -rcb 6/90 */
      if (window_hook && instream == stdin)
	(*window_hook) (instream, gbl_prompt);
#endif

      quit_flag = 0;
      if (instream == stdin && ISATTY (stdin))
	reinitialize_more_filter ();
      old_chain = make_cleanup (do_nothing, 0);
#ifdef TEK_PROG_HACK /* -rcb 6/90 */
      p = command_line_input (instream == stdin ? gbl_prompt : 0,
#else
      p = command_line_input (instream == stdin ? prompt : 0,
#endif
			      instream == stdin);

      if (p == (char *)EOF)
	{
	  if (instream != stdin)
	    return;
	  if (!varvalue("ignoreeof")) {
            quit_command();
          }
	  continue;
	}
      execute_command (0, p, instream == stdin);
      /* Do any commands attached to breakpoint we stopped at.  */
      
      do_breakpoint_commands ();

      do_cleanups (old_chain);
    }
}

/* Commands call this if they do not want to be repeated by null lines.  */

void
dont_repeat ()
{
  /* If we aren't reading from standard input, we are saving the last
     thing read from stdin in line and don't want to delete it.  Null lines
     won't repeat here in any case.  */
  if (instream == stdin)
    *line = 0;
}

#ifdef STOP_SIGNAL
static void
stop_sig ()
{
#if STOP_SIGNAL == SIGTSTP
  signal (SIGTSTP, SIG_DFL);
#ifdef	TEK_HACK
#ifdef	BSD
#ifndef	BSD4_1
  sigsetmask (0);
#endif
#endif
#endif	/* TEK_HACK */
  kill (getpid (), SIGTSTP);
  signal (SIGTSTP, stop_sig);
#else
  signal (STOP_SIGNAL, stop_sig);
#endif
  ui_newprompt();
#ifdef TEK_PROG_HACK
  ui_fprintf(stdout, "%s", gbl_prompt);
#else /* not TEK_PROG_HACK */
  ui_fprintf(stdout, "%s", prompt);
#endif /* not TEK_PROG_HACK */
  ui_fflush (stdout);

  /* Forget about any previous command -- null line now will do nothing.  */
  dont_repeat ();
}
#endif /* STOP_SIGNAL */

/* This routine reads a line from the stream "instream" via fgetc.
   If RETURN_RESULT is set it allocates
   space for whatever the user types and returns the result.
   Return value is (char *)EOF if end-of-file (control-D). */
/* Revised to use ui_fgets to accommodate X interface DL 8/1/89 */
char *
gdb_readline (prompt, return_result)
     char *prompt;
     int return_result;
{
  char *result;
  int result_size;

  if (prompt)
    {
      ui_fflush (stdout);
      ui_newprompt();
      ui_fprintf(stdout, "%s", prompt);
      ui_fflush (stdout);
    }

  if (instream == stdin)
    {
      char *mark;

      ui_tickleMe();
  
      result_size = 320;
      result = (char *) xmalloc (result_size);
 
      /* Loop until we do a read with no I/O error.
	 We'll get an error each time the user types ^Z, fg. */
      for (;;)
	{
	  errno = 0;
	  if (ui_fgets(result, result_size, instream))
	    break;

	  /* If EOF, return EOF.  Otherwise go around the loop again. */
	  if (errno==0)
	    {
	      free (result);
	      ui_putc('\n', stdout);
	      return (char *) EOF;
	    }
	}

      if (return_result)
        {
          mark = index(result, '\n');
          if (mark) *mark = '\0';
          else result[result_size - 1] = '\0';
          return result;
        }
      else
        {
          free (result);
          return (char *) 0;
        }
    }
  else
    {
      int c;
      int input_index = 0;

      result_size = 80;

      if (return_result)
        result = (char *) xmalloc (result_size);

      while (1)
        {
          c = fgetc (instream);
          if (c == EOF || c == '\n')
            break;
          if (return_result)
            {
              result[input_index++] = c;
              while (input_index >= result_size)
                {
                  result_size *= 2;
                  result = (char *) xrealloc (result, result_size);
                }
            }
        }
      if (c == EOF)
	{
	  free (result);
	  return (char *) EOF;
	}
      else if (return_result)
        {
          result[input_index++] = '\0';
          return result;
        }
      else
	{
	  free (result);
          return (char *) 0;
	}
    }
}

/* Declaration for fancy readline with command line editing.  */
char *readline ();

/* Variables which control command line editing and history
   substitution.  These variables are given default values at the end
   of this file.  */

/* This is always off for now if we're using the X user interface. DL 8/2/89 */
static int command_editing_p;
static int history_expansion_p;
static int write_history_p;
static int history_size;
static char *history_filename;

/* Variables which are necessary for fancy command line editing.  */
char *gdb_completer_word_break_characters =
  " \t\n!@@#$%^&*()-+=|~`}{[]\"';:?/>.<,";

/* Functions that are used as part of the fancy command line editing.  */

/* Generate symbol names one by one for the completer.  If STATE is
   zero, then we need to initialize, otherwise the initialization has
   already taken place.  TEXT is what we expect the symbol to start
   with.  RL_LINE_BUFFER is available to be looked at; it contains the
   entire text of the line.  RL_POINT is the offset in that line of
   the cursor.  You should pretend that the line ends at RL_POINT.  */
char *
symbol_completion_function (text, state)
     char *text;
     int state;
{
  char **make_symbol_completion_list ();
  static char **list = (char **)NULL;
  static int index;
  char *output;
  extern char *rl_line_buffer;
  extern int rl_point;
  char *tmp_command, *p;
  struct cmd_list_element *c, *result_list;

  if (!state)
    {
      /* Free the storage used by LIST, but not by the strings inside.  This is
	 because rl_complete_internal () frees the strings. */
      if (list)
	free (list);
      list = 0;
      index = 0;

      /* Decide whether to complete on a list of gdb commands or on
	 symbols.  */
      tmp_command = (char *) alloca (rl_point + 1);
      p = tmp_command;
      
      strncpy (tmp_command, rl_line_buffer, rl_point);
      tmp_command[rl_point] = '\0';
      
      c = lookup_cmd_1 (&p, cmdlist, &result_list, 1);

      /* Move p up to the next interesting thing.  */
      while (*p == ' ' || *p == '\t')
	p++;

      if (!c)
	/* He's typed something unrecognizable.  Sigh.  */
	list = (char **) 0;
      else if (c == (struct cmd_list_element *) -1)
	{
	  if (p + strlen(text) != tmp_command + rl_point)
	    ui_badnews(-1,"Unrecognized command.");
	  
	  /* He's typed something ambiguous.  This is easier.  */
	  if (result_list)
	    list = complete_on_cmdlist (result_list, text);
	  else
	    list = complete_on_cmdlist (cmdlist, text);
	}
      else
	{
	  /* If we've gotten this far, gdb has recognized a full
	     command.  There are several possibilities:

	     1) We need to complete on the command.
	     2) We need to complete on the possibilities coming after
	     the command.
	     2) We need to complete the text of what comes after the
	     command.   */

	  if (!*p && *text)
	    /* Always (might be longer versions of thie command).  */
	    list = complete_on_cmdlist (result_list, text);
	  else if (!*p && !*text)
	    {
	      if (c->prefixlist)
		list = complete_on_cmdlist (*c->prefixlist, "");
	      else
		list = make_symbol_completion_list ("");
	    }
	  else
	    {
	      if (c->prefixlist && !c->allow_unknown)
		{
		  *p = '\0';
		  ui_badnews(-1,"\"%s\" command requires a subcommand.",
			 tmp_command);
		}
	      else
		list = make_symbol_completion_list (text);
	    }
	}
    }

  /* If the debugged program wasn't compiled with symbols, or if we're
     clearly completing on a command and no command matches, return
     NULL.  */
  if (!list)
    return ((char *)NULL);

  output = list[index];
  if (output)
    index++;

  return (output);
}

/* Read one line from the command input stream `instream'
   into the local static buffer `linebuffer' (whose current length
   is `linelength').
   The buffer is made bigger as necessary.
   Returns the address of the start of the line.
   If end-of-file (control-D or true file EOF) occurs, returns (char *)EOF.

   *If* the instream == stdin & stdin is a terminal, the line read
   is copied into the file line saver (global var char *line,
   length linesize) so that it can be duplicated.

   This routine either uses fancy command line editing or
   simple input as the user has requested.  */

char *
command_line_input (prompt, repeat)
     char *prompt;
     int repeat;
{
  static char *linebuffer = 0;
  static int linelength = 0;
  register char *p;
  register char *p1, *rl;
  char *local_prompt = prompt;
  register int c;
  char *nline;

  if (linebuffer == 0)
    {
      linelength = 80;
      linebuffer = (char *) xmalloc (linelength);
    }

  p = linebuffer;

  /* Control-C quits instantly if typed while in this loop
     since it should not wait until the user types a newline.  */
  immediate_quit++;
#ifdef STOP_SIGNAL
  signal (STOP_SIGNAL, stop_sig);
#endif

  while (1)
    {
      /* Don't use fancy stuff if not talking to stdin.  */
      if (command_editing_p && instream == stdin
	  && ISATTY (instream))
	rl = readline (local_prompt);
      else
	rl = gdb_readline (local_prompt, 1);

      /* On error or EOF, set the line buffer to a null string (so
	 carriage return has nothing to repeat) and return EOF. */
      if (!rl || rl == (char *) EOF)
	{
	  linebuffer[0] = '\0';
	  return (char *)EOF;
	}
      if (strlen(rl) + 1 + (p - linebuffer) > linelength)
	{
	  linelength = strlen(rl) + 1 + (p - linebuffer);
	  nline = (char *) xrealloc (linebuffer, linelength);
	  p += nline - linebuffer;
	  linebuffer = nline;
	}
      p1 = rl;
      /* Copy line.  Don't copy null at end.  (Leaves line alone
         if this was just a newline)  */
      while (*p1)
	*p++ = *p1++;

      free (rl);			/* Allocated in readline.  */

      if (p == linebuffer || *(p - 1) != '\\')
	break;

      p--;			/* Put on top of '\'.  */
      local_prompt = (char *) 0;
  }

#ifdef STOP_SIGNAL
  signal (SIGTSTP, SIG_DFL);
#endif
  immediate_quit--;

  /* Do history expansion if that is wished.  */
  if (history_expansion_p && instream == stdin
      && ISATTY (instream) && linebuffer[0] == '!')
    {
      char *history_value;
      int expanded;

      *p = '\0';		/* Insert null now.  */
      expanded = history_expand (linebuffer, &history_value);
      if (expanded)
	{
	  /* Print the changes.  */
	  ui_fprintf(stdout, "%s\n", history_value);

	  /* If there was an error, call this function again.  */
	  if (expanded < 0)
	    {
	      free (history_value);
	      return command_line_input (prompt, repeat);
	    }
	  if (strlen (history_value) > linelength)
	    {
	      linelength = strlen (history_value) + 1;
	      linebuffer = (char *) xrealloc (linebuffer, linelength);
	    }
	  strcpy (linebuffer, history_value);
	  p = linebuffer + strlen(linebuffer);
	  free (history_value);
	}
    }

  /* If we just got an empty line, and that is supposed
     to repeat the previous command, return the value in the
     global buffer.  */

#ifdef TEK_HACK
  if (repeat && autorepeat)
#else
  if (repeat)
#endif /* not TEK_HACK */

    {
      if (p == linebuffer)
	return line;
      p1 = linebuffer;
      while (*p1 == ' ' || *p1 == '\t')
	p1++;
      if (!*p1)
	return line;
    }

  /* If line is a comment, clear it out.  */
  p1 = linebuffer;
  while ((c = *p1) == ' ' || c == '\t') p1++;
  if (c == '#')
    p = linebuffer;

  *p = 0;

  /* Add line to history if appropriate.  */
  if (instream == stdin
      && ISATTY (stdin) && *linebuffer)
    add_history (linebuffer);

  /* Save into global buffer if appropriate.  */
  if (repeat)
    {
      if (linelength > linesize)
	{
	  line = xrealloc (line, linelength);
	  linesize = linelength;
	}
      strcpy (line, linebuffer);
      return line;
    }

  return linebuffer;
}

/* Read lines from the input stream
   and accumulate them in a chain of struct command_line's
   which is then returned.  */

#ifndef TEK_PROG_HACK 
struct command_line *
read_command_lines ()
{
  struct command_line *first = 0;
  register struct command_line *next, *tail = 0;
  register char *p, *p1;
  struct cleanup *old_chain = 0;

  while (1)
    {
      dont_repeat ();
      p = command_line_input (0, instream == stdin);
      /* Remove leading and trailing blanks.  */
      while (*p == ' ' || *p == '\t') p++;
      p1 = p + strlen (p);
      while (p1 != p && (p1[-1] == ' ' || p1[-1] == '\t')) p1--;

      /* Is this "end"?  */
      if (p1 - p == 3 && !strncmp (p, "end", 3))
	break;

      /* No => add this line to the chain of command lines.  */
      next = (struct command_line *) xmalloc (sizeof (struct command_line));
      next->line = savestring (p, p1 - p);
      next->next = 0;
      if (tail)
	{
	  tail->next = next;
	}
      else
	{
	  /* We just read the first line.
	     From now on, arrange to throw away the lines we have
	     if we quit or get an error while inside this function.  */
	  first = next;
	  old_chain = make_cleanup (free_command_lines, &first);
	}
      tail = next;
    }

  dont_repeat ();

  /* Now we are about to return the chain to our caller,
     so freeing it becomes his responsibility.  */
  if (first)
    discard_cleanups (old_chain);
  return first;
}
#endif

/* Free a chain of struct command_line's.  */

void
free_command_lines (lptr)
      struct command_line **lptr;
{
  register struct command_line *l = *lptr;
  register struct command_line *next;

  while (l)
    {
      next = l->next;
#ifdef TEK_PROG_HACK
      if (l->cmd && (l->cmd == (struct cmd_list_element *) INVALID_CORE_ADDR))
	free_string_list (l->line);
      else if (l->cmd && (l->cmd->class == class_nested))
        free_command_lines ((struct command_line **)&(l->line));
      else
#endif /* TEK_PROG_HACK */
      free (l->line);
      free (l);
      l = next;
    }
}

/* Add an element to the list of info subcommands.  */

void
add_info (name, fun, doc)
     char *name;
     void (*fun) ();
     char *doc;
{
#ifdef TEK_PROG_HACK
  struct cmd_list_element *new;

  new = 
#endif /* TEK_PROG_HACK */
  add_cmd (name, no_class, fun, doc, &infolist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) info_cmd;
#endif /* TEK_PROG_HACK */
}

/* Add an alias to the list of info subcommands.  */

void
add_info_alias (name, oldname, abbrev_flag)
     char *name;
     char *oldname;
     int abbrev_flag;
{
#ifdef TEK_PROG_HACK
  struct cmd_list_element *new;

  new =
#endif /* TEK_PROG_HACK */
  add_alias_cmd (name, oldname, 0, abbrev_flag, &infolist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) info_cmd;
#endif /* TEK_PROG_HACK */
}

/* The "info" command is defined as a prefix, with allow_unknown = 0.
   Therefore, its own definition is called only for "info" with no args.  */

static void
info_command ()
{
  ui_fprintf(stdout, "\"info\" must be followed by the name of an info command.\n");
  help_list (infolist, "info ", -1, stdout);
}

/* Add an element to the list of commands.  */

void
add_com (name, class, fun, doc)
     char *name;
     int class;
     void (*fun) ();
     char *doc;
{
  add_cmd (name, class, fun, doc, &cmdlist);
}

/* Add an alias or abbreviation command to the list of commands.  */

void
add_com_alias (name, oldname, class, abbrev_flag)
     char *name;
     char *oldname;
     int class;
     int abbrev_flag;
{
  add_alias_cmd (name, oldname, class, abbrev_flag, &cmdlist);
}

void
error_no_arg (why)
     char *why;
{
  ui_badnews(-1,"Argument required (%s).", why);
}

static void
help_command (command, from_tty)
     char *command;
     int from_tty; /* Ignored */
{
  help_cmd (command, stdout);
}

#ifdef TEK_PROG_HACK
char *
#else /* not TEK_PROG_HACK */
static void
#endif /* not TEK_PROG_HACK */
validate_comname (comname)
     char *comname;
{
  register char *p;

  if (comname == 0)
    error_no_arg ("name of command to define");

  p = comname;
  while (*p)
    {
#ifdef TEK_PROG_HACK
      if ((*p == ' ') || (*p == '\t'))
	break;
#endif /* TEK_PROG_HACK */      
      if (!(*p >= 'A' && *p <= 'Z')
	  && !(*p >= 'a' && *p <= 'z')
	  && !(*p >= '0' && *p <= '9')
	  && *p != '-')
	ui_badnews(-1,"Junk in argument list: \"%s\"", p);
      p++;
    }
#ifdef TEK_PROG_HACK
  return p;
#endif /* TEK_PROG_HACK */  
}

static void
define_command(comname, from_tty)
     char *comname;
     int from_tty;
{
  register struct command_line *cmds;
  register struct cmd_list_element *c;
  char *tem = comname;
#ifdef TEK_PROG_HACK
  char *extra;

  extra = validate_comname (comname);
  comname = savestring (comname, extra - comname);
#else /* not TEK_PROG_HACK */
  validate_comname (comname);
#endif /* not TEK_PROG_HACK */

  c = lookup_cmd (&tem, cmdlist, "", -1, 1);
  if (c)
    {
      if (c->class == (int) class_user || c->class == (int) class_alias)
	tem = "Redefine command \"%s\"? ";
      else
	tem = "Really redefine built-in command \"%s\"? ";
      if (!query (tem, comname))
	ui_badnews(-1,"Command \"%s\" not redefined.", comname);
    }

  if (from_tty)
    {
      ui_fprintf(stdout, "Type commands for definition of \"%s\".\n\
End with a line saying just \"end\".\n", comname);
      ui_fflush (stdout);
    }

#ifdef TEK_PROG_HACK
  if (*extra)
    {
      cmds = (struct command_line *) xmalloc (sizeof (struct command_line));
      cmds->cmd = (struct cmd_list_element *) INVALID_CORE_ADDR;
      cmds->line = (char *) parse_string_list (extra);
      cmds->next = read_command_lines (3);
    }
  else
    cmds = read_command_lines (3);
#else /* not TEK_PROG_HACK */
  comname = savestring (comname, strlen (comname));

  cmds = read_command_lines ();
#endif /* not TEK_PROG_HACK */

  if (c && c->class == (int) class_user)
    free_command_lines (&c->function);

  add_com (comname, class_user, cmds,
	   (c && c->class == (int) class_user)
	   ? c->doc : savestring ("User-defined.", 13));
}

static void
document_command (comname, from_tty)
     char *comname;
     int from_tty;
{
  struct command_line *doclines;
  register struct cmd_list_element *c;
  char *tem = comname;
#ifdef TEK_PROG_HACK
  char *extra;

  extra = validate_comname (comname);
  if (*extra)
    ui_badnews(-1,"Junk in argument list: \"%s\"", extra);
#else /* not TEK_PROG_HACK */
  validate_comname (comname);
#endif /* not TEK_PROG_HACK */

  c = lookup_cmd (&tem, cmdlist, "", 0, 1);

  if (c->class != (int) class_user)
    ui_badnews(-1,"Command \"%s\" is built-in.", comname);

  if (from_tty)
    ui_fprintf(stdout, "Type documentation for \"%s\".\n\
End with a line saying just \"end\".\n", comname);

#ifdef TEK_PROG_HACK
  doclines = read_command_lines (0);
#else /* not TEK_PROG_HACK */
  doclines = read_command_lines ();
#endif /* not TEK_PROG_HACK */
  if (c->doc) free (c->doc);

  {
    register struct command_line *cl1;
    register int len = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      len += strlen (cl1->line) + 1;
 
   c->doc = (char *) xmalloc (len + 1);
    *c->doc = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      {
	strcat (c->doc, cl1->line);
	if (cl1->next)
	  strcat (c->doc, "\n");
      }
  }

  free_command_lines (&doclines);
} 

static void
copying_info ()
{
  immediate_quit++;
  printf_filtered ("		    GDB GENERAL PUBLIC LICENSE\n\
		    (Clarified 11 Feb 1988)\n\
\n\
 Copyright (C) 1988 Richard M. Stallman\n\
 Everyone is permitted to copy and distribute verbatim copies\n\
 of this license, but changing it is not allowed.\n\
 You can also use this wording to make the terms for other programs.\n\
\n\
  The license agreements of most software companies keep you at the\n\
mercy of those companies.  By contrast, our general public license is\n\
intended to give everyone the right to share GDB.  To make sure that\n\
you get the rights we want you to have, we need to make restrictions\n\
that forbid anyone to deny you these rights or to ask you to surrender\n\
the rights.  Hence this license agreement.\n\
\n\
  Specifically, we want to make sure that you have the right to give\n\
away copies of GDB, that you receive source code or else can get it\n\
if you want it, that you can change GDB or use pieces of it in new\n\
free programs, and that you know you can do these things.\n");

  printf_filtered ("\
  To make sure that everyone has such rights, we have to forbid you to\n\
deprive anyone else of these rights.  For example, if you distribute\n\
copies of GDB, you must give the recipients all the rights that you\n\
have.  You must make sure that they, too, receive or can get the\n\
source code.  And you must tell them their rights.\n\
\n\
  Also, for our own protection, we must make certain that everyone\n\
finds out that there is no warranty for GDB.  If GDB is modified by\n\
someone else and passed on, we want its recipients to know that what\n\
they have is not what we distributed, so that any problems introduced\n\
by others will not reflect on our reputation.\n\
\n\
  Therefore we (Richard Stallman and the Free Software Foundation,\n\
Inc.) make the following terms which say what you must do to be\n\
allowed to distribute or change GDB.\n");

  printf_filtered ("\
			COPYING POLICIES\n\
\n\
  1. You may copy and distribute verbatim copies of GDB source code as\n\
you receive it, in any medium, provided that you conspicuously and\n\
appropriately publish on each copy a valid copyright notice \"Copyright\n\
\(C) 1988 Free Software Foundation, Inc.\" (or with whatever year is\n\
appropriate); keep intact the notices on all files that refer\n\
to this License Agreement and to the absence of any warranty; and give\n\
any other recipients of the GDB program a copy of this License\n\
Agreement along with the program.  You may charge a distribution fee\n\
for the physical act of transferring a copy.\n\
\n\
  2. You may modify your copy or copies of GDB or any portion of it,\n\
and copy and distribute such modifications under the terms of\n\
Paragraph 1 above, provided that you also do the following:\n\
\n\
    a) cause the modified files to carry prominent notices stating\n\
    that you changed the files and the date of any change; and\n");

  printf_filtered ("\
    b) cause the whole of any work that you distribute or publish,\n\
    that in whole or in part contains or is a derivative of GDB\n\
    or any part thereof, to be licensed to all third parties on terms\n\
    identical to those contained in this License Agreement (except that\n\
    you may choose to grant more extensive warranty protection to some\n\
    or all third parties, at your option).\n\
\n");
  printf_filtered ("\
    c) if the modified program serves as a debugger, cause it\n\
    when started running in the simplest and usual way, to print\n\
    an announcement including a valid copyright notice\n\
    \"Copyright (C) 1988 Free Software Foundation, Inc.\" (or with\n\
    the year that is appropriate), saying that there is no warranty\n\
    (or else, saying that you provide a warranty) and that users may\n\
    redistribute the program under these conditions, and telling the user\n\
    how to view a copy of this License Agreement.\n\
\n\
    d) You may charge a distribution fee for the physical act of\n\
    transferring a copy, and you may at your option offer warranty\n\
    protection in exchange for a fee.\n\
\n\
Mere aggregation of another unrelated program with this program (or its\n\
derivative) on a volume of a storage or distribution medium does not bring\n\
the other program under the scope of these terms.\n");

  printf_filtered ("\
  3. You may copy and distribute GDB (or a portion or derivative of it,\n\
under Paragraph 2) in object code or executable form under the terms of\n\
Paragraphs 1 and 2 above provided that you also do one of the following:\n\
\n\
    a) accompany it with the complete corresponding machine-readable\n\
    source code, which must be distributed under the terms of\n\
    Paragraphs 1 and 2 above; or,\n\
\n\
    b) accompany it with a written offer, valid for at least three\n\
    years, to give any third party free (except for a nominal\n\
    shipping charge) a complete machine-readable copy of the\n\
    corresponding source code, to be distributed under the terms of\n\
    Paragraphs 1 and 2 above; or,\n\n");

  printf_filtered ("\
    c) accompany it with the information you received as to where the\n\
    corresponding source code may be obtained.  (This alternative is\n\
    allowed only for noncommercial distribution and only if you\n\
    received the program in object code or executable form alone.)\n\
\n\
For an executable file, complete source code means all the source code for\n\
all modules it contains; but, as a special exception, it need not include\n\
source code for modules which are standard libraries that accompany the\n\
operating system on which the executable file runs.\n");

  printf_filtered ("\
  4. You may not copy, sublicense, distribute or transfer GDB\n\
except as expressly provided under this License Agreement.  Any attempt\n\
otherwise to copy, sublicense, distribute or transfer GDB is void and\n\
your rights to use the program under this License agreement shall be\n\
automatically terminated.  However, parties who have received computer\n\
software programs from you with this License Agreement will not have\n\
their licenses terminated so long as such parties remain in full compliance.\n\
\n\
");
  printf_filtered ("\
  5. If you wish to incorporate parts of GDB into other free\n\
programs whose distribution conditions are different, write to the Free\n\
Software Foundation at 675 Mass Ave, Cambridge, MA 02139.  We have not yet\n\
worked out a simple rule that can be stated here, but we will often permit\n\
this.  We will be guided by the two goals of preserving the free status of\n\
all derivatives of our free software and of promoting the sharing and reuse\n\
of software.\n\
\n\
In other words, go ahead and share GDB, but don't try to stop\n\
anyone else from sharing it farther.  Help stamp out software hoarding!\n\
");
  immediate_quit--;
}

static void
warranty_info ()
{
  immediate_quit++;
  printf_filtered ("			 NO WARRANTY\n\
\n\
  BECAUSE GDB IS LICENSED FREE OF CHARGE, WE PROVIDE ABSOLUTELY NO\n\
WARRANTY, TO THE EXTENT PERMITTED BY APPLICABLE STATE LAW.  EXCEPT\n\
WHEN OTHERWISE STATED IN WRITING, FREE SOFTWARE FOUNDATION, INC,\n\
RICHARD M. STALLMAN AND/OR OTHER PARTIES PROVIDE GDB \"AS IS\" WITHOUT\n\
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT\n\
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n\
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND\n\
PERFORMANCE OF GDB IS WITH YOU.  SHOULD GDB PROVE DEFECTIVE, YOU\n\
ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n");

  printf_filtered ("\
 IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW WILL RICHARD M.\n\
STALLMAN, THE FREE SOFTWARE FOUNDATION, INC., AND/OR ANY OTHER PARTY\n\
WHO MAY MODIFY AND REDISTRIBUTE GDB, BE LIABLE TO\n\
YOU FOR DAMAGES, INCLUDING ANY LOST PROFITS, LOST MONIES, OR OTHER\n\
SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR\n\
INABILITY TO USE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA\n\
BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY THIRD PARTIES OR A\n\
FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS) GDB, EVEN\n\
IF YOU HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, OR FOR\n\
ANY CLAIM BY ANY OTHER PARTY.\n");
  immediate_quit--;
}

  
static void
print_gdb_version ()
{
  printf_filtered ("\
This version of GDB contains a simulator of a 4-processor, 8-CMMU 88000 system.\n");
}

#ifdef TEK_HACK
extern char _rcsid[];
#endif /* TEK_HACK */

static void
version_info ()
{
  immediate_quit++;
  print_gdb_version ();
#ifdef TEK_HACK
    ui_fprintf(stdout, "%s\n", _rcsid);
#endif /* TEK_HACK */
  immediate_quit--;
}

/* xgdb calls this to reprint the usual GDB prompt.  */

void
print_prompt ()
{
  extern int selected_processor;

  ui_fflush();
  ui_newprompt();
#ifdef TEK_PROG_HACK
  ui_fprintf(stdout, "[%d] %s", selected_processor, gbl_prompt);
#else /* not TEK_PROG_HACK */
  ui_fprintf(stdout, "%s", prompt);
#endif /* not TEK_PROG_HACK */
  ui_fflush (stdout);
}

/* Command to specify a prompt string instead of "(gdb) ".  */

#ifndef TEK_PROG_HACK
static void
set_prompt_command (text)
     char *text;
{
  char *p, *q;
  register int c;
  char *new;

  if (text == 0)
    error_no_arg ("string to which to set prompt");

  new = (char *) xmalloc (strlen (text) + 2);
  p = text; q = new;
  while (c = *p++)
    {
      if (c == '\\')
	{
	  /* \ at end of argument is used after spaces
	     so they won't be lost.  */
	  if (*p == 0)
	    break;
	  c = parse_escape (&p);
	  if (c == 0)
	    break; /* C loses */
	  else if (c > 0)
	    *q++ = c;
	}
      else
	*q++ = c;
    }
  if (*(p - 1) != '\\')
    *q++ = ' ';
  *q++ = '\0';
  new = (char *) xrealloc (new, q - new);
  free (prompt);
  prompt = new;
}
#endif /* not TEK_PROG_HACK */

static void
quit_command ()
{
  extern int simulator;
  if (have_inferior_p () && !remote_debugging)
    {
#ifdef TEK_HACK
      /* If the process stopped because of SIGKILL, then it cannot be continued,
	 so skip the message asking whether to quit.
	 This addresses Tektronix bug BLK1450. */
      if (stop_signal == SIGKILL ||
	  query ("The program is running.  Quit anyway? "))
#else
      if (query ("The program is running.  Quit anyway? "))
#endif
	{
	  /* Prevent any warning message from reopen_exec_file, in case
	     we have a core file that's inconsistent with the exec file.  */
	  exec_file_command (0, 0);
	  kill_inferior_fast ();
	}
      else
	ui_badnews(-1,"Not confirmed.");
    }
  remote_close(1);
  /* Save the history information if it is appropriate to do so.  */
  if (write_history_p && history_filename)
    write_history (history_filename);
  ui_byebye();
  exit (0);
}

int
input_from_terminal_p ()
{
  return instream == stdin;
}

static void
pwd_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  char getwd_path[MAXPATHLEN];

  if (arg) ui_badnews(-1,"The \"pwd\" command does not take an argument: %s", arg);
  getwoid (getwd_path);
  if (strcmp (getwd_path, current_directory))
    ui_fprintf(stdout, "Working directory %s\n(actually %s)\n",
	    current_directory, getwd_path);
  else
    ui_fprintf(stdout, "Working directory %s\n", current_directory);
}

static void
cd_command (dir, from_tty)
     char *dir;
     int from_tty;
{
  auto char newdirbuf[MAXPATHLEN];
  int dirlen;
  int change;
  char *p;

  if (dir == 0)
    error_no_arg ("new working directory");
  dirlen = strlen(dir);
  if (dirlen >= MAXPATHLEN)
    ui_badnews(-1, "Directory name too long\n");

  /* Build the new directory name. */
  if (dir[0] == '/')
    strcpy(newdirbuf, dir);
  else
    {
      int oldlen = strlen(current_directory);
      if (oldlen + dirlen + 1 /* for '/' */ >= MAXPATHLEN)
	ui_badnews(-1, "Directory name too long\n");
      strcpy(newdirbuf, current_directory);
      newdirbuf[oldlen] = '/';
      strcpy(&newdirbuf[oldlen+1], dir);
    }

  /* Reduce the constructed path name.
     Keep looping until no more reductions can be applied. */
  do
    {
      change = 0;

      /* Replace leading "/../" with "/". */
      while (!strncmp(newdirbuf, "/../", 4))
	{
	  strcpy(newdirbuf, newdirbuf+3);
	  change = 1;
	}

      /* Change path "/.." to "/". */
      if (!strcmp(newdirbuf, "/.."))
	{
	  newdirbuf[1] = '\0';
	  break;
	}

      /* Loop to handle substring reductions. */
      p = newdirbuf;
      while (*p)
	{
		/* Eliminate trailing "/" or "/." */
	  if (p != newdirbuf && (!strcmp (p, "/") || !strcmp (p, "/.")))
	    *p = '\0', change = 1;
		/* Change "//" to "/" */
	  else if (!strncmp (p, "//", 2))
	    strcpy(p, p+1), change = 1;
		/* Change "/./" to "/" */
	  else if (!strncmp (p, "/./", 3))
	    strcpy (p, p+2), change = 1;
		/* Change "/dir/.." to "/" */
	  else if (!strncmp (p, "/..", 3) && (p[3] == 0 || p[3] == '/') &&
		   p != newdirbuf)
	    {
	      char *q = p;
	      while (q != newdirbuf && q[-1] != '/') q--;
	      if (q-1 == newdirbuf)
		{
			/* Path begins "/dir/..".
			   Replace substring with "/". */
		  strcpy (q, p+3);
		  p = q;
		  change = 1;
		}
	      else if (q != newdirbuf)
		{
			/* "/dir/.." occurs after beginning of string.
			   Delete entire substring. */
		  strcpy (q-1, p+3);
		  p = q-1;
		  change = 1;
		}
	    }
	  else p++;
	}
    }
  while (change);

  /* Issue the chdir and check that it works before committing to the new
     path name. */
  if (chdir (newdirbuf) < 0)
    perror_with_name (newdirbuf);

  /* Install the new path name. */
  strcpy(dirbuf, newdirbuf);

  if (from_tty)
    pwd_command ((char *) 0, 1);
}

static void
source_command (file)
     char *file;
{
  FILE *stream;
  struct cleanup *cleanups;
  struct source_stack_structure *s;

  if (file == 0)
    error_no_arg ("file to read commands from");

  stream = fopen (file, "r");
  if (stream == 0)
    perror_with_name (file);

  cleanups = make_cleanup (source_stack_cleanup, source_stack);

  /* Stack the name of this file, for "info files". */
  s = (struct source_stack_structure *)
      xmalloc(sizeof(struct source_stack_structure) + strlen(file));
  strcpy(s->file, file);
  s->previous_instream = instream;
  s->next = source_stack;
  source_stack = s;

  instream = stream;

  command_loop ();

  do_cleanups (cleanups);
}

info_active_sources()
{
  register struct source_stack_structure *s = source_stack;

  if (!s)
    ui_fprintf(stdout, "No active source scripts.\n");
  else if (!s->next)	/* one-line report */
    ui_fprintf(stdout, "Active source script is \"%s\".\n", s->file);
  else
  {
    /* Loop through sources and report filenames. */
    ui_fprintf(stdout,
	       "Active source scripts (first is most recently started):\n");
    while (s)
    {
      ui_fprintf(stdout, "  \"%s\"\n", s->file);
      s = s->next;
    }
  }
}

static void
echo_command (text)
     char *text;
{
  char *p = text;
  register int c;

  if (text)
    while (c = *p++)
      {
	if (c == '\\')
	  {
	    /* \ at end of argument is used after spaces
	       so they won't be lost.  */
	    if (*p == 0)
	      return;

	    c = parse_escape (&p);
	    if (c >= 0)
	      ui_putc (c, stdout);
	  }
	else
	  ui_putc (c, stdout);
      }
}
 
static void
dump_me_command ()
{
  if (query ("Should GDB dump core? "))
    {
      signal (SIGQUIT, SIG_DFL);
      kill (getpid (), SIGQUIT);
    }
}

int
parse_binary_operation (caller, arg)
     char *caller, *arg;
{
  int length;

  if (!arg || !*arg)
    return 1;

  length = strlen (arg);

  while (arg[length - 1] == ' ' || arg[length - 1] == '\t')
    length--;

  if (!strncmp (arg, "on", length)
      || !strncmp (arg, "1", length)
      || !strncmp (arg, "yes", length))
    return 1;
  else
    if (!strncmp (arg, "off", length)
	|| !strncmp (arg, "0", length)
	|| !strncmp (arg, "no", length))
      return 0;
    else
      ui_badnews(-1,"\"%s\" not given a binary valued argument.", caller);
}

/* Functions to manipulate command line editing control variables.  */

static void
set_editing (arg, from_tty)
     char *arg;
     int from_tty;
{
#ifdef TEK_HACK
  if (! usingX)
#endif /* TEK_HACK */
    command_editing_p = parse_binary_operation ("set command-editing", arg);
}

static void
editing_info (arg, from_tty)
     char *arg;
     int from_tty;
{
  int offset;

  printf_filtered ("Interactive command editing is %s.\n",
	  command_editing_p ? "on" : "off");

  printf_filtered ("History expansion of command input is %s.\n",
	  history_expansion_p ? "on" : "off");
  printf_filtered ("Writing of a history record upon exit is %s.\n",
	  write_history_p ? "enabled" : "disabled");
  printf_filtered ("The size of the history list (number of stored commands) is %d.\n",
	  history_size);
  printf_filtered ("The name of the history record is \"%s\".\n\n",
	  history_filename ? history_filename : "");
  printf_filtered ("This list of the last %d commands is:\n\n",
	  history_size);
  for (offset = 0; offset < history_size; offset++)
    {
      struct _hist_entry {
	char *line;
	char *data;
      } *retval, *history_get();
      extern int history_base;

      retval = history_get (history_base + offset);
      if (!retval) break;

      printf_filtered ("%5d  %s\n", history_base + offset,
	      retval->line);
    }
}

static void
set_history_expansion (arg, from_tty)
     char *arg;
     int from_tty;
{
  history_expansion_p = parse_binary_operation ("set history expansion", arg);
}

static void
set_history_write (arg, from_tty)
     char *arg;
     int from_tty;
{
  write_history_p = parse_binary_operation ("set history write", arg);
}

static void
set_history (arg, from_tty)
     char *arg;
     int from_tty;
{
  ui_fprintf(stdout, "\"set history\" must be followed by the name of a history subcommand.\n");
  help_list (sethistlist, "set history ", -1, stdout);
}

static void
set_history_size (arg, from_tty)
     char *arg;
     int from_tty;
{
  if (!*arg)
    error_no_arg ("set history size");

  history_size = atoi (arg);
}

static void
set_history_filename (arg, from_tty)
     char *arg;
     int from_tty;
{
  int i = strlen (arg) - 1;
  
  free (history_filename);
  
  while (i > 0 && (arg[i] == ' ' || arg[i] == '\t'))
    i--;

  if (!*arg)
    history_filename = (char *) 0;
  else
    history_filename = savestring (arg, i + 1);
}

int info_verbose;

static void
set_verbose_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  info_verbose = parse_binary_operation ("set verbose", arg);
}

static void
verbose_info (arg, from_tty)
     char *arg;
     int from_tty;
{
  if (arg)
    ui_badnews(-1,"\"info verbose\" does not take any arguments.\n");
  
  ui_fprintf(stdout, "Verbose printing of information is %s.\n",
	  info_verbose ? "on" : "off");
}

static void
float_handler ()
{
  ui_badnews(-1,"Invalid floating value encountered or computed.");
}


static void
initialize_cmd_lists ()
{
  cmdlist = (struct cmd_list_element *) 0;
  infolist = (struct cmd_list_element *) 0;

  info_cmd =
  add_prefix_cmd ("info", class_info, info_command,
		  "Generic command for printing status.",
		  &infolist, "info ", 0, &cmdlist);

  enablelist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  enable_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_HACK */
  disablelist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  disable_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_HACK */
  deletelist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  gdbdelete_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_PROG_HACK */
  enablebreaklist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  enablebreak_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_PROG_HACK */
  setlist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  set_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_PROG_HACK */
  sethistlist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  sethist_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_PROG_HACK */
  unsethistlist = (struct cmd_list_element *) 0;
#ifdef TEK_PROG_HACK
  unsethist_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_PROG_HACK */
}

#ifdef TEK_HACK

reset_stdout(oldfd)
  int oldfd;
{
  fflush(stdout);
  close(1);
  if (dup(oldfd) != 1) {
    ui_badnews(-2, "Standard out dup failed!");
  }
  close(oldfd);
  ui_endRedirectOut();
}

redirect_out_command(args)
    char *args;
{
  register int tty;
  char *filename, *cptr = args;
  int len = 0;
  int oldstdout;
  struct cleanup *old_chain;

  /* Get filename from args */
  while (cptr && *cptr != ' ' && *cptr != '\t') {
	len++;
        cptr++;
  }
  filename = (char *) xmalloc(len + 1);
  strncpy(filename, args, len);
  filename[len] = '\0';
  oldstdout = dup(1);
  close(1);
  tty = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0775);
  free(filename);
  if (tty == -1) {
    ui_badnews(-1, "Can't open %s for output redirection", filename);
  }
  ui_startRedirectOut();
  old_chain = make_cleanup(reset_stdout, oldstdout);
  execute_command(0, args + len, 0);
  do_cleanups(old_chain);
}
#endif /*TEK_HACK*/
void
make_button_commands ()
{
/* Commands added to enable button adding/deleting.  User should only
 * access these from a startup file, although it is possible to use these
 * from the command line.  These are undefined if no X interface is running.
 * DL 8/2/89
 */
  add_com("button", class_obscure, ui_button, "Add a button associated with a command.");
  add_com("unbutton", class_obscure, ui_unbutton, "Delete a button associated with a command.");
}

static void
initialize_main ()
{
  char *tmpenv;
  struct cmd_list_element *new;
  /* Command line editing externals.  */
  extern int (*rl_completion_entry_function)();
  extern char *rl_completer_word_break_characters;
  
  /* Set default verbose mode on.  */
  info_verbose = 1;

#ifndef TEK_PROG_HACK
  prompt = savestring ("(gdb) ", 6);
#endif /* not TEK_PROG_HACK */

  /* Set the important stuff up for command editing.  */
  if (! usingX) command_editing_p = 1;
  history_expansion_p = 1;
  write_history_p = 0;
  
  if (tmpenv = getenv ("HISTSIZE"))
    history_size = atoi (tmpenv);
  else
    history_size = 256;

  stifle_history (history_size);

  if (tmpenv = getenv ("GDBHISTFILE"))
    history_filename = savestring (tmpenv, strlen(tmpenv));
  else
    history_filename = savestring ("./.gdb_history", 14);

  read_history (history_filename);

  /* Setup important stuff for command line editing.  */
  rl_completion_entry_function = (int (*)()) symbol_completion_function;
  rl_completer_word_break_characters = gdb_completer_word_break_characters;

  /* Define the classes of commands.
     They will appear in the help list in the reverse of this order.  */

  add_cmd ("obscure", class_obscure, 0, "Obscure features.", &cmdlist);
#ifdef TEK_PROG_HACK
  add_cmd ("conditionals", class_conditional, 0, "Commands for conditional execution.\n\
These include a command for executing \"while loops\" and commands that\n\
implement an \"if-else\" like facility.", &cmdlist);
#endif /* TEK_PROG_HACK */
  add_cmd ("alias", class_alias, 0, "Aliases of other commands.", &cmdlist);
#ifdef  TEK_PROG_HACK
  add_cmd ("user", class_user, 0, "User-defined commands.\n\
The commands in this class are those defined by the user.\n\
Use the \"define\" command to define a command.\n\
Use \"info user COMMAND\" to print the definition of COMMAND.\n\
Use \"info user\" with no argument to print the definitions of all\n\
user-defined commands.", &cmdlist);
#else /* not TEK_PROG_HACK */
  add_cmd ("user", class_user, 0, "User-defined commands.\n\
The commands in this class are those defined by the user.\n\
Use the \"define\" command to define a command.", &cmdlist);
#endif /* not TEK_PROG_HACK */
  add_cmd ("support", class_support, 0, "Support facilities.", &cmdlist);
  add_cmd ("status", class_info, 0, "Status inquiries.", &cmdlist);
  add_cmd ("files", class_files, 0, "Specifying and examining files.", &cmdlist);
  add_cmd ("breakpoints", class_breakpoint, 0, "Making program stop at certain points.", &cmdlist);
  add_cmd ("data", class_vars, 0, "Examining data.", &cmdlist);
  add_cmd ("stack", class_stack, 0, "Examining the stack.\n\
The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\
counting from zero for the innermost (currently executing) frame.\n\n\
At any time gdb identifies one frame as the \"selected\" frame.\n\
Variable lookups are done with respect to the selected frame.\n\
When the program being debugged stops, gdb selects the innermost frame.\n\
The commands below can be used to select other frames by number or address.",
           &cmdlist);
  add_cmd ("running", class_run, 0, "Running the program.", &cmdlist);

  add_com ("pwd", class_files, pwd_command,
	   "Print working directory.  This is used for your program as well.");
  add_com ("cd", class_files, cd_command,
	   "Set working directory to DIR for debugger and program being debugged.\n\
The change does not take effect for the program being debugged\n\
until the next time it is started.");

#ifdef TEK_HACK
  add_com ("redirect-output", class_support, redirect_out_command, "Redirect output for this command to a file.");
  add_com_alias (">", "redirect-output", class_support, 1);
#endif /* not TEK_HACK */
#ifndef TEK_PROG_HACK
  add_cmd ("prompt", class_support, set_prompt_command,
	   "Change gdb's primary prompt from the default of \"(gdb)\"",
	   &setlist);
#endif /* not TEK_PROG_HACK */
  add_com ("echo", class_support, echo_command,
	   "Print a constant string.  Give string as argument.\n\
C escape sequences may be used in the argument.\n\
No newline is added at the end of the argument;\n\
use \"\\n\" if you want a newline to be printed.\n\
Since leading and trailing whitespace are ignored in command arguments,\n\
if you want to print some you must use \"\\\" before leading whitespace\n\
to be printed or after trailing whitespace.");
  add_com ("document", class_support, document_command,
	   "Document a user-defined command.\n\
Give command name as argument.  Give documentation on following lines.\n\
End with a line of just \"end\".");
  add_com ("define", class_support, define_command,
	   "Define a new command name.  Command name is argument.\n\
Definition appears on following lines, one command per line.\n\
End with a line of just \"end\".\n\
Use the \"document\" command to give documentation for the new command.\n\
Commands defined in this way do not take arguments.");

  add_com ("source", class_support, source_command,
	   "Read commands from a file named FILE.\n\
Note that the file \".gdbinit\" is read automatically in this way\n\
when gdb is started.");
  add_com ("quit", class_support, quit_command, "Exit gdb.");
  add_com ("help", class_support, help_command, "Print list of commands.");
  add_com_alias ("q", "quit", class_support, 1);
  add_com_alias ("h", "help", class_support, 1);

#ifdef TEK_PROG_HACK
  new =
#endif /* TEK_PROG_HACK */
  add_cmd ("verbose", class_support, set_verbose_command,
	   "Change the number of informational messages gdb prints.",
	   &setlist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) set_cmd;
#endif /* TEK_PROG_HACK */
  add_info ("verbose", verbose_info,
	    "Status of gdb's verbose printing option.\n");

  add_com ("dump-me", class_obscure, dump_me_command,
	   "Get fatal error; make debugger dump its core.");

#ifdef TEK_PROG_HACK
  new =
#endif /* TEK_PROG_HACK */
  add_cmd ("editing", class_support, set_editing,
	   "Enable or disable command line editing.\n\
Use \"on\" to enable to enable the editing, and \"off\" to disable it.\n\
Without an argument, command line editing is enabled.", &setlist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) set_cmd;

  new =
#endif /* TEK_PROG_HACK */
  add_prefix_cmd ("history", class_support, set_history,
		  "Generic command for setting command history parameters.",
		  &sethistlist, "set history ", 0, &setlist);
#ifdef TEK_PROG_HACK
  if (new)
    {
      new->aux = (char *) set_cmd;
      sethist_cmd = new;
    }

  new =
#endif /* TEK_PROG_HACK */
  add_cmd ("expansion", no_class, set_history_expansion,
	   "Enable or disable history expansion on command input.\n\
Without an argument, history expansion is enabled.", &sethistlist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) sethist_cmd;

  new =
#endif /* TEK_PROG_HACK */
  add_cmd ("write", no_class, set_history_write,
	   "Enable or disable saving of the history record on exit.\n\
Use \"on\" to enable to enable the saving, and \"off\" to disable it.\n\
Without an argument, saving is enabled.", &sethistlist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) sethist_cmd;

  new =
#endif /* TEK_PROG_HACK */
  add_cmd ("size", no_class, set_history_size,
	   "Set the size of the command history, \n\
ie. the number of previous commands to keep a record of.", &sethistlist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) sethist_cmd;

  new =
#endif /* TEK_PROG_HACK */
  add_cmd ("filename", no_class, set_history_filename,
	   "Set the filename in which to record the command history\n\
 (the list of previous commands of which a record is kept).", &sethistlist);
#ifdef TEK_PROG_HACK
  if (new)
    new->aux = (char *) sethist_cmd;
#endif /* TEK_PROG_HACK */

  add_com_alias ("i", "info", class_info, 1);

  add_info ("editing", editing_info, "Status of command editor.");

  add_info ("copying", copying_info, "Conditions for redistributing copies of GDB.");
  add_info ("warranty", warranty_info, "Various kinds of warranty you do not have.");
  add_info ("version", version_info, "Report what version of GDB this is.");
#ifdef TEK_PROG_HACK
  init_cmd_pointers ();
#endif /* TEK_PROG_HACK */
#ifdef TEK_HACK
  {  char *p;
  
     p = "echo";
     echo_p = lookup_cmd (&p, cmdlist, "", -1, 1);
     if (echo_p == 0)
	ui_badnews(1, "Internal: \"Echo\" not defined.");
  }
#endif /* TEK_HACK */
}
@


1.69
log
@Now we close the remote tty line before quiting.
@
text
@d4 2
a5 2
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/main.c,v 1.68 90/11/15 19:28:00 robertb Exp Locker: robertb $
   $Locker: robertb $
d1881 1
a1881 3
  if (remote_debugging && !simulator) {
    remote_close();
  }
@


1.68
log
@Added $ignoreeof convenience variable so that control-D on a blank
line does have to make g88 quit.
@
text
@d4 1
a4 1
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/main.c,v 1.67 90/09/29 21:01:14 robertb Exp Locker: robertb $
d1860 1
d1881 3
@


1.67
log
@Shortened the start up message.
@
text
@d4 1
a4 1
   $Header: /tmp_mnt/u2/cs568/g88/RCS/main.c,v 1.66 90/08/19 21:21:53 robertb Exp Locker: robertb $
d843 3
a845 1
	  quit_command();
@


1.66
log
@ deleted redundant include.
@
text
@d4 1
a4 1
   $Header: /home/vlsi/u2/cs568/g88/RCS/main.c,v 1.65 90/07/01 12:26:36 robertb Exp Locker: robertb $
d1777 2
a1778 6
  ui_fprintf(stdout, "GDB %s, Copyright (C) 1989 Free Software Foundation, Inc.\n\
There is ABSOLUTELY NO WARRANTY for GDB; type \"info warranty\" for details.\n\
GDB is free software and you are welcome to distribute copies of it\n\
under certain conditions; type \"info copying\" to see the conditions.\n\
This version of GDB contains a simulator of a 4-processor, 8-CMMU 88000 system.\n\
Type \"attach sim\" to use the simulator\n", version);
@


1.65
log
@Fixed prompt messages so that just one [proc#] is emitted.
@
text
@d4 1
a4 1
   $Header: /home/bigbird/Usr.U6/robertb/gdb/RCS/main.c,v 1.64 90/06/30 17:57:51 robertb Exp Locker: robertb $
a82 1
#include <sys/param.h>
@


1.64
log
@Deleted large useless comment at top of file.
Switched back to old gdb warrenty and copying info routines.
Put some things in #ifdef TEK_PROG_HACK so that it would compile
w/ this off.
Got old read_command_lines() function so that this would like
w/o the new crude in programmer.c (i.e., w/ TEK_PROG_HACK off).
Added processor number to several places where prompt is displayed.
@
text
@d4 1
a4 1
   $Header: /home/bigbird/Usr.U6/robertb/gdb/RCS/main.c,v 1.63 90/03/22 10:58:51 jrb Exp Locker: robertb $
a871 2
  extern int selected_processor;
  
d888 1
a888 1
  ui_fprintf(stdout, "[%d] %s", selected_processor, gbl_prompt);
a908 1
  extern int selected_processor;
d916 1
a916 1
      ui_fprintf(stdout, "[%d] %s", selected_processor, prompt);
@


1.63
log
@changed quit_command() to not use kill_inferior() and use
kill_inferior_fast() instead. kill_inferior() will call error()
on a ptrace error, which will longjmp back into the command loop,
so in some circumstances getting out of gdb can be a tad tough.
kill_inferior_fast doesn't call error() amongst other things.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.62 90/02/23 15:32:19 andrew Exp $
   $Locker: jrb $
a796 1

d824 1
d827 1
d833 1
d835 3
d839 1
d872 2
d890 1
a890 1
  ui_fprintf(stdout, "%s", gbl_prompt);
d911 1
d919 1
a919 1
      ui_fprintf(stdout, prompt);
d1298 51
a1608 2
#ifdef TEK_HACK
/* We'll read the COPYING file directly from the file system. */
a1609 54
copying_info()
{
        FILE *stream;
        char cp[1024];

	stream = fopen("/usr/local/bin/gnu/COPYING", "r");
	if (stream == 0)  {
	    printf_filtered("Can't find file \"/usr/local/bin/gnu/COPYING\" to print\n agreement on copying gdb.\nSee your Tektronix field office for more information.\n");
	    return;
	}
        while (fgets(cp, 1024, stream)) {
	    printf_filtered(cp);
        }
        fclose (stream);
}
/* We'll read the COPYING file directly from the file system, and get the
 * warranty info from it. */
static void
warranty_info()
/* This relies on having a line beginning with <whitespace>NO WARRANTY in the
 * COPYING file.  Yuck.
 * And on a line beginning <whitespace>END OF to end it.
 */
{
        FILE *stream;
        char cp[1024], *cptr;
        int foundit = 0;

	stream = fopen("/usr/local/bin/gnu/COPYING", "r");
	if (stream == 0)  {
	    printf_filtered("Can't find file \"/usr/local/bin/gnu/COPYING\" to print\n information on gdb warranty.\nSee your Tektronix field office for more information.\n");
	    return;
	}
        while (fgets(cp, 1024, stream)) {
    	    cptr = cp;
            while ((*cptr == ' ' || *cptr == '\t') && cptr < 
                cp + 1023) cptr++;
	    if (foundit) {
	        if (strncmp(cptr, "END OF", 6) == 0) 
		    break;
		else printf_filtered(cp);
            }
            else {
                if (strncmp(cptr, "NO WARRANTY", 11) == 0) {
		    foundit = 1;
		    printf_filtered(cp);
		}
   	    }
        }
        fclose (stream);
}
#endif /* TEK_HACK */
#if 0
static void
a1775 1
#endif /* 0 */
a1776 19
#ifdef TEK_HACK
static void
license_info()
{
        FILE *stream;
        char cp[1024];

	stream = fopen("/usr/local/bin/gnu/TEK-LICENSE-GDB", "r");
	if (stream == 0)  {
	    printf_filtered("Can't find file \"/usr/local/bin/gnu/TEK-LICENSE-GDB\" to print license agreement.\nSee your Tektronix field office for more information.\n");
	    return;
	}
        while (fgets(cp, 1024, stream)) {
	    printf_filtered(cp);
        }
        fclose (stream);
}
#endif /* TEK_HACK */
	
d1784 3
a1786 5
 under certain conditions; type \"info copying\" to see the conditions.\n",
	  version);
#ifdef TEK_HACK
  ui_fprintf(stdout, "Type \"info license\" to see the Tektronix gdb licensing agreement.\n");
#endif /* TEK_HACK */
d1809 2
d1814 1
a1814 1
  ui_fprintf(stdout, "%s", gbl_prompt);
a2562 1
#if 0
a2564 6
#endif
#ifdef TEK_HACK
  add_info ("copying", copying_info, "Conditions for redistributing copies of GDB.");
  add_info ("warranty", warranty_info, "Various kinds of warranty you do not have.");
  add_info ("license", license_info, "The Tektronix gdb licensing agreement.");
#endif /* TEK_HACK */
@


1.62
log
@Move initialization of info_cmd into initialize_cmd_lists, so that it is
assigned before it is used.  This fixes bug BLK2026.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.61 90/02/23 09:37:14 andrew Exp $
   $Locker: andrew $
d1897 1
a1897 1
	  kill_inferior ();
@


1.61
log
@Fix a bug in set_history_filename: the last character of the filename
was being truncated.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.60 90/02/21 11:06:08 andrew Exp $
d2286 6
a2291 3
#ifdef TEK_PROG_HACK
  info_cmd = (struct cmd_list_element *) 0;
#endif /* TEK_HACK */
d2573 1
a2574 5
  info_cmd =
#endif /* TEK_PROG_HACK */
  add_prefix_cmd ("info", class_info, info_command,
		  "Generic command for printing status.",
		  &infolist, "info ", 0, &cmdlist);
@


1.60
log
@With "set editing off", when reading a command line from the terminal,
if an I/O error is seen, don't treat it as EOF (quit command); request
another line.  This I/O error is seen when the user does ^Z, fg.
This still doesn't help when ^Z is typed during prompt for a secondary
input line, like the "yes or no", but in this case, behaving as though
^D had been entered is not quite so bad.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.59 90/02/20 11:41:06 andrew Exp $
a2249 1
  history_filename[i] = '\0';
@


1.59
log
@Make control-D work correctly.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.58 90/02/07 17:03:34 davidl Exp $
d218 1
d923 3
a925 1
      if (!ui_fgets(result, result_size, instream))
d927 11
a937 3
	  free (result);
	  ui_putc('\n', stdout);
	  return (char *) EOF;
d939 2
a940 1
      else if (return_result)
@


1.58
log
@Added protection against infinite loops caused by errors while
trying to read in source command files during initialization.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.57 90/02/07 16:04:45 andrew Exp $
   $Locker: davidl $
d213 1
d819 2
a824 1
#ifdef TEK_PROG_HACK
a825 3
#else /* not TEK_PROG_HACK */
	(*window_hook) (instream, prompt);
#endif /* not TEK_PROG_HACK */
d831 10
a840 9
#ifdef TEK_PROG_HACK
      execute_command (0, command_line_input (instream == stdin ? gbl_prompt : 0,
				      instream == stdin),
		       instream == stdin);
#else /* not TEK_PROG_HACK */
      execute_command (command_line_input (instream == stdin ? prompt : 0,
				      instream == stdin),
		       instream == stdin);
#endif /* not TEK_PROG_HACK */
d893 3
a895 2
   It never prints the PROMPT; if RETURN_RESULT is set it allocates
   space for whatever the user types and returns the result.  */
a903 3
#ifndef TEK_HACK
  extern char *index ();
#endif /* TEK_HACK */
d912 1
a912 1
#ifdef TEK_HACK
d922 7
a928 2
      ui_fgets(result, result_size, instream);
      if (return_result)
d947 1
a947 1
#endif /* TEK_HACK */
d954 1
a954 1
          if (c == -1 || c == '\n')
d966 6
a971 1
      if (return_result)
d977 4
a980 2
        return (char *) 0;
#ifdef TEK_HACK
a981 1
#endif /* TEK_HACK */
d1114 1
d1160 7
a1166 1
      if (!rl || rl == (char *) EOF) break;
a1275 53

#ifdef TEK_PROG_HACK
/* now in programmer.c */
#else /* not TEK_PROG_HACK */
struct command_line *
read_command_lines ()
{
  struct command_line *first = 0;
  register struct command_line *next, *tail = 0;
  register char *p, *p1;
  struct cleanup *old_chain = 0;

  while (1)
    {
      dont_repeat ();
      p = command_line_input (0, instream == stdin);
      /* Remove leading and trailing blanks.  */
      while (*p == ' ' || *p == '\t') p++;
      p1 = p + strlen (p);
      while (p1 != p && (p1[-1] == ' ' || p1[-1] == '\t')) p1--;

      /* Is this "end"?  */
      if (p1 - p == 3 && !strncmp (p, "end", 3))
	break;

      /* No => add this line to the chain of command lines.  */
      next = (struct command_line *) xmalloc (sizeof (struct command_line));
      next->line = savestring (p, p1 - p);
      next->next = 0;
      if (tail)
	{
	  tail->next = next;
	}
      else
	{
	  /* We just read the first line.
	     From now on, arrange to throw away the lines we have
	     if we quit or get an error while inside this function.  */
	  first = next;
	  old_chain = make_cleanup (free_command_lines, &first);
	}
      tail = next;
    }

  dont_repeat ();

  /* Now we are about to return the chain to our caller,
     so freeing it becomes his responsibility.  */
  if (first)
    discard_cleanups (old_chain);
  return first;
}
#endif /* not TEK_PROG_HACK */
@


1.57
log
@Delete support for obsolete help messages.
Change interface to watchpoint hit mechanism.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.56 90/01/05 13:01:19 jrb Exp $
   $Locker: andrew $
d575 2
a576 1
		source_command(homeinit);
d580 2
a581 1
   		source_command ("./gdb-dbx_script");
d585 2
a586 1
   		source_command ("/usr/local/bin/gnu/gdb-dbx_script");
d590 2
a591 1
   		source_command ("/usr/local/bin/gdb-dbx_script");
d595 2
a596 1
   		source_command ("/usr/local/gdb-dbx_script");
d602 2
a603 1
	source_command(source_command_file);
@


1.56
log
@Rob B.'s change to support remote_debug.
main.c was wiped out due to NFS mishap and has been restored.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.2 90/01/02 16:56:41 robertb Exp $
   $Locker: jrb $
a137 12
#ifdef TEK_HACK
/* Chains analogous to breakpoint supporting chains but for watchpoints */
struct cmd_list_element *wenable_cmd;
struct cmd_list_element *wenablelist;

struct cmd_list_element *wenablebreaklist;
struct cmd_list_element *wenablebreak_cmd;

struct cmd_list_element *enablewatchlist;
struct cmd_list_element *enablewatch_cmd;
#endif /* TEK_HACK */

a199 5
#ifdef TEK_HACK
extern int hunting_watchpoint;
extern int watchpoint_enabled_count;
#endif /* TEK_HACK */

a825 5
#ifdef TEK_HACK
			 /* firewall against watchpoints inadvertently left in the kernel */
			 remove_watchpoints ();
       watchpoint_enabled_count = hunting_watchpoint = 0; 
#endif /* TEK_HACK */
a837 5

#ifdef TEK_HACK
			/* do the commands associated with the lowest number watchpoint hit */
      do_watchpoint_commands();
#endif /* TEK_HACK */
@


1.55
log
@added comments
@
text
@d4 2
a5 2
   $Header: main.c,v 1.54 89/12/19 15:38:37 andrew Exp $
   $Locker:  $
d1928 1
a1928 1
  if (have_inferior_p ())
@


1.54
log
@Rewrote cd_com().
@
text
@d4 2
a5 2
   $Header: main.c,v 1.53 89/12/19 13:29:25 donhar Exp $
   $Locker: andrew $
d844 1
d862 1
@


1.53
log
@increase protection against watchpoints remaining
inadvertantly set after inferior stops.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.52 89/12/07 14:54:00 andrew Exp $
   $Locker: donhar $
a395 1
#if	defined (DG_HACK) && defined (USG)
a396 3
#else /* not DG_HACK or not USG */
  getwd (dirbuf);
#endif /* not DG_HACK or not USG */
d1964 2
d1967 4
a1970 9
#if	defined (DG_HACK) && defined (USG)
  getwoid (dirbuf);
#else /* not DG_HACK or not USG */
  getwd (dirbuf);
#endif /* not DG_HACK or not USG */

  if (strcmp (dirbuf, current_directory))
    ui_fprintf(stdout, "Working directory %s\n (canonically %s).\n",
	    current_directory, dirbuf);
d1972 1
a1972 1
    ui_fprintf(stdout, "Working directory %s.\n", current_directory);
d1980 2
a1981 1
  int len;
d1983 1
d1987 3
d1991 1
a1991 2
  len = strlen (dir);
  dir = savestring (dir, len - (len > 1 && dir[len-1] == '/'));
d1993 1
a1993 1
    current_directory = dir;
d1996 6
a2001 2
      current_directory = concat (current_directory, "/", dir);
      free (dir);
d2004 3
a2006 4
  /* Now simplify any occurrences of `.' and `..' in the pathname.  */

  change = 1;
  while (change)
a2007 1
      char *p;
d2010 2
a2011 1
      for (p = current_directory; *p;)
d2013 27
a2039 6
	  if (!strncmp (p, "/./", 2)
	      && (p[2] == 0 || p[2] == '/'))
	    strcpy (p, p + 2);
	  else if (!strncmp (p, "/..", 3)
		   && (p[3] == 0 || p[3] == '/')
		   && p != current_directory)
d2042 2
a2043 2
	      while (q != current_directory && q[-1] != '/') q--;
	      if (q != current_directory)
d2045 10
d2057 1
d2063 1
d2065 7
a2071 2
  if (chdir (dir) < 0)
    perror_with_name (dir);
@


1.52
log
@Add report of active source script(s) to output from "info files".
@
text
@d4 2
a5 2
   $Header: main.c,v 1.51 89/12/06 12:30:02 davidl Exp $
   $Locker: andrew $
d138 12
d848 1
@


1.51
log
@Refined strategy for dealing with startup scripts.  We now read, in order,
	1. gdb-dbx_script, if invoked with -dbx
	2. any file associated with -x option
	3. .gdbinit, if it exists, and -nx option not used
Thus any user-defined startup file can use dbx syntax if desired.

One may argue with the relative placement of (2) and (3) above, but it
is inherited from gdb3.2.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.50 89/12/05 09:23:20 donhar Exp $
   $Locker: davidl $
d164 8
d327 5
d345 14
d2032 1
d2041 1
a2041 1
  cleanups = make_cleanup (source_cleanup, instream);
d2043 8
d2056 21
@


1.50
log
@reset watchpoint-related variables in case they have been left set
by pathological exits from running code w/watchpoints on
@
text
@d4 2
a5 2
   $Header: main.c,v 1.49 89/11/27 12:33:44 davidl Exp $
   $Locker: donhar $
d349 1
d488 4
d493 1
d536 1
a536 2
    }

d543 41
d586 1
d588 1
a605 11
#ifdef TEK_HACK
        if (emulate_dbx) {
           sprintf(homeinit, "%s/gdb-dbx_script", getenv ("HOME"));
           if (access(homeinit, R_OK) == 0) {
		emulate_dbx = 0;
		ui_fprintf(stdout,"Reading %s for dbx emulation script.\n",
			homeinit);
		source_command(homeinit);
	   } 
        }
#endif /* TEK_HACK */
a618 22
#ifdef TEK_HACK
 /* Look in current directory, or in /usr/local/bin, or in /usr/local */
  if (emulate_dbx) {
     if (access("./gdb-dbx_script", R_OK) == 0) {
	ui_fprintf(stdout,"Reading ./gdb-dbx_script for dbx emulation script.\n");
	source_command ("./gdb-dbx_script");
     }
     else if (access("/usr/local/bin/gnu/gdb-dbx_script", R_OK) == 0) {
	ui_fprintf(stdout,"Reading /usr/local/bin/gnu/gdb-dbx_script for dbx emulation script.\n");
	source_command ("/usr/local/bin/gnu/gdb-dbx_script");
     }
     else if (access("/usr/local/bin/gdb-dbx_script", R_OK) == 0) {
	ui_fprintf(stdout,"Reading /usr/local/bin/gdb-dbx_script for dbx emulation script.\n");
	source_command ("/usr/local/bin/gdb-dbx_script");
     }
     else if (access("/usr/local/gdb-dbx_script", R_OK) == 0) {
	ui_fprintf(stdout,"Reading /usr/local/gdb-dbx_script for dbx emulation script.\n");
	source_command ("/usr/local/gdb-dbx_script");
     }
     else ui_fprintf(stderr, "Can't find gdb-dbx_script to use in setting up dbx emulation.\n");
  }
#endif /* TEK_HACK */
@


1.49
log
@Print out the name of the dbx emulation script file we read if emulating
dbx.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.49 89/11/27 12:14:30 davidl Exp $
   $Locker:  $
d192 5
d793 3
@


1.48
log
@If the program stopped because of SIGKILL, don't print the query
about whether to exit with a "running" program -- the process is
dead and can't be continued.  This is in response to bug BLK1450.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.47 89/11/18 16:49:43 davidl Exp $
   $Locker: andrew $
d557 3
a560 1
		emulate_dbx = 0;
d580 2
a581 1
     if (access("./gdb-dbx_script", R_OK) == 0)
d583 3
a585 1
     else if (access("/usr/local/bin/gnu/gdb-dbx_script", R_OK) == 0)
d587 3
a589 1
     else if (access("/usr/local/bin/gdb-dbx_script", R_OK) == 0)
d591 3
a593 1
     else if (access("/usr/local/gdb-dbx_script", R_OK) == 0)
d595 1
@


1.47
log
@Use savestring in execute_command if we have a ';' to delimit commands.
Otherwise user-defined commands containing ';' will be truncated after
executing once.
\.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.45 89/11/17 08:07:13 davidl Exp $
   $Locker:  $
d192 3
d1859 7
d1867 1
d2061 1
a2061 1
#endif TEK_HACK
@


1.46
log
@ added #ifdef TEK_HACK
@
text
@d5 1
a5 1
   $Locker: valeries $
d190 1
a190 1
void(*window_hook) ();
d650 3
a652 2
            char *ldquote = index(p, '"');
	    char *newcmd = semicolon + 1;
d657 2
d668 1
a668 1
			execute_command(c, p, from_tty);
d670 1
d674 1
d2050 1
a2050 1
#endif  /* TEK_HACK */
d2255 1
a2266 1
#endif /* TEK-HACK */
@


1.45
log
@Added Tek header information.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.44 89/11/17 08:01:16 valeries Exp $
   $Locker: davidl $
d190 1
a190 1
void (*window_hook) ();
d2045 1
a2045 1
#endif TEK_HACK
a2249 1
#endif /*TEK_HACK*/
d2261 1
@


1.44
log
@added ifdef TEK_HACK where required
@
text
@d4 2
a5 2
   $Header: main.c,v 1.43 89/11/16 21:57:46 donhar Exp $
   $Locker: valeries $
d22 42
@


1.43
log
@compile error in previous revision
@
text
@d4 2
a5 2
   $Header: main.c,v 1.42 89/11/16 21:55:43 donhar Exp $
   $Locker:  $
d139 1
d142 1
d602 1
a602 1

d630 1
d814 1
d844 1
d870 1
d872 1
d2001 1
d2003 1
@


1.42
log
@add support for watchpoints
@
text
@d4 2
a5 2
   $Header: main.c,v 1.41 89/11/14 08:35:28 davidl Exp $
   $Locker: donhar $
d740 1
a740 1
#endif /* TEK_HACK
@


1.41
log
@Call ui_fprintf with error if we can't find gdb-dbx_script, not ui_badnews.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.40 89/11/12 16:42:41 paulg Exp $
   $Locker: davidl $
d735 1
d737 5
@


1.40
log
@minor changes: update_prompt (2) now resets level,  parse_delims is now called
parse_string_list.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.39 89/11/11 16:43:35 davidl Exp $
   $Locker: paulg $
d539 1
a539 1
     else ui_badnews(-1, "Can't find gdb-dbx_script to use in setting up dbx emulation.");
@


1.39
log
@The '>' command is now an alias for a new command, 'redirect-output'.

We ignore ';' in execute_command if the current command is 'echo', rather
than using it as a command separator.

We call my_lookup_cmd() now where appropriate, rather than lookup_cmd().
@
text
@d4 2
a5 2
   $Header: main.c,v 1.38 89/11/10 17:00:01 davidl Exp $
   $Locker: davidl $
d214 1
a214 1
  update_prompt (0);
d1387 1
a1387 1
      cmds->line = (char *) parse_delims (extra);
@


1.38
log
@Support for multiple commands on a single line separated by semicolons.
Semicolons inside a string delineated by double-quotes are ignored.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.37 89/11/09 17:18:22 davidl Exp $
   $Locker:  $
d130 3
d169 1
d588 1
a588 1
      c = lookup_cmd (&p, cmdlist, "", 0, 1);
d602 1
a602 1
      if (*p) {
d2290 2
a2291 1
  add_com (">", class_support, redirect_out_command, "Redirect output for this command to a file.");
d2424 9
@


1.37
log
@Changed tek-license-gdb to TEK-LICENSE-GDB.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.36 89/11/08 13:30:23 davidl Exp $
   $Locker: davidl $
d174 2
d597 28
d790 1
d792 1
@


1.36
log
@Added license_info().  Wrote copying_info() and warranty_info() versions
which read /usr/local/bin/gnu/COPYING at runtime.  Look in /usr/local/bin/gnu
for gdb-dbx_script.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.35 89/11/08 10:32:15 davidl Exp $
   $Locker:  $
d1657 1
a1657 1
	stream = fopen("/usr/local/bin/gnu/tek-license-gdb", "r");
d1659 1
a1659 1
	    printf_filtered("Can't find file \"/usr/local/bin/gnu/tek-license-gdb\" to print license agreement.\nSee your Tektronix field office for more information.\n");
@


1.35
log
@Added macro_expand call in execute_command for user-defined commands. Also
check skip_execute here, so we don't try to expand what may be garbage.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.34 89/11/06 19:15:18 davidl Exp $
d384 1
d527 2
d1425 55
d1648 1
a1648 1
#endif
d1650 1
d1652 19
d1678 3
d2378 5
@


1.34
log
@Changed dbx emulation so that it has its own option (-dbx) now.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.33 89/11/02 12:42:56 davidl Exp $
   $Locker: davidl $
d597 1
d611 5
d621 1
a621 1
	      old_chain = push_def_expansions (c->name, p, cmdlines->line);
d625 1
a625 1
	    old_chain = push_def_expansions (c->name, p, 0);
@


1.33
log
@Added second param to macro_expand.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.32 89/11/02 08:56:28 davidl Exp $
a331 2
  while (isalpha(*p)) p++;
  if (*(p - 1) == 'x') emulate_dbx = 1;
d343 2
d400 1
a400 1
              || !strcmp (arg, "-na")
@


1.32
log
@Added support for dbx emulation.  If argv[0] ends in 'x', we look for
a gdb-dbx_script file in the user's home directory, current directory,
/usr/local/bin, and /usr/local.  Only one file is read in.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.31 89/10/27 14:31:30 davidl Exp $
d646 1
a646 1
          tem = macro_expand (p);
@


1.31
log
@Changed 'kind' argument to read_command_lines.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.30 89/10/25 19:18:07 davidl Exp $
   $Locker:  $
d289 3
d320 1
d332 3
d481 1
a481 1
	homeinit = (char *) alloca (strlen (getenv ("HOME")) + 10);
d499 9
a507 1
      }
d521 13
d542 1
@


1.30
log
@Moved skip_execute() call in execute_command so we wouldn't try to
execute commands when execute_enable is off.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.29 89/10/24 13:30:08 donhar Exp $
d1314 1
a1314 1
      cmds->next = read_command_lines (2);
d1317 1
a1317 1
    cmds = read_command_lines (2);
@


1.29
log
@put "#ifdef TEK_HACK" & "#endif" around previous revisions
@
text
@d4 2
a5 2
   $Header: main.c,v 1.28 89/10/24 12:27:50 donhar Exp $
   $Locker: donhar $
d609 2
a612 2
      else if (skip_execute (c))
        return;
@


1.28
log
@to add an "-na" switch to suppress repeat-on-carriage-return
@
text
@d4 1
a4 1
   $Header: main.c,v 1.27 89/10/19 13:28:07 davidl Exp $
d126 1
d130 1
d335 1
d338 1
d392 1
d394 1
d1025 2
d1028 4
@


1.27
log
@Added ui_doneinit.  This allows the debugger to inform the X interface that
it's done with what may be lengthy initialization (such as reading a
large symbol table).  At that time the X interface turns off synchronization.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.26 89/10/10 12:22:10 paulg Exp $
   $Locker:  $
d126 4
d333 2
d388 1
d1019 1
a1019 1
  if (repeat)
@


1.26
log
@get user defined command argument delimiters to work
@
text
@d4 2
a5 2
   $Header: main.c,v 1.25 89/10/07 10:26:36 paulg Exp $
   $Locker: paulg $
d500 1
@


1.25
log
@make it so "info user" will do the right thing when printing lines begining with sub commands (like "info break")
@
text
@d4 1
a4 1
   $Header: main.c,v 1.24 89/09/27 13:16:31 davidl Exp $
d555 1
a555 4
#ifdef TEK_PROG_HACK
          old_chain = push_match_expansions ();
	  (void) push_def_expansions (c->name, p);
#else /* not TEK_PROG_HACK */
d567 11
d1120 3
a1122 1
      if (l->cmd && (l->cmd->class == class_nested))
d1221 4
a1224 2
#ifndef TEK_PROG_HACK
static
a1225 1
void
d1237 4
d1248 3
d1254 1
a1254 1
define_command (comname, from_tty)
d1261 2
d1264 3
d1268 1
a1286 1
  comname = savestring (comname, strlen (comname));
d1289 9
a1297 1
  cmds = read_command_lines (2);
d1299 2
d1320 2
d1323 4
d1328 1
@


1.24
log
@Change initialize_cmd_pointers() to init_cmd_pointers() so munch doesn't
put it in init.c.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.23 89/09/27 09:33:59 davidl Exp $
   $Locker: davidl $
d74 1
d79 1
d84 1
d89 1
d94 1
d99 1
d104 1
d109 1
d1130 5
d1136 4
d1150 5
d1156 4
d1905 3
d1909 3
d1913 3
d1917 3
d1921 3
d1925 3
d1929 3
d1933 3
d1998 1
d2113 3
d2119 4
d2129 3
d2136 3
d2140 2
d2145 6
d2152 2
d2157 3
d2161 2
d2167 3
d2171 2
d2176 3
d2180 2
d2185 3
d2189 2
@


1.23
log
@Changed include of sys/fcntl.h to fcntl.h.  This is POSIX compliant, as
well as consistent with the file's location on a UTek 68k machine.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.22 89/09/27 09:27:29 davidl Exp $
d2110 1
a2110 1
  initialize_cmd_pointers ();
@


1.22
log
@Added workaround so '-c' works correctly when using X interface.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.21 89/09/26 21:38:59 paulg Exp $
d43 1
a43 1
#include <sys/fcntl.h>
@


1.21
log
@add #include for sys/fcntl.h
@
text
@d4 2
a5 2
   $Header: main.c,v 1.20 89/09/26 11:02:31 paulg Exp $
   $Locker: paulg $
d329 10
@


1.20
log
@change TEK_DEF_HACK to TEK_PROG_HACK
@
text
@d4 1
a4 1
   $Header: main.c,v 1.19 89/09/26 10:40:53 paulg Exp $
d43 1
@


1.19
log
@transfered most of the programming support stuff from main.c to programer.c
@
text
@d4 1
a4 1
   $Header: main.c,v 1.18 89/09/21 19:52:49 paulg Exp $
d147 1
a147 1
#ifdef TEK_DEF_HACK
d159 1
a159 1
#else /* not TEK_DEF_HACK */
d161 1
a161 1
#endif /* TEK_DEF_HACK */
d191 1
a191 1
#ifdef TEK_DEF_HACK
d194 1
a194 1
#endif /* TEK_DEF_HACK */
d246 1
a246 1
#ifndef TEK_DEF_HACK
d248 1
a248 1
#endif /* not TEK_DEF_HACK */
d499 1
a499 1
#ifdef TEK_DEF_HACK
d502 1
a502 1
#else /* not TEK_DEF_HACK */
d504 1
a504 1
#endif /* not TEK_DEF_HACK */
d508 1
a508 1
#ifndef TEK_DEF_HACK
d510 1
a510 1
#endif /* not TEK_DEF_HACK */
d515 1
a515 1
#ifdef TEK_DEF_HACK
d519 1
a519 1
#else /* not TEK_DEF_HACK */
d521 1
a521 1
#endif /* not TEK_DEF_HACK */
d523 1
a523 1
#ifndef TEK_DEF_HACK
d528 1
a528 1
#endif /* not TEK_DEF_HACK */
d536 1
a536 1
#ifdef TEK_DEF_HACK
d539 1
a539 1
#else /* not TEK_DEF_HACK */
d542 1
a542 1
#endif /* not TEK_DEF_HACK */
d550 1
a550 1
#ifdef TEK_DEF_HACK
d552 1
a552 1
#else /* not TEK_DEF_HACK */
d554 1
a554 1
#endif /* not_TEK_DEF_HACK */
d558 1
a558 1
#ifdef TEK_DEF_HACK
d560 1
a560 1
#else /* not TEK_DEF_HACK */
d562 1
a562 1
#endif /* not TEK_DEF_HACK */
d567 1
a567 1
#ifdef TEK_DEF_HACK
d580 1
a580 1
#else /* not TEK_DEF_HACK */
d584 1
a584 1
#endif /* not TEK_DEF_HACK */
d602 1
a602 1
#ifdef TEK_DEF_HACK
d604 1
a604 1
#else /* not TEK_DEF_HACK */
d606 1
a606 1
#endif /* not TEK_DEF_HACK */
d612 1
a612 1
#ifdef TEK_DEF_HACK
d616 1
a616 1
#else /* not TEK_DEF_HACK */
d620 1
a620 1
#endif /* not TEK_DEF_HACK */
d658 1
a658 1
#ifdef TEK_DEF_HACK
d660 1
a660 1
#else /* not TEK_DEF_HACK */
d662 1
a662 1
#endif /* not TEK_DEF_HACK */
d1027 1
a1027 1
#ifdef TEK_DEF_HACK
d1029 1
a1029 1
#else /* not TEK_DEF_HACK */
d1078 1
a1078 1
#endif /* not TEK_DEF_HACK */
d1092 1
a1092 1
#ifdef TEK_DEF_HACK
d1096 1
a1096 1
#endif /* TEK_DEF_HACK */
d1174 1
a1174 1
#ifndef TEK_DEF_HACK
d1176 1
a1176 1
#endif /* not TEK_DEF_HACK */
d1228 1
a1228 1
#ifdef TEK_DEF_HACK
d1230 1
a1230 1
#else /* not TEK_DEF_HACK */
d1232 1
a1232 1
#endif /* not TEK_DEF_HACK */
d1262 1
a1262 1
#ifdef TEK_DEF_HACK
d1264 1
a1264 1
#else /* not TEK_DEF_HACK */
d1266 1
a1266 1
#endif /* not TEK_DEF_HACK */
d1492 1
a1492 1
#ifdef TEK_DEF_HACK
d1494 1
a1494 1
#else /* not TEK_DEF_HACK */
d1496 1
a1496 1
#endif /* not TEK_DEF_HACK */
d1502 1
a1502 1
#ifndef TEK_DEF_HACK
d1540 1
a1540 1
#endif /* not TEK_DEF_HACK */
d1944 1
a1944 1
#ifndef TEK_DEF_HACK
d1946 1
a1946 1
#endif /* not TEK_DEF_HACK */
d1975 1
a1975 1
#ifdef TEK_DEF_HACK
d1979 1
a1979 1
#endif /* TEK_DEF_HACK */
d1981 1
a1981 1
#ifdef  TEK_DEF_HACK
d1988 1
a1988 1
#else /* not TEK_DEF_HACK */
d1992 1
a1992 1
#endif /* not TEK_DEF_HACK */
d2018 1
a2018 1
#ifndef TEK_DEF_HACK
d2022 1
a2022 1
#endif /* not TEK_DEF_HACK */
d2098 1
a2098 1
#ifdef TEK_DEF_HACK
d2100 1
a2100 1
#endif /* TEK_DEF_HACK */
@


1.18
log
@made the use of "getwoid()" conditional on USG as well as on DG_HACK.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.17 89/09/21 16:10:24 davidl Exp $
a48 4
#ifdef TEK_DEF_HACK
#include <fcntl.h>
#endif

a143 6
#ifdef TEK_DEF_HACK
void clear_cond_stack ();
void update_prompt ();
void dont_repeat ();
#endif /* TEK_DEF_HACK */

a146 1
static char *prompt;
d148 1
a148 3
char *prompt1;
char *prompt2;
#define MAXPROMPTLEN 128
d150 11
a160 12
int nesting_level;
static struct cmd_list_element *define_p;
static struct cmd_list_element *commands_p;
static struct cmd_list_element *document_p;
static struct cmd_list_element *while_p;
static struct cmd_list_element *if_p;
static struct cmd_list_element *endif_p;
struct cmd_list_element nested_define;
struct cmd_list_element nested_commands;
struct cmd_list_element nested_document;
struct cmd_list_element nested_while;
extern void nested_commands_command ();  /* In breakpoint.c */
d193 1
a193 2
  nesting_level = 0;
  update_prompt ();
d246 4
a249 1
static void
a493 3
#ifdef TEK_DEF_HACK
#include "expression.h"
#include "value.h"
a494 425
void execute_command ();
void add_com ();
void error_no_arg ();
void validate_comname ();

struct args_el {
  char *arg;
  struct args_el *next;
};
typedef struct args_el *args_el;

static args_el def_args = 0;
args_el match_args = 0;  

enum exec_state_type {
  exec_enabled, exec_disabled, exec_skipping,
};

struct cond_level
{
  enum exec_state_type exec_state;
  int else_ok;
  struct cond_level *prev;
};

typedef struct cond_level *cond_level;

cond_level cond_stack = 0;

void
clear_cond_stack ()
{
  cond_level level_to_free;

  while (cond_stack)
    {
      level_to_free = cond_stack;
      cond_stack = cond_stack->prev;
      free (level_to_free);
    }
}

static void
match_args_cleanup (prev)
     args_el prev;
{
  args_el l;
  args_el next_l;

  for (l = match_args; l; l = next_l)
    {
      next_l = l->next;
      if (l->arg)
        free (l->arg);
      free (l);
    }
  match_args = prev;
}

static void
update_prompt ()
{
  if (prompt != prompt1)
    free (prompt);
  if (nesting_level == 0)
    prompt = prompt1;
  else
    {
      prompt = (char *) xmalloc (MAXPROMPTLEN);
      sprintf (prompt, prompt2, nesting_level);
    }
}

static void
nested_while_command (cmds, from_tty)
     char *cmds;
     int from_tty;
{
  register struct command_line *cmdlines, *l;
  register struct cmd_list_element *c;
  register char *cond;
  struct expression *expr;
  value val;
  struct cleanup *old_chain, *chain_2;

  for (;;)
    {
      /* Test the condition. */

      cmdlines = (struct command_line *)cmds;
      cond = cmdlines->line;
      expr = parse_c_expression (cond);
      old_chain = make_cleanup (free_current_contents, &expr);
      val = evaluate_expression (expr);
#ifdef TEK_HACK
      if (val->lval == lval_reg_invalid)
        ui_badnews(-1, "condition is #%s=%s#", reg_names[VALUE_REGNO (val)],
                   THE_UNKNOWN);
#endif /* TEK_HACK */
      if (val->contents[0] == 0)
        break;
      do_cleanups (old_chain);

      /* Do the loop */

      /* Check for a null loop. */
      cmdlines = cmdlines->next;
      if (cmdlines == 0)
        continue;

      /* Set the instream to 0, indicating execution of a
         user-defined function.  */
      old_chain =  make_cleanup (source_cleanup, instream);
      instream = (FILE *) 0;
      while (cmdlines)
        {
          execute_command (cmdlines->cmd, cmdlines->line, 0);
          cmdlines = cmdlines->next;
        }
      do_cleanups (old_chain);
    }
  do_cleanups (old_chain);
}

void
while_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  struct command_line *cmdlines, *newone;
  struct cleanup *old_chain;
  char *cond;
  
  /* We don't want conditional commands to auto repeat. */
  dont_repeat ();

  /* Make sure there is a condition. */
  if ((arg == 0) || (*arg == 0))
    error_no_arg ("while condition");
  cond = savestring (arg, strlen (arg));

  /* Gather up the body of the while loop */
  
  if (from_tty)
    {
      ui_fprintf(stdout, "Type commands for body of while loop.\n\
End with a line saying just \"end\".\n");
      ui_fflush (stdout);
    }
  cmdlines = read_command_lines (2);
  old_chain = make_cleanup (free_command_lines, &cmdlines);

  /* Try to execute the loop only if we are currently enabled */
  if (cond_stack->exec_state == exec_enabled)
    {
      /* Construct a command list for "nested_while_command" and call it. */
      newone = (struct command_line *) xmalloc (sizeof (struct command_line));
      newone->cmd = 0;
      newone->line = cond;
      newone->next = cmdlines;
      cmdlines = newone;
      nested_while_command ((char *) cmdlines, from_tty);
    }
  
  /* All done, clean up. */
  do_cleanups (old_chain);
}

void
if_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  cond_level new_level;
  struct expression *expr;
  value val;
  struct cleanup *old_chain = 0;
  int cleanup = 0;

  /* We don't want conditional commands to auto repeat. */

  dont_repeat ();

  /* Create a new level */

  ++nesting_level;
  update_prompt ();
  new_level = (cond_level) malloc (sizeof(struct cond_level));
  new_level->prev = cond_stack;
  new_level->else_ok = 1;
  cond_stack = new_level;

  /* Handle the case where we are not currently enabled */

  if (new_level->prev->exec_state != exec_enabled)
    {
      new_level->exec_state = exec_skipping;
      return;
    }

  /* Either evaluate the argument or get a value from history. */

  if (arg && *arg)
    {
      expr = parse_c_expression (arg);
      old_chain = make_cleanup (free_current_contents, &expr);
      cleanup = 1;
      val = evaluate_expression (expr);
    }
  else
    val = access_value_history (0);

  /* Set the execution state depending on the value obtained above. */

#ifdef TEK_HACK
  if (val->lval == lval_reg_invalid)
    ui_badnews(-1, "condition is #%s=%s#", reg_names[VALUE_REGNO (val)],
	THE_UNKNOWN);
#endif
  new_level->exec_state = val->contents[0] ? exec_enabled : exec_disabled;

  /* Clean up after ourself */

  if (cleanup)
    do_cleanups (old_chain);
}

void
elif_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  cond_level cur_level = cond_stack;
  struct expression *expr;
  struct cleanup *old_chain = 0;
  value val;
  int cleanup = 0;

  /* We don't want conditional commands to auto repeat. */

  dont_repeat ();

  /* Make sure we are have seen an "if" at this level and not an "else". */

  if (! (cur_level && cur_level->else_ok))
    ui_badnews(-1, "not expecting an \"elif\" command");

  /* If we have been executing commands, then start skipping them. */

  if (cur_level->exec_state == exec_enabled)
    cur_level->exec_state = exec_skipping;

  /* If we are skipping commands until the next "endif", then bugout without
     evaluating our argument. */

  if (cur_level->exec_state == exec_skipping)
    return;

  /* Either evaluate the argument or get a value from history. */

  if (arg && *arg)
    {
      expr = parse_c_expression (arg);
      old_chain = make_cleanup (free_current_contents, &expr);
      cleanup = 1;
      val = evaluate_expression (expr);
    }
  else
    val = access_value_history (0);

  /* Set the execution state depending on the value obtained above. */

#ifdef TEK_HACK
  if (val->lval == lval_reg_invalid)
    ui_badnews(-1, "condition is #%s=%s#", reg_names[VALUE_REGNO (val)],
	THE_UNKNOWN);
#endif
  cur_level->exec_state = val->contents[0] ? exec_enabled : exec_disabled;

  /* Clean up after ourself */

  if (cleanup)
    do_cleanups (old_chain);
}

void
else_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  cond_level cur_level = cond_stack;

  /* We don't want conditional commands to auto repeat. */

  dont_repeat ();

  /* Make sure we are have seen an "if" at this level and not an "else". */

  if (! (cur_level && cur_level->else_ok))
    ui_badnews(-1, "not expecting an \"else\" command");

  /* Make sure this is the only else we'll take at this level */

  cur_level->else_ok = 0;

  /* "Toggle" the execution sate. */

  if (cur_level->exec_state == exec_enabled)
    cur_level->exec_state = exec_disabled;
  else if (cur_level->exec_state == exec_disabled)
    cur_level->exec_state = exec_enabled;
}

void
endif_command (arg, from_tty)
     char *arg;
     int from_tty;
{
  cond_level cur_level = cond_stack;

  /* We don't want conditional commands to auto repeat. */

  dont_repeat ();

  /* Make sure we have already seen an "if" */
  
  if (! cur_level)
    ui_badnews(-1, "not expecting an \"endif\" command");

  /* Get rid of this level */

  --nesting_level;
  update_prompt ();
  cond_stack = cur_level->prev;
  free (cur_level);
}

struct command_line *
copy_command_lines (in)
     register struct command_line *in;
{
  register struct command_line *out;

  if (in == 0)
    return 0;

  out = (struct command_line *) xmalloc (sizeof (struct command_line));

  out->cmd = in->cmd;
  if (in->cmd && (in->cmd->class == class_nested))
    out->line = (char *) copy_command_lines ((struct command_lines *)in->line);
  else
    out->line = savestring(in->line, strlen (in->line));
  out->next = copy_command_lines (in->next);

  return out;
}

static void
nested_define_command (cmds, from_tty)
     char *cmds;
     int from_tty;
{
  register struct command_line *cmdlines;
  register struct cmd_list_element *c;
  register char *comname;
  char *tem;

  cmdlines = (struct command_line *)cmds;
  comname = savestring (cmdlines->line, strlen(cmdlines->line));

  validate_comname (comname);
  tem = comname;
  c = lookup_cmd (&tem, cmdlist, "", -1, 1);

  if (c && c->class == (int) class_user)
    free_command_lines (&c->function);

  add_com (comname, class_user, copy_command_lines (cmdlines->next),
	   (c && c->class == (int) class_user)
	   ? c->doc : savestring ("User-defined.", 13));
}

static void
nested_document_command (cmds)
     char *cmds;
{
  register struct command_line *doclines;
  register struct cmd_list_element *c;
  char *comname;

  doclines = (struct command_line *)cmds;
  comname= doclines->line;

  validate_comname (comname);

  c = lookup_cmd (&comname, cmdlist, "", 0, 1);

  if (c->class != (int) class_user)
    ui_badnews(-1,"Command \"%s\" is built-in.", doclines->line);

  doclines = doclines->next;

  if (c->doc) free (c->doc);

  {
    register struct command_line *cl1;
    register int len = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      len += strlen (cl1->line) + 1;

    c->doc = (char *) xmalloc (len + 1);
    *c->doc = 0;

    for (cl1 = doclines; cl1; cl1 = cl1->next)
      {
	strcat (c->doc, cl1->line);
	if (cl1->next)
	  strcat (c->doc, "\n");
      }
  }
}
#endif /* TEK_DEF_HACK */

d537 3
a539 3
          old_chain = make_cleanup (match_args_cleanup, match_args);
	  match_args = 0;
#endif /* TEK_DEF_HACK */
d542 1
d570 1
a570 2
      else if (cond_stack && (c->class != (int) class_conditional)
               && (cond_stack->exec_state != exec_enabled))
d576 3
a578 1
          (*c->function) (*p ? p : 0, from_tty);
d602 3
d606 1
d613 1
a613 1
      execute_command (0, command_line_input (instream == stdin ? prompt : 0,
d658 3
d662 1
d1027 3
a1030 4
#ifdef TEK_DEF_HACK
read_command_lines (kind)
     int kind; /* 0: don't check; 1: silent OK as 1st; otherwise: check all */
#else /* TEK_DEF_HACK */
a1031 1
#endif /* TEK_DEF_HACK */
a1036 6
#ifdef TEK_DEF_HACK
  register struct cmd_list_element *c;
  char *psav;
  struct cmd_list_element *nested_cmd;
  cond_level starting_level = cond_stack;
  int new_kind;
a1037 4
  ++nesting_level;
  update_prompt ();
#endif /* TEK_DEF_HACK */

a1040 4
#ifdef TEK_DEF_HACK
      p = command_line_input ((instream == stdin) ? prompt : 0,
                              instream == stdin);
#else /* not TEK_DEF_HACK */
a1041 1
#endif /* not TEK_DEF_HACK */
a1049 22
#ifdef TEK_DEF_HACK
      /* See if the command is a valid one. */
      switch (kind) {
      case 0:
        c = 0;
        break;
      case 1:
        if ((tail == 0) && (p1 - p == 6) && !strncmp (p, "silent", 6))
          {
            c = 0;
            break;
          }
        /* Fall through if not first line or silent "command". */
      default:
        psav = p;
        c = lookup_cmd (&psav, cmdlist, "", 0, 1);
        if (c == NULL)
          ui_badnews (-1, "bad command: %s", p);
        if (c->function == 0)
          ui_badnews (-1, "%s: this is not a command, just a help topic.", p);
        p = psav;
      }
a1050 49
      /* See if we should nest. It would be nice if the cmd_list_element
         could tell us this, but that would be more intrusive. */
      nested_cmd = 0;
      if (c == define_p)
        {
          nested_cmd = &nested_define;
          new_kind = 2;
        }
      else if (c == commands_p)
        {
          nested_cmd = &nested_commands;
          new_kind = 1;
        }
      else if (c == document_p)
        {
          nested_cmd = &nested_document;
          new_kind = 0;
        }
      else if (c == while_p)
        {
          nested_cmd = &nested_while;
          new_kind = 2;
        }
      else if (c == if_p)
        {
          ++nesting_level;
          update_prompt ();
        }
      else if (c == endif_p)
        {
          --nesting_level;
          update_prompt ();
        }
      
      if (nested_cmd)
        {
          next = (struct command_line *) xmalloc (sizeof (struct command_line));
          next->cmd = nested_cmd;
          next->line = (char *) xmalloc (sizeof (struct command_line));
          ((struct command_line *)(next->line))->cmd = 0;
          ((struct command_line *)(next->line))->line = savestring (p, p1 - p);
          ((struct command_line *)(next->line))->next =
            read_command_lines (new_kind);
          next->next = 0;
        }
      else
        {
#endif /* TEK_DEF_HACK */

a1052 3
#ifdef TEK_DEF_HACK
      next->cmd = c;
#endif /* TEK_DEF_HACK */
a1054 3
#ifdef TEK_DEF_HACK
        }
#endif /* TEK_DEF_HACK */
a1071 7
#ifdef TEK_DEF_HACK
  if (starting_level != cond_stack)
    ui_badnews (-1, "Missing \"endif\" command(s)");
  --nesting_level;
  update_prompt ();
#endif /* TEK_DEF_HACK */

d1078 1
d1174 4
a1177 1
static void
d1275 2
a1276 2

    c->doc = (char *) xmalloc (len + 1);
a1288 81

#ifdef TEK_DEF_HACK
void
print_command_lines (lvl, cmdlines)
     int lvl;
     register struct command_line *cmdlines;
{
  int i;

  for (; cmdlines; cmdlines = cmdlines->next)
    {
      printf_filtered ("\t");
      if (cmdlines->cmd)
        {
          if (cmdlines->cmd->class == class_nested)
            {
              for (i = 0; i < lvl; ++i)
                printf_filtered ("  ");
              printf_filtered ("%s %s\n", cmdlines->cmd->name,
                               ((struct command_line *)
                                (cmdlines->line))->line);
              print_command_lines (lvl + 1,
                                   ((struct command_line *)
                                    (cmdlines->line))->next);
              printf_filtered ("\t");
              for (i = 0; i < lvl; ++i)
                printf_filtered ("  ");
              printf_filtered ("end\n");
              continue;
            }
          if ((cmdlines->cmd->class == class_conditional)
                   && (cmdlines->cmd != if_p))
            --lvl;
          for (i = 0; i < lvl; ++i)
            printf_filtered ("  ");
          printf_filtered ("%s %s\n", cmdlines->cmd->name, cmdlines->line);
          if ((cmdlines->cmd->class == class_conditional)
                   && (cmdlines->cmd != endif_p))
            ++lvl;
        }
      else
        {
          for (i = 0; i < lvl; ++i)
            printf_filtered ("  ");
          printf_filtered ("%s\n", cmdlines->line);
        }
    }
}

static void
user_info (cmd_name)
     char *cmd_name;
{
  struct cmd_list_element *c;
  register struct command_line *cmdlines;

  if (cmd_name && *cmd_name)
    {
      c = lookup_cmd (&cmd_name, cmdlist, "", 0, 1);
      if (c == 0) return; /* Just to be sure. */
      if (c->function == 0)
	ui_badnews (-1,"That is not a command, just a help topic.");
      if (c->class != (int) class_user)
        ui_badnews (-1, "That is not a user command.");
      printf_filtered ("%s:\n", c->name);
      cmdlines = (struct command_line *) c->function;
      print_command_lines (0, cmdlines);
    }
  else
    for (c = cmdlist; c; c = c->next)
      {
        if (c->function == 0)
          continue;
        if (c->class != (int) class_user)
          continue;
        printf_filtered ("%s:\n", c->name);
        cmdlines = (struct command_line *) c->function;
        print_command_lines (0, cmdlines);
      }
}
#endif /* TEK_DEF_HACK */
d1463 1
a1463 1
  ui_fprintf(stdout, "GDB %s, Copyright (C) 1988 Free Software Foundation, Inc.\n\
d1470 4
d1479 3
d1492 3
d1496 1
d1502 1
a1503 4
#ifdef TEK_DEF_HACK
set_either_prompt_command (normal, text)
     int normal;
#else /* not TEK_DEF_HACK */
a1504 1
#endif /* not TEK_DEF_HACK */
a1536 13
#ifdef TEK_DEF_HACK
  if (normal)
    {
      free (prompt1);
      prompt1 = new;
    }
  else
    {
      free (prompt2);
      prompt2 = new;
    }
  update_prompt ();
#else /* not TEK_DEF_HACK */
d1539 1
a1540 17
}

#ifdef TEK_DEF_HACK
static void
set_prompt_command (text)
     char *text;
{
  set_either_prompt_command (1, text);
}

static void
set_prompt2_command (text)
     char *text;
{
  set_either_prompt_command (0, text);
}
#endif /* TEK_HACK */
d1694 1
a1694 1

d1877 1
a1877 1
#ifdef TEK_DEF_HACK
d1920 1
a1920 1
#endif /*TEK_DEF_HACK*/
d1944 1
a1944 6
#ifdef TEK_DEF_HACK
  prompt1 = savestring ("(gdb) ", 6);
  prompt2 = savestring ("<%d> ", 5);
  nesting_level = 0;
  prompt = prompt1;
#else /* not TEK_DEF_HACK */
d2015 4
d2022 1
a2022 7
#ifdef TEK_DEF_HACK
  add_cmd ("prompt2", class_support, set_prompt2_command,
	   "Change gdb's secondary prompt.\n\
The default secondary prompt is \"r<%d>\".",
	   &setlist);
  add_com (">", class_support, redirect_out_command, "Redirect output for this command to a file.");
#endif /* TEK_DEF_HACK */
d2099 1
a2099 50
  add_com ("endif", class_conditional, endif_command, "Endif part of conditional.");

  add_com ("elif", class_conditional, elif_command, "Elif part of conditional.");
  add_com ("else", class_conditional, else_command, "Else part of conditional.");
  add_com ("if", class_conditional, if_command, "If part of conditional.");
  add_info ("user", user_info,
            "Show definitions of any or all user commands.\n\
Use \"info user COMMAND\" to show the definition of COMMAND or use \"info user\"\n\
to see the definitions of all commands.");
  add_com ("while", class_conditional, while_command, "While loop.");
  {
    char *p;

    p = "define";
    define_p = lookup_cmd (&p, cmdlist, "", -1, 1);
    if (define_p == 0)
      ui_badnews (1, "Internal: \"Define\" not defined.");
    p = "commands";
    commands_p = lookup_cmd (&p, cmdlist, "", -1, 1);
    if (commands_p == 0)
      ui_badnews (1, "Internal: \"Commands\" not defined.");
    p = "document";
    document_p = lookup_cmd (&p, cmdlist, "", -1, 1);
    if (document_p == 0)
      ui_badnews (1, "Internal: \"Document\" not defined.");
    p = "while";
    while_p = lookup_cmd (&p, cmdlist, "", -1, 1);
    if (while_p == 0)
      ui_badnews (1, "Internal: \"While\" not defined.");
    p = "if";
    if_p = lookup_cmd (&p, cmdlist, "", -1, 1);
    if (if_p == 0)
      ui_badnews (1, "Internal: \"If\" not defined.");
    p = "endif";
    endif_p = lookup_cmd (&p, cmdlist, "", -1, 1);
    if (endif_p == 0)
      ui_badnews (1, "Internal: \"Endif\" not defined.");
  }
  nested_define.function = nested_define_command;
  nested_define.name = "define";
  nested_define.class = class_nested;
  nested_commands.function = nested_commands_command;
  nested_commands.name = "commands";
  nested_commands.class = class_nested;
  nested_document.function = nested_document_command;
  nested_document.name = "document";
  nested_document.class = class_nested;
  nested_while.function = nested_while_command;
  nested_while.name = "while";
  nested_while.class = class_nested;
@


1.17
log
@Added add_com(">") to get > in the command list.

Added third parameter to execute_command in redirect_command().

Minor fix to allow xgdb xxIOW window input.
@
text
@d4 2
a5 2
   $Header: main.c,v 1.16 89/09/21 11:30:56 davidl Exp $
   $Locker:  $
d23 1
a23 1
#ifdef	DG_HACK
d25 1
a25 1
#endif
d292 1
a292 1
#ifdef	DG_HACK
d294 1
a294 1
#else
d296 1
a296 1
#endif	/* DG_HACK */
d2206 1
a2206 1
#ifdef	DG_HACK
d2208 1
a2208 1
#else
d2210 1
a2210 1
#endif	/* DG_HACK */
@


1.16
log
@Added code for redirection of command output and some minor typo cleanup.
@
text
@d4 1
a4 1
   $Header: main.c,v 1.15 89/09/21 10:43:58 paulg Exp $
d1133 2
a1134 3
          if (mark)
            ui_badnews (1, "Internal: gdb_readline - no end of line");
          result[result_size - 1] = '\0';
d2547 1
a2547 1
  execute_command(args + len, 0);
d2658 1
@


1.15
log
@added stuff for macro_args
@
text
@d4 2
a5 2
   $Header: main.c,v 1.14 89/09/21 10:20:15 paulg Exp $
   $Locker: paulg $
d49 4
d553 1
a553 1
macro_args_cleanup (prev)
d559 1
a559 1
  for (l = macr_args; l; l = next_l)
d566 1
a566 1
  macro_args = prev;
d977 2
a978 2
          old_chain = make_cleanup (macro_args_cleanup, macro_args);
	  macro_args = 0;
d2508 44
d2617 1
a2617 1
#ifdef /* TEK_DEF_HACK */
@


1.14
log
@add rcsid stuff
@
text
@d4 2
a5 2
   $Header:  $
   $Locker:  $
d511 9
d549 17
d972 4
d985 3
d989 1
@


1.13
log
@declare some forward referneces to keep the Green Hills compiler happy.
@
text
@d4 3
@


1.12
log
@HUGE ASSIVE CHANGE:  Allow commands that collect lines (commands) to nest.
These commandsare "define", "document", "comments", and "while".  The
"while" command is new: it collects commands and repeatedly executes them
as long as its argument keeps evaluating to 1.  To support nesting, there
is now a secondary prompt "prompt2".  It is used to prompt for all
lines being collected (and durring an if-elif-else-endif sequence).
"prmopt2" is used as a format to print the prompt: the only argument is
"nesting_level".  "nesting_level" keeps track of the nesting of the 
'collecting' commands and of the if-elif-else-endif commands.
@
text
@d503 5
@


1.11
log
@Disabled X interface if running in batch mode.  Don't use X interface
if -x option chosen.  Don't call ui_tickleMe() if reading commands
from a source file.
@
text
@d141 5
a145 4
#ifdef TEK_COND_HACK
void clear_cond_stack();
void dont_repeat();
#endif
d151 4
d156 14
d198 1
a198 1
#ifdef TEK_COND_HACK
d200 3
a202 1
#endif /* TEK_COND_HACK */
d499 1
a499 1
#ifdef TEK_COND_HACK
d531 65
d597 44
d657 2
d803 2
a807 1
#endif /* TEK_COND_HACK */
d809 88
d901 4
d906 1
d910 1
d912 1
d917 5
d923 1
d925 1
d930 1
d939 1
a939 1
	    ui_badnews(-1,"User-defined commands cannot take arguments.");
d951 3
d955 1
d960 3
a962 1
#ifdef TEK_COND_HACK
d966 7
a972 1
#endif /* TEK_COND_HACK */
d976 1
d1000 5
d1008 1
d1063 3
a1065 3
  char *result, *mark;
  int result_size = 320;
  extern char *index();
d1074 5
a1078 1
  if (instream == stdin) ui_tickleMe();
d1080 17
a1096 9
  result = (char *) xmalloc (result_size);

  ui_fgets(result, result_size, instream);
  if (return_result)
    {
      mark = index(result, '\n');
      if (mark) *mark = '\0';
      else result[result_size - 1] = '\0';
      return result;
d1100 29
a1128 2
      free(result);
      return (char *) 0;
d1413 4
d1418 1
d1424 6
d1431 4
d1438 4
d1443 1
d1452 22
d1475 49
d1526 3
d1531 3
d1551 7
d1577 5
d1710 3
d1714 1
d1744 3
d1748 1
a1748 1

d1770 48
d1819 33
d2055 4
d2060 1
d2093 13
d2108 1
d2110 16
d2485 6
d2492 1
d2521 5
a2525 3
#ifdef TEK_COND_HACK
  add_cmd ("conditionals", class_conditional, 0, "Conditional commands", &cmdlist);
#endif /* TEK_COND_HACK */
d2527 1
d2530 7
d2538 1
d2551 1
a2551 1
	   &cmdlist);
d2562 1
a2562 1
	   "Change gdb's prompt from the default of \"(gdb)\"",
d2564 6
d2645 3
a2647 2
#ifdef TEK_COND_HACK
  add_com ("if", class_conditional, if_command, "If part of conditional.");
d2650 47
a2696 2
  add_com ("endif", class_conditional, endif_command, "Endif part of conditional.");
#endif /* TEK_COND_HACK */
@


1.10
log
@Paramiterized the unknown message.
@
text
@d141 5
d307 1
a307 1
	batch = 1, quiet = 1;
a311 2
      else if (!strcmp (argv[i], "-x") || !strcmp(argv[i], "X"))
	usingX = 1;
d557 1
a557 1
               THE_UNKNOWN);
d615 1
a615 1
               THE_UNKNOWN);
d819 1
a819 1
  ui_tickleMe();
@


1.9
log
@Declare clear_cond_stack and dont_repeat ifdef TEK_COND_HACK before they're
used, as Green Hills produces fatal error (they return void, not int).
@
text
@a140 5
#ifdef TEK_COND_HACK
void clear_cond_stack();
void dont_repeat();
#endif

d553 2
a554 1
    ui_badnews(-1, "condition is #%s=unknown#", reg_names[VALUE_REGNO (val)]);
d611 2
a612 1
    ui_badnews(-1, "condition is #%s=unknown#", reg_names[VALUE_REGNO (val)]);
@


1.8
log
@Added four new commands: "if", "elif", "else", and "endif".  These impliment
a conditional capablity.  "If" and "elif" both evaluate an expression.  If
the expresion evaluates to 0, the execution of commands is suppressed until
the next matching "elif", "else", or "endif".  A stack is used so that these
can be nested.
@
text
@d141 5
@


1.7
log
@change calles to "fatal" to "ui_badnews" with a first argument of 1.
@
text
@d174 3
d475 196
d715 8
a722 3
      else
	/* Pass null arg rather than an empty one.  */
	(*c->function) (*p ? p : 0, from_tty);
d1983 3
d2090 6
@


1.6
log
@change ui_badnews(0 to ui_badnews(-1
@
text
@d453 1
a453 1
    fatal ("Attempt to read commands from stdin in batch mode.");
@


1.5
log
@merge in Data General stuff: get clean compile.
@
text
@d384 1
a384 1
		ui_badnews(0,"Unknown command-line switch: \"%s\"\n", arg);
d493 1
a493 1
	ui_badnews(0,"That is not a command, just a help topic.");
d499 1
a499 1
	    ui_badnews(0,"User-defined commands cannot take arguments.");
d698 1
a698 1
	    ui_badnews(0,"Unrecognized command.");
d732 1
a732 1
		  ui_badnews(0,"\"%s\" command requires a subcommand.",
d1036 1
a1036 1
  ui_badnews(0,"Argument required (%s).", why);
d1063 1
a1063 1
	ui_badnews(0,"Junk in argument list: \"%s\"", p);
d1087 1
a1087 1
	ui_badnews(0,"Command \"%s\" not redefined.", comname);
d1122 1
a1122 1
    ui_badnews(0,"Command \"%s\" is built-in.", comname);
d1405 1
a1405 1
	ui_badnews(0,"Not confirmed.");
d1425 1
a1425 1
  if (arg) ui_badnews(0,"The \"pwd\" command does not take an argument: %s", arg);
d1579 1
a1579 1
      ui_badnews(0,"\"%s\" not given a binary valued argument.", caller);
d1700 1
a1700 1
    ui_badnews(0,"\"info verbose\" does not take any arguments.\n");
d1709 1
a1709 1
  ui_badnews(0,"Invalid floating value encountered or computed.");
@


1.4
log
@Added a couple of ui_fflush'es to keep prompt printing business straight.
@
text
@d20 4
d256 3
d260 1
d569 3
d573 3
d1426 3
d1430 1
@


1.3
log
@Renamed usrIntNo to usingX.  Changed calls to fputc to ui_putc.
@
text
@d591 1
d1332 1
@


1.2
log
@Changes for initial runnable xgdb version.
@
text
@d115 1
a115 1
int usrIntNo = 0;
d279 1
a279 1
          usrIntNo = 1;
d297 1
a297 1
	usrIntNo = 1;
d307 1
a307 1
  initUsrInt (usrIntNo, &argc, argv);
d1518 1
a1518 1
	      fputc (c, stdout);
d1521 1
a1521 1
	  fputc (c, stdout);
d1569 1
a1569 1
  if (! usrIntNo)
d1733 1
a1733 1
  if (! usrIntNo) command_editing_p = 1;
@


1.1
log
@Initial revision
@
text
@d23 1
d114 3
d196 1
a196 1
      fprintf (stderr, "%s\n", errstring);
d244 2
d270 12
d296 2
d307 1
d340 1
a340 1
	    fprintf (stderr, "No argument follows \"%s\".\n", arg);
d376 1
a376 1
		error ("Unknown command-line switch: \"%s\"\n", arg);
d398 1
a398 1
		fprintf (stderr, "Excess command line args ignored. (%s%s)\n",
d447 4
a450 2
  if (!quiet)
    printf ("Type \"help\" for a list of commands.\n");
d457 3
a459 1
	command_loop ();
d480 4
d485 1
a485 1
	error ("That is not a command, just a help topic.");
d491 1
a491 1
	    error ("User-defined commands cannot take arguments.");
d567 3
a569 2
  printf ("%s", prompt);
  fflush (stdout);
d579 1
d585 3
a587 4
  int c;
  char *result;
  int input_index = 0;
  int result_size = 80;
d591 3
a593 2
      printf (prompt);
      fflush (stdout);
d595 1
d597 1
a597 2
  if (return_result)
    result = (char *) xmalloc (result_size);
d599 1
a599 15
  while (1)
    {
      c = fgetc (instream);
      if (c == -1 || c == '\n')
	break;
      if (return_result)
	{
	  result[input_index++] = c;
	  while (input_index >= result_size)
	    {
	      result_size *= 2;
	      result = (char *) xrealloc (result, result_size);
	    }
	}
    }
d602 3
a604 1
      result[input_index++] = '\0';
d608 4
a611 1
    return (char *) 0;
d620 2
d683 1
a683 1
	    error ("Unrecognized command.");
d717 1
a717 1
		  error ("\"%s\" command requires a subcommand.",
d829 1
a829 1
	  printf ("%s\n", history_value);
d989 1
a989 1
  printf ("\"info\" must be followed by the name of an info command.\n");
d1021 1
a1021 1
  error ("Argument required (%s).", why);
d1048 1
a1048 1
	error ("Junk in argument list: \"%s\"", p);
d1072 1
a1072 1
	error ("Command \"%s\" not redefined.", comname);
d1077 1
a1077 1
      printf ("Type commands for definition of \"%s\".\n\
d1079 1
a1079 1
      fflush (stdout);
d1107 1
a1107 1
    error ("Command \"%s\" is built-in.", comname);
d1110 1
a1110 1
    printf ("Type documentation for \"%s\".\n\
d1311 1
a1311 1
  printf ("GDB %s, Copyright (C) 1988 Free Software Foundation, Inc.\n\
d1331 3
a1333 2
  printf ("%s", prompt);
  fflush (stdout);
d1389 1
a1389 1
	error ("Not confirmed.");
d1394 1
d1409 1
a1409 1
  if (arg) error ("The \"pwd\" command does not take an argument: %s", arg);
d1413 1
a1413 1
    printf ("Working directory %s\n (canonically %s).\n",
d1416 1
a1416 1
    printf ("Working directory %s.\n", current_directory);
d1559 1
a1559 1
      error ("\"%s\" not given a binary valued argument.", caller);
d1569 2
a1570 1
  command_editing_p = parse_binary_operation ("set command-editing", arg);
d1630 1
a1630 1
  printf ("\"set history\" must be followed by the name of a history subcommand.\n");
d1680 1
a1680 1
    error ("\"info verbose\" does not take any arguments.\n");
d1682 1
a1682 1
  printf ("Verbose printing of information is %s.\n",
d1689 1
a1689 1
  error ("Invalid floating value encountered or computed.");
d1707 12
d1733 1
a1733 1
  command_editing_p = 1;
@
