head     1.33;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.33
date     91.01.13.23.52.47;  author robertb;  state Exp;
branches ;
next     1.32;

1.32
date     91.01.01.21.09.59;  author robertb;  state Exp;
branches ;
next     1.31;

1.31
date     90.12.29.21.26.14;  author robertb;  state Exp;
branches ;
next     1.30;

1.30
date     90.12.10.21.19.59;  author robertb;  state Exp;
branches ;
next     1.29;

1.29
date     90.11.27.01.02.47;  author robertb;  state Exp;
branches ;
next     1.28;

1.28
date     90.11.15.19.32.20;  author robertb;  state Exp;
branches ;
next     1.27;

1.27
date     90.09.29.20.59.58;  author robertb;  state Exp;
branches ;
next     1.26;

1.26
date     90.08.19.21.19.54;  author robertb;  state Exp;
branches ;
next     1.25;

1.25
date     90.05.11.11.44.07;  author robertb;  state Exp;
branches ;
next     1.24;

1.24
date     90.04.29.19.43.41;  author robertb;  state Exp;
branches ;
next     1.23;

1.23
date     90.04.27.18.33.51;  author robertb;  state Exp;
branches ;
next     1.22;

1.22
date     90.04.25.10.19.07;  author robertb;  state Exp;
branches ;
next     1.21;

1.21
date     90.04.23.10.21.48;  author robertb;  state Exp;
branches ;
next     1.20;

1.20
date     90.03.29.15.46.55;  author robertb;  state Exp;
branches ;
next     1.19;

1.19
date     90.03.28.14.26.21;  author robertb;  state Exp;
branches ;
next     1.18;

1.18
date     90.03.15.09.26.57;  author andrew;  state Exp;
branches ;
next     1.17;

1.17
date     90.02.07.16.05.00;  author andrew;  state Exp;
branches ;
next     1.16;

1.16
date     90.01.02.18.01.28;  author robertb;  state Exp;
branches ;
next     1.15;

1.15
date     89.12.31.00.39.17;  author robertb;  state Exp;
branches ;
next     1.14;

1.14
date     89.12.22.16.25.18;  author root;  state Exp;
branches ;
next     1.13;

1.13
date     89.12.22.16.08.17;  author root;  state Exp;
branches ;
next     1.12;

1.12
date     89.12.22.16.05.37;  author root;  state Exp;
branches ;
next     1.11;

1.11
date     89.12.20.19.05.43;  author robertb;  state Exp;
branches ;
next     1.10;

1.10
date     89.12.18.17.02.13;  author robertb;  state Exp;
branches ;
next     1.9;

1.9
date     89.12.18.16.31.53;  author andrew;  state Exp;
branches ;
next     1.8;

1.8
date     89.12.18.15.44.26;  author robertb;  state Exp;
branches ;
next     1.7;

1.7
date     89.11.17.08.07.29;  author davidl;  state Exp;
branches ;
next     1.6;

1.6
date     89.10.16.16.56.28;  author davidl;  state Exp;
branches ;
next     1.5;

1.5
date     89.09.22.15.59.43;  author paulg;  state Exp;
branches ;
next     1.4;

1.4
date     89.08.20.17.54.30;  author paulg;  state Exp;
branches ;
next     1.3;

1.3
date     89.08.19.12.33.51;  author paulg;  state Exp;
branches ;
next     1.2;

1.2
date     89.08.04.10.18.36;  author davidl;  state Exp;
branches ;
next     1.1;

1.1
date     89.07.30.23.08.15;  author paulg;  state Exp;
branches ;
next     ;


desc
@@


1.33
log
@FIxed get_remote_char(), added multiple processor support to
match that in target.  Added "$showinput" convenience variable.
@
text
@/* Memory-access and commands for cross-debugging

   Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.

   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.32 91/01/01 21:09:59 robertb Exp Locker: robertb $
   $Locker: robertb $

This file is part of GDB. */


#include <ctype.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/file.h>
#include <sys/time.h>
#include <termio.h>
#include <string.h>
#include <stropts.h>
#include <sys/types.h>
#include <sys/timeb.h>

#include "defs.h"
#include "param.h"
#include "frame.h"
#include "inferior.h"
#include "wait.h"
#include "expression.h"
#include "symtab.h"
#include "ui.h"
#include "value.h"

#include "montraps.h"
#include "remote.h"
#include "hmon/mon.h"

#define REMOTE_ENV_BAUD		"REMOTEBAUD"

#define	DEFAULT_RESET_TIMEOUT	(10)	/* Seconds to wait for target to reset*/
boolean resetting_remote;
boolean nmiing_remote;
boolean remote_errno;
boolean ignore_errors;			/* True while interrupting target */

u_char cpu_enabled[MAX_PROCESSORS];

int stop_cause;		/* Is (1 << SIGINT), (1 << SIGTRAP), or the or both */
int simulator;		/* True => we are using simulator.                  */

#define	L_BYTE		(1)
#define	L_SHORT		(2)
#define	L_WORD		(4)
#define	L_QUOTED1	(COMMAND_PREFIX1)
#define	L_QUOTED2	(COMMAND_PREFIX2)

struct compress {
	unsigned pattern;
	unsigned length;
};

#define	SIZEOF_COMPRESS_TABLE (sizeof(struct compress) * 256)

static void comm_err();
extern void request_quit ();
/* Variables for the remote tty line output buffer that we maintain
   in this file. */
static u_long output_buffercnt;
static unsigned char output_buffer[BUFSIZ];
static unsigned char *out_bp;
static void init_input_buffer();

static u_char input_buffer[BUFSIZ];
static u_char *input_buffer_p;
static input_buffer_cnt;
static void init_output_buffer();
static void flush_output_buffer();

jmp_buf controlc_env;
static u_char prev_char;

/* Last instruction to be fetched in preparation for printing the
   effect of the execution of this instruction after a single step. */
u_long last_iword;

/* The address from or to which the instruction in 'last_iword' would access. */
static CORE_ADDR ld_st_addr;

/* Checksum generated by the 'add_to_checksum()' macro in remote.h */
u_long checksum;

/* True if characters received or sent should be "added" to the checksum */
static u_long checksumming;

/* Partial word received from the target.  See 'get_byte()'. */
static u_long partial;

/* Number of bytes (0..3) of 'partial' that are valid. */
static u_long partial_length;

/* Forward declarations of functions in this file.  */

void open_debug_port();
void close_debug_port();
void close_control_port();
static void add_to_text_buffer();
static boolean user_mode_access();
static void interrupt_remote();

static boolean tty_line_init();
static boolean checksum_compress_table();
static unsigned long remote_188syscall();
void remote_select_processor();

/* These values are returned by the target when we first attach. */

u_long mon_compress_table_addr;	/* Only sent by XD-88 monitor                 */
u_long mon_dacc_address_addr;	/* Only sent by tek188mon (Moto)              */
u_long mon_report_comm_errors_addr;  /* Dito */

/* Target address of monitor's register area  for each processor */
u_long mon_register_area_addr[MAX_PROCESSORS];

u_long mon_single_step_trap_addr;  /* Target address of tb0 0,r0,253 instruc. */
u_long mon_date_addr;		   /* Target address of date string           */
u_long mon_time_addr;		   /* Target address of time string           */
u_long mon_panic_code_addr;	/* Target address of word w/ error code       */

u_long bytes_transmitted;
u_long total_bytes_transmitted;
u_long bytes_received;
u_long total_bytes_received;	/* # of bytes received in download process    */
double start_time;		/* Time that last download was started        */
double end_time;		/* Time that last download finished           */
u_long total_bytes_downloaded;  /* Number of bytes sent to target to download */
boolean downloaded;		/* True after download, used to warn user     */

char remote_tty_name[200];	/* File name of remote tty line               */
int remote_fd = -1;		/* File descriptor of remote tty line         */
int current_baud;		/* Current data rate of remote tty line       */
char lock_fname[1000];		/* File name of lock file for remote tty line */
boolean lock_gotten;		/* True if we have the remote tty line lock   */

int *reset_env;

struct compress compress_table[] = {
#include "compress.h"
};

static int direction;		/* 1 or 2 for receiving or transmitting       */

static struct itimerval new_timerval;
static struct itimerval old_timerval;

extern char *malloc();

/* Return true if the parameter is a data rate that we can set the tty
   line to. */
boolean
valid_baud(baud)
  int baud;
{
  switch (baud) {
    case 50:   case 75:    case 110:   case 150:   case 200:   case 300:
    case 600:  case 1200:  case 1800:  case 2400:  case 4800:
    case 9600: case 19200: case 38400:	
      return true;
  }
  return false;
}


/* Make sure that no one else is using the target.  We open a special
   file in /tmp to indicate that we are using it.  If the file already
   exists, perhaps some one else is using the target. */

void get_debug_line_mutex(debug_fname)
  char *debug_fname;
{
  int fd;
  char *p = rindex(debug_fname, '/');  /* Get tail of debug line file name*/

  if (lock_gotten) {
    return;
  }
  strcpy(lock_fname, "/tmp/gdb-lock-");
  if (p) {
    strcat(lock_fname, p + 1);
  }

  fd = open(lock_fname, O_RDONLY);
  if (fd > 0) {
    close(fd);
    rerr("Lock file %s exists, perhaps some one else is using the target?", 
                    lock_fname);
  }
  fd = open(lock_fname, O_CREAT, 0600);
  if (fd < 0) {
    rerr("Can not open lock file %s", lock_fname);
  }
  if (close(fd) != 0) {
    rerr("Error closing lock file %s", lock_fname);
  }
  lock_gotten = 1;
}

/* We are done with the debug line, get rid of the lock file. */

void release_debug_line_mutex()
{
  if (lock_gotten && unlink(lock_fname) != 0) {
    rerr("Error doing unlink of %s", lock_fname);
  }
  lock_gotten = 0;
}

/* Open a connection to a remote debugger.
   NAME is the filename used for communication.  */

void remote_open(name, from_tty)
  char *name;
  int from_tty;
{
  extern stop_after_attach;

  setvar("motomode", 1);  /* Delete this when we might run a Tek target */
  if (remote_debugging && !strcmp(name, remote_tty_name)) {
    rerr("Already attached to %s", remote_tty_name);
  }
  get_debug_line_mutex(name);
  if (!valid_baud(varvalue("baudrate"))) {
    setvar("baudrate", 38400);
  }
  strcpy(remote_tty_name, name);
  open_debug_port();
  spllo();
  if (varvalue("resetonattach")) {
    reset_remote();
  } else { 
    interrupt_remote();
  }

  print_comm_statistics();
  stop_after_attach = 1;

  /* What ptrace reports after attaching a process */
  stop_cause |= (1 << SIGTRAP);

  get_monitor_addresses();
  remote_debugging = 1;
}

/* Close the tty port used to communicate with the target if it is open */

void close_debug_port()
{
  if (remote_fd > 0) {
    if (close(remote_fd) != 0) {
      ui_badnews(-1, "close_debug_port: error closing %s", remote_tty_name);
    }
    remote_fd = -1;
  }
}

/*
 * This closes the tty line that we've been communicating with the target
 * over.  Since we do not have output flow control (DOCTS), we shouldn't
 * block here.
 */
void remote_close(from_tty)
{
  release_debug_line_mutex();
  close_control_port();
  close_debug_port();
}

/* Called when we get an error.  Display the
   error message after turning interrupts back on. */

/*VARARGS1*/
void rerr(fmt, a, b, c, d, e, f, g)
  char *fmt;
{
  spllo();
  ui_badnews(-1, fmt, a, b, c, d, e, f, g);
}

/*
 * This is called when we get an error command from the target.  
 */
void handle_target_rerr(c)
    u_char c;
{
    switch (c) {
        case C_CHECKSUMERR:
            ui_fprintf(stderr, 
                  "Target got checksum error, it expected 0x%x but got 0x%x\n",
                            get_word(), get_word());
            break;

        case C_BADCOMMAND:
            ui_fprintf(stderr, "Target got bad command: %s\n", 
                           comm_name(get_byte(), COMMAND_PREFIX1));
            break;

        case C_COMMERR:
            ui_fprintf(stderr, 
                    "Target got communication error on receive, status=0x%x\n",
                            get_byte());
            break;

        case C_COMPRESSERR:
            ui_fprintf(stderr,
                     "Target got a compression error, it must be quite ill\n");
            break;

        case C_EXPECTEDTOKEN:
            ui_fprintf(stderr, "Target expected %s, but got %s\n", 
                           comm_name(get_byte(), COMMAND_PREFIX1), 
                           comm_name(get_byte(), COMMAND_PREFIX1));
            break;

        default:
          rerr("Case error in handle_target_error()");
    }

    /* If the target is not running, we want to abort the current
       command.  If it was in g88_read() or g88_write(), we want
       to keep listening to the debug port in the hope that the
       target will be ok by the time it hits an exception.  If
       it was running, but got the comm error while trying to
       tell us about its exception, we will erroneously keep
       waiting for the exception. */
    if (!target_running) {
      rerr("");
    }
}

/*
 * Initialize most of the variables used in cross-debugging.
 */
void init_globals()
{
  int i;
  for (i = 0 ; i < MAX_PROCESSORS ; i++) {
    cpu_enabled[i] = 0;
  }
  selected_processor = 0;
  cpu_enabled[0] = 1;
  stop_cause = 0;
  target_running = false;
  downloaded = false;
  resetting_remote = false;
  nmiing_remote = false;
  ignore_errors = false;
  remote_errno = false;
  total_bytes_transmitted = 0;
  total_bytes_received = 0;
  bytes_transmitted = 0;
  bytes_received = 0;
  start_time = 0.0;
  end_time = 0.0;
  partial = 0;
  partial_length = 0;
  checksumming = 0;
  checksum = 0;
  current_baud = 0;  /* Force it to be set next time setbaud() is called */
  invalidate_mem_cache();
  init_output_buffer();
  init_input_buffer();
  init_buffers();
}

#define BUFFERSIZE	(200)

struct buffer *receive_buffer, *transmit_buffer;

/* We store the last BUFFERSIZE (or $buffersize, if it is set) lines that
   were or would have been displayed by having $traceremote set. This
   supports the lasta command. */

char **text_buffer_base, **text_buffer;
int text_buffer_index, text_buffer_size;

/* Set up a buffer for transmitted and received characters so that
   the user can look look at a transactions w/ the target after it
   has happened. */
static void init_buffers()
{
  int buffersize = varvalue("buffersize");
  if (buffersize == 0) {
    setvar("buffersize", buffersize = BUFFERSIZE);
  }
  if (receive_buffer != (struct buffer *)0) {
    free((char *)receive_buffer);
  }
  receive_buffer = (struct buffer *)malloc(sizeof(struct buffer));
  receive_buffer->data = (u_char *)malloc(buffersize);
  receive_buffer->size = buffersize;
  receive_buffer->head = 0;

  if (transmit_buffer != (struct buffer *)0) {
    free((char *)transmit_buffer);
  }
  transmit_buffer = (struct buffer *)malloc(sizeof(struct buffer));
  transmit_buffer->size = buffersize;
  transmit_buffer->data = (u_char *)malloc(buffersize);
  transmit_buffer->head = 0;

  /* Free any storage that the previous text buffer had been using. */
  if (text_buffer_base != (char **)0) {
    int i;
    text_buffer = text_buffer_base;
    for (i = 0 ; text_buffer && *text_buffer && i < text_buffer_size ; i++) {
      free(*text_buffer++);
    }
    free((char *)text_buffer_base);
  }
  text_buffer_size = buffersize;
  text_buffer_base = (char **)malloc(sizeof(char *) * text_buffer_size);
  bzero((char *)text_buffer_base, sizeof(char *) * text_buffer_size);
  text_buffer = text_buffer_base;
  text_buffer_index = 0;
}

/* Take the passed line of text and copy into to some newly malloc'd
   memory and make the current text buffer slot point to it. */

static void add_to_text_buffer(text)
  char *text;
{
  if (*text_buffer != (char *)0) {
    free(*text_buffer);
  }
  *text_buffer = malloc(strlen(text) + 1);
  strcpy(*text_buffer, text);
  text_buffer++;
  text_buffer_index++;
  if (text_buffer_index == text_buffer_size) {
    text_buffer = text_buffer_base;
    text_buffer_index = 0;
  }
}

/* Add the passed character to the passed buffer. */

static void add_to_buffer(buffer, c)
  struct buffer *buffer;
  u_char c;
{
  buffer->data[buffer->head] = c;
  buffer->head = (buffer->head + 1) % buffer->size;
}


/* This is called by functions that interact with the target.  They pass
   printf-like arguments that describe what they are doing with the target
   and what the target is reponding with.  If $traceremote is set, we
   display the string.  In any case, we save the string in a text buffer
   that can be displayed with the lasta command. */

/*VARARGS1*/
void traceremote(fmt, a, b, c, d, e, f, g, h)
  char *fmt;
{
  char buf[1000];
  if (varvalue("traceremote")) {
    ui_fprintf(stderr, fmt, a, b, c, d, e, f, g, h);
  }
  sprintf(buf, fmt, a, b, c, d, e, f, g, h);
  add_to_text_buffer(&buf[0]);
}

/* This flushes any crud that might be waiting for us.  */

void flush_tty_line()
{
#define FBUFSIZE (1000)		/* Size of flush buffer.                  */
#define SHOWCNT	 (300)		/* Number of flushed chars to display     */

    u_char buf[FBUFSIZE], prev_char;
    int  cnt, i, first_time = 1;
    int  overall_cnt = 0;

    prev_char = '\0';
    init_output_buffer();
    while ((cnt = read(remote_fd, (char *)&buf[0], FBUFSIZE)) > 0) {
        int i, show_in_ascii = 1;
        overall_cnt += cnt;
	for (i = 0 ; i < cnt ; i++) {
          if  (buf[i] > 127) {
            show_in_ascii = 0;
            break;
          }
        }
        if (first_time || varvalue("traceremote")) {
          first_time = 0;
          ui_fprintf(stderr, "flushed: ");
          if (show_in_ascii) {
            ui_fprintf(stderr, "%s", buf);
          } else {
            for (i = 0 ; i < cnt && i < SHOWCNT ; i++) {
              ui_fprintf(stderr, "%s ", comm_name(buf[i], prev_char));
              prev_char = buf[i];
            }
          }
          ui_fprintf(stderr, "\n");
        }
        if (overall_cnt > 2000) {
            ui_fprintf(stderr, "Target is going wild, reset it? (y/n)");
            if (getchar() == 'y') {
                send_reset_signal();
                flush_output_buffer();
                invalidate_mem_cache();
                sleep(1);
            }
            overall_cnt = 0;
        }
    if (!first_time) {
      ui_fprintf(stderr, "<end of flushing>\n");
    }
  }
}


/*
 * This looks for the passed command from the remote.  It returns
 * true if the thing being waited for was the next character, false
 * otherwise.
 */
int wait_for_token(token1, token2, timeout_action, timeout)
    u_char token1, token2;
    timeout_action_t timeout_action;
    int     timeout;
{
  u_char c;

  do {
    c = get_remote_char(timeout_action, timeout);
    if (c != COMMAND_PREFIX1) {
      if (c == '\r' && varvalue("motomode")) {
        ui_fprintf(stderr,
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
        resetting_remote = false;
        do_pass_command("", true, true);
        flush_tty_line();
        rerr("");
      } 
      if (!ignore_errors) {
        rerr("Received %s instead of COMMAND_PREFIX1", comm_name(c, 0));
      }
      return 0;
    }

    c = get_remote_char(timeout_action, timeout);
  } while (c == C_SYNC && token1 != C_SYNC && token2 != C_SYNC);
    
  if (c != token1 && c != token2) {
    unsigned exception_code, new_processor;

    switch (c) {
      case C_EXCEPTION:
        invalidate_mem_cache();
        new_processor = get_word();
        exception_code = get_word();
        remote_select_processor(new_processor, true);
        ui_fprintf(stderr, "\nCPU %d took ", new_processor);
        if (exception_code < 512) {
          ui_fprintf(stderr, "%s", exception_name(exception_code));
        } else {
          ui_fprintf(stderr, "an exception, but the code was garbled.\n");
        }
        ui_fprintf(stderr, ".  This happened while waiting for a %s or a %s\n",
                                    comm_name(token1, COMMAND_PREFIX1), 
                                    comm_name(token2, COMMAND_PREFIX2));
        break;

      case C_CHECKSUMERR:
      case C_COMMERR:
      case C_BADCOMMAND:
      case C_COMPRESSERR:
      case C_EXPECTEDTOKEN:
        handle_target_rerr(c);
        break;

      default:
        if (c == '\r' && varvalue("motomode")) {
          ui_fprintf(stderr, 
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
          resetting_remote = false;
          do_pass_command("", true, true);
          flush_tty_line();
          rerr("");
        } 
        flush_tty_line();
        rerr("Received %s instead of %s or a %s", 
              comm_name(c, COMMAND_PREFIX1),
              comm_name(token1, COMMAND_PREFIX1), 
              comm_name(token2, COMMAND_PREFIX1));
        break;
    }
    return C_NONE;
  }
  return c;
}

/* Return true if the processor is currently in the target debug 
   monitor. */

boolean in_monitor(processor)
  int processor;
{
  struct all_vars v;	/* For soff() macro */
  invalidate_mem_cache();	/* In case it is stale. */
  return read_remote_w(mon_register_area_addr[processor] + soff(dm_in_mon), 
                       M_SUPERVISOR) == IN_MON_MAGIC;
}

/* Return the exception code for the processor. */

int processor_exception_code(processor)
  int processor;
{
  struct all_vars v;	/* For soff() macro */
  invalidate_mem_cache();	/* In case it is stale. */
  return read_remote_w(mon_register_area_addr[processor] + 
                       soff(dm_exception_code), M_SUPERVISOR);
}


/* Make the passed processor number be the new current  processor
   number and copy its registers to the working registers. */

void remote_select_processor(processor, force)
  int processor;
  int force;   /* True => do it anyway */
{
  char buf[100];

  if (force || in_monitor(processor)) {
    selected_processor = processor;
    sprintf(buf, "[%d] (gdb)", selected_processor);
    set_either_prompt_command (0, buf);
    if (varvalue("showswitch")) {
      ui_fprintf(stdout, "MP:%d ", processor);
      ui_fflush(stdout);
    }
  } else {
    rerr("CPU %d is not stopped in the monitor, cannot select it", processor);
  }
}

/*
 * This listens to the remote, waiting for an exception to
 * occur.
 */
boolean wait_for_exception(expected_exception, timeout_action, timeout)
  unsigned expected_exception;
  timeout_action_t timeout_action;
  int     timeout;
{
  u_char c;
  char *buf;
  unsigned i, new_processor;
  u_long actual_length;	/* # of characters read to satisfy db_read */
  u_long length;		/* Length of target's db_read buffer       */
  struct termio t, old_t;
  boolean ioctl_flag;
  static int terminal_fd = 0;		/* We do ioctl's on this             */

  while (1) {
    init_checksum();
    while ((c = get_remote_char(timeout_action, timeout)) != COMMAND_PREFIX1) {
      if (!ignore_errors) {
        ui_fprintf(stderr, "w-f-e: expected P1, got instead: %s\n", 
                                                         comm_name(c, 0));
        if (c == '\r' && varvalue("motomode")) {
          ui_fprintf(stderr, 
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
          resetting_remote = false;
          do_pass_command("", true, true);
          flush_tty_line();
          rerr("");
        } 
      }
      init_checksum();
    }

    splhi();
    c = get_remote_char(timeout_action, timeout);
    switch (c) {
      unsigned exception_code;

      case C_EXCEPTION:
        target_running = false;
        invalidate_mem_cache();
        new_processor = get_word();
        exception_code = get_word();
        if (!cpu_enabled[new_processor]) {
          if (expected_exception != TR_INT) {
            ui_fprintf(stderr, "Idle processor saw unexpected abort interrupt.\n");
          }
          ui_fprintf(stdout, 
   "Running processor(s) didn't see the interrupt, idle processor took over\n");
        }
	remote_select_processor(new_processor, true);
        spllo();
        if (exception_code == expected_exception) {
          traceremote("Expected and received the exception: %s\n",
                             exception_name(exception_code));
          return true;
        }
        switch (expected_exception) {
          case TR_TRC:
            rerr("Target got %s while trying to single step.",
                            exception_name(exception_code));

          case TR_BPT:
            rerr("Target got %s.", exception_name(exception_code));
            break;

          default:
            if (exception_code < 512) {
              rerr("While waiting for %s, target got %s",
                                   exception_name(expected_exception),
                                   exception_name(exception_code));
            } else {
              rerr(
     "While waiting for %s, target got an exception, but the code was garbled.",
                                      exception_name(expected_exception));
            }
            break;
          }
          return false;
        break;

      case C_DBREAD:
        length = get_word();
        verify_checksum();
        if (length > 1024*1024) {
          rerr("Received outrageous length, %d on dbread.", length);
          break;
        }
        traceremote("reading %d character string for remote.\n", length);
        length++;	/* Extra byte for the null */
        if (!(buf = malloc((unsigned)length))) {
          rerr("dbread: unable to malloc a %d bytes", length);
        }
        ioctl_flag = 0;
        switch (varvalue("showinput")) {
          case 0: break;
          case 1: 
            ui_fprintf(stdout, "g88_input(%d)> ", length); 
            ui_fflush(stdout);
            break;;

          case 2: 
            save_terminal_mode();
            init_terminal_mode();
            ioctl_flag = 1;
            break;

          default:
            fprintf(stderr, "$showinput has invalid value, now set to 0\n");
            setvar("showinput", 0);
            break;
        }
        actual_length = read(terminal_fd, &buf[0], length);
        if (actual_length < 0 || actual_length > length) {
          fprintf(stderr, "dbread: error doing read(), length=%d", length);
        }
        if (ioctl_flag) {
          restore_terminal_mode();
        }
        init_checksum();
        send_command(C_DATASTART);
        send_word(actual_length);
        for (i = 0 ; i < actual_length ; i++) {
          send_byte((u_char)buf[i]);
        }
        free(buf);
        send_command(C_DATAEND);
        send_checksum();
        spllo();
        break;

      case C_DBWRITE:
        length = get_word();
        if (length > 1024*1024) {
          rerr("Received outrageous length, %d on dbwrite.", length);
          break;
        }
        traceremote("receiving %d character string from remote.\n", length);
        switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
          case C_DATASTART:
            for (i = 0 ; i < length ; i++) {
              ui_putchar(get_byte());
              ui_fflush(stdout);
            }
            if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
              ui_fprintf(stderr, "\nDidn't find C_DATAEND in DBWRITE\n");
              break;
            }
            verify_checksum();
            break;

          case C_DATAERROR:
            dacc_rerr("fetching characters for DBWWRITE");

          default:
            rerr("Didn't find C_DATASTART in DBWRITE");
            break;
        }
        spllo();
        break;

      case C_CHECKSUMERR:
      case C_COMMERR:
      case C_BADCOMMAND:
      case C_COMPRESSERR:
      case C_EXPECTEDTOKEN:
        handle_target_rerr(c);
        return false;

      default:
        if (c == '\r' && varvalue("motomode")) {
          ui_fprintf(stderr, 
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
          resetting_remote = false;
          do_pass_command("", true, true);
          flush_tty_line();
          rerr("");
        } 
        if (!ignore_errors) {
          rerr("wait_for_exception: got %s", comm_name(c, COMMAND_PREFIX1));
        }
        break;
    }
  }
}

/*
 * Send the 0x81 code to the target in order to reset it.  The kludge
 * board will see this code and pull 88k's reset line.  
 */
void reset_remote()
{
  int timeout;
  jmp_buf timeout_env;

  reset_env = &timeout_env[0];	/* So code in motomode can longjmp to us */

  init_globals();
  resetting_remote = true;
  if (varvalue("resettimeout") <= 0) {
    setvar("resettimeout", DEFAULT_RESET_TIMEOUT);
  }

  /* The user may be resetting the target because power was
     cycled.  If this happens, we will start getting parity errors
     when gdb tries to access target memory unless we tell the
     target monitor to initialize parity before reading.  */

  setvar("noparityinit", 0);

  if (setjmp(timeout_env)) {
      resetting_remote = false;
      if (remote_debugging) {
        rerr("Timeout trying to reset target.");
      } else {
        rerr("\n\
Error while trying to reset target.  Try the attach command again.\n\
You may use the init command.  The flush command may also be useful.\n");
      }
  } else {
    flush_tty_line();
    invalidate_mem_cache();
    if (varvalue("motomode")) {
      char *init_string;
      switch (varvalue("baudrate")) {
        case 9600:
          init_string = "*r\r*e\r*W188-Bug>\r*c\r";
          break;

        case 19200:
          init_string = "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b \
19200\r*W188-Bug>\r*c\r";
          break;

        case 38400:
          init_string = "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b \
19200\r*W188-Bug>\rmm fff82013;nb\r*p\r40\r*b 38400\r.\r*W188-Bug>\r*c\r";
          break;

        default:
          ui_badnews(-1, "$baudrate only supported for values of 9600, \
19200, and 38400 in motomode");
      }
      do_pass_command(init_string, 
                      false, 
                      varvalue("traceremote"));
    } else {
      send_reset_signal();
    }
    timeout = varvalue("resettimeout");
    
    if (setjmp(timeout_env)) {
      resetting_remote = false;
      if (remote_debugging) {
        rerr("Timeout trying to reset target, while waiting for reset exception.");
      } else {
        rerr("\n\
Error while trying to reset target while waiting for the reset exception\n\
report from the target.  Try the attach command again.\n\
You may use the init command.  The flush command may also be useful.\n");
      }
    } else {
      if (wait_for_exception(TR_RESET, timeout_env, timeout)) {
        traceremote("Target received reset signal.\n");
        stop_cause = 0;
      } else {
        resetting_remote = false;
        rerr("Unable to reset remote.");
      }
    }
  }
  resetting_remote = false;
}

/* Send an interrupt signal to the target and wait for the target to
   report an interrupt exception.  If we think the target is already
   in the target debug monitor, just send it a C_SYNC and see if we
   get a C_SYNC back, don't interrupt it. */

static void interrupt_remote()
{
  static boolean trying_to_sync = false;
  jmp_buf timeout_env;

  if (!trying_to_sync && !target_running) {
    trying_to_sync = true;
    if (setjmp(timeout_env) == 0) {
      traceremote("sending C_SYNC to target...\n");
      flush_tty_line();
      send_command(C_SYNC);
      flush_output_buffer();
      if (wait_for_token(C_SYNC, C_NONE, timeout_env, 1) == C_SYNC) {
        trying_to_sync = false;
        stop_cause |= (1 << SIGINT);
        return;
      }
    }
  }

  trying_to_sync = false;
  nmiing_remote = true;
  if (setjmp(timeout_env)) {
    nmiing_remote = false;
    rerr("Timeout trying to interrupt target.");
  } else {
    traceremote("Interrupting target ...\n");
    flush_tty_line();
    send_interrupt_signal();
    fflush(stdout);
    ignore_errors = true;
    invalidate_mem_cache();
    if (wait_for_exception(TR_INT, timeout_env, 2 /* seconds */)) {
      stop_cause |= (1 << SIGINT);
      traceremote("Target received debug interrupt.\n");
      check_for_delay_slot_after_interrupt();

      if ((remote_read_register(DMT0_REGNUM) & 1)) {
          ui_fprintf(stdout, 
                      "Warning: DMU fault: DMT0=0x%x DMD0=0x%x DMA0=0x%x\n",
                         remote_read_register(DMT0_REGNUM), 
                         remote_read_register(DMD0_REGNUM),
                         remote_read_register(DMA0_REGNUM));
      }
    } else {
      nmiing_remote = false;
      rerr("Unable to interrupt target\n");
    }
    ignore_errors = false;
  }
  nmiing_remote = false;
  fflush(stdout);
}


/*
 * Get the pointers to various monitor data structures by
 * asking the monitor.
 */
void get_monitor_addresses()
{
    u_long addr;
    int     i, c;
    char buf[100];
    char *periodp;

    init_checksum();
    splhi();
    send_command(C_RETPTRS);
    send_command(C_END);
    send_checksum();

    init_checksum();
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
        case C_DATASTART:
            break;

        case C_DATAERROR:
            rerr("Target got error while sending monitor addresses");

        default:
            rerr("Didn't find C_DATASTART in get_monitor_addresses");
    }

    if (!varvalue("motomode")) {
      mon_compress_table_addr = get_word();
      traceremote("mon_compress_table_addr=0x%x\n", mon_compress_table_addr);
    }

    for (i = 0 ; i < MAX_PROCESSORS ; i++) {
      mon_register_area_addr[i] = get_word();
      traceremote("mon_register_area_addr[%d]=0x%x\n", 
                   i, mon_register_area_addr[i]);
      if ((mon_register_area_addr[i] & 7) != 0) {
        ui_fprintf(stderr, "WARNING: monitor's register area is misaligned.\n");
      }
    }

    mon_single_step_trap_addr = get_word();
    traceremote("mon_single_step_trap_addr=0x%x\n", mon_single_step_trap_addr);

    mon_date_addr = get_word();
    traceremote("mon_date_addr=0x%x\n", mon_date_addr);

    mon_time_addr = get_word();
    traceremote("mon_time_addr=0x%x\n", mon_time_addr);

    mon_report_comm_errors_addr = get_word();

    traceremote("mon_report_comm_errors_addr=0x%x\n", 
                 mon_report_comm_errors_addr);

    if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
        rerr("Didn't find C_DATAEND in get_monitor_addresses\n");
    }
    verify_checksum();

    addr = mon_date_addr;
    i = 0;
    while ((c = read_remote_b(addr++, M_SUPERVISOR)) != 0 && 
           i < (sizeof(buf) - 1)) {;
        buf[i++] = c;
    }
    buf[i++] = ' ';
    addr = mon_time_addr;
    while ((c = read_remote_b(addr++, M_SUPERVISOR)) != 0 && 
           i < (sizeof(buf) - 1)) {;
        buf[i++] = c;
    }
    buf[i] ='\0';
    ui_fprintf(stdout, "Tek/HRI Target debug monitor alive  version: %s\n", buf);
    spllo();
}

/*
 * Set the data rate of the remote tty line.
 */
void setbaud(new_baud)
  int new_baud;
{
  struct termio t;
  int baud_code;

  if (new_baud == current_baud) {
    return;
  }
  switch (new_baud) {
    case 50:	baud_code = B50;	break;
    case 75:	baud_code = B75;	break;
    case 110:	baud_code = B110;	break;
    case 150:	baud_code = B150;	break;
    case 200:	baud_code = B200;	break;
    case 300:	baud_code = B300;	break;
    case 600:	baud_code = B600;	break;
    case 1200:	baud_code = B1200;	break;
    case 1800:	baud_code = B1800;	break;
    case 2400:	baud_code = B2400;	break;
    case 4800:	baud_code = B4800;	break;
    case 9600:	baud_code = B9600;	break;
    case 19200:	baud_code = EXTA;	break;

    case 0:
    case 38400:	baud_code = EXTB;	break;

    default:
      rerr("Can't set remote tty line to %d baud", new_baud);
  }
  if (ioctl(remote_fd, TCGETA, &t) < 0) {
    rerr("setbaud: Error in doing TCGETA ioctl to %s", remote_tty_name);
  }

  t.c_cflag = (t.c_cflag & ~CBAUD) | baud_code;

  if (ioctl(remote_fd, TCSETAW, &t) < 0) {
        rerr("setbaud: Error in doing TCSETAW ioctl to %s", remote_tty_name);
  }
  current_baud = new_baud == 0 ? 38400 : new_baud;
}

/*
 * This initializes the remote communication line.
 * This was *not* lifted from targ_init.c in remote adb.
 */
void open_debug_port()
{
  struct termio t;
  char *env_tty_name;
  char *getenv();

  /*
   * If we already have a tty line open, close it to conserve
   * on file descriptors.
   */
  if (remote_fd > 0) {
    close_debug_port();
  }

  if ((remote_fd = open(remote_tty_name, O_RDWR | O_NDELAY)) < 0) {
    remote_fd = -1;
    rerr("Cannot open %s", remote_tty_name);
  }

  if (ioctl(remote_fd, TCGETA, &t) < 0) {
    rerr("open_debug_port: Error in doing TCGETA ioctl");
  }

  t.c_oflag = 0;

  /* Attempt to turn on hardware flow control (seems like SUN-OS
     isn't doing this). */

  t.c_cflag = CRTSCTS | CS8 | CREAD | (t.c_cflag & CBAUD);
  t.c_line = 0;

  /* Have the system send control-S/control-Q to throttle the target.
     Ignore breaks and parity errors. */

  t.c_iflag = IXOFF | IGNBRK | IGNPAR;
  t.c_lflag = 0;
  t.c_cc[VMIN] = 0;
  t.c_cc[VTIME] = 0;
  t.c_cc[VSTART] = 0x81;
  t.c_cc[VSTOP] = 0x82;
  if (ioctl(remote_fd, TCSETA, &t) < 0) {
    rerr("open_debug_port: Error in doing TCSETA ioctl");
  }
  setbaud(varvalue("baudrate"));

#ifdef	SIGIO_WORKS	/* Doesn't work in SUN-OS   91.1.1 */
  /* Request a SIGIO when there is data ready (this appears not to work) */

  if (fcntl(remote_fd, F_SETFL, FASYNC) < 0) {
    rerr("open_debug_port: Error doing fcntl to set flags on %s", 
                                                             remote_tty_name);
  }
#endif

  /* Make I/O asynchronous (this should not be necessary because we
     specified (O_NDELAY in the open, but this appears not to work) */

  if (fcntl(remote_fd, F_SETFL, FNDELAY) < 0) {
    rerr("open_debug_port: Error doing fcntl to set flags on %s", 
                                                             remote_tty_name);
  }
}

/*
 * Lookup the name as a convenience variable, return it's value.
 */
u_long varvalue(varname) 
    char *varname;
{
  struct internalvar *var;

  var = lookup_internalvar(varname);
  if (TYPE_CODE(VALUE_TYPE(var->value)) != TYPE_CODE_INT) {
    return 0;
  }
  return value_as_long(var->value);
}

/*
 * This an internal variable (now used only for setting "noparityinit"
 * to 0 and 1.
 */
void setvar(varname, newvalue)
    char *varname;
    int newvalue;
{
  struct internalvar *var = lookup_internalvar(varname);
  set_internalvar(var, value_from_long(builtin_type_int, newvalue));
}

/* This is called when the process in which this program is running
   receives a SIGINT, which is usually the result of the user hitting 
   control-c.  */
void remote_request_quit()
{
  /* True if the target was running before we interrupted it */
  boolean target_was_running;	

  if (resetting_remote || nmiing_remote) {
    resetting_remote = false;
    nmiing_remote = false;
    return_to_top_level();
  }

  /* If we have not yet successfully attached, 'remote_debugging' will
     be false.  But 'resetting_remote' might be true, so we test it first. */
    
  if (!remote_debugging) {
    return;
  }
  if (simulator) {
    sim_interrupt();
    quit_flag = 0;
    return;
  }

  target_was_running = target_running;

  /* Attempt to interrupt the target.  If we are successful, unwind
     the stack and let go_remote return to its caller.  */

  interrupt_remote();
  quit_flag = 0;
  if ((stop_cause & (1 << SIGINT)) && target_was_running) {
    ui_fprintf(stdout, "Target interrupted\n");
    longjmp(controlc_env, 1);	/* Return to go_remote()              */
  }

  if (!target_was_running) {
    traceremote("Target alive and was already in debug monitor");
  }

  if (!(stop_cause & (1 << SIGINT)) && target_was_running) {
    ui_fprintf(stdout, 
    "Target hit breakpoint while we were trying to interrupt it\n");
  }
}

/*
 * This returns the string corresponding to the passed command.  
 * 'prev_char' is the previous character.  This helps comm_name 
 * determine whether 'c' is a command or not.
 */
char *comm_name(c, prev_char)
    u_char c;
    u_char prev_char;
{
  static char str[100];
  static char *comm_names[] = 
    { "C_DOWNLOAD", "C_UPLOAD", "C_CHECKSUM", "C_END", "C_GO",
      "C_DATASTART", "C_CHECKSUMERR", "C_ACK", "C_DATAEND", "C_FILL",
      "C_RETPTRS", "C_EXCEPTION", "C_DBWRITE", "C_DBREAD", 
      "C_SYNC", "C_DATAERROR", "C_UPLOADNOINIT", "C_CHECKSUMNOINIT",
      "C_SEARCH", "C_COPYMEM", "C_UPLOADUSER", "C_UPLOADNOINITUSER",
      "C_DOWNLOADUSER", "C_EXPECTEDTOKEN", "C_COMMERR", 
      "C_COMPPRESSERR", "C_BADCOMMAND", "C_188SYSCALL" }; 

  if (passthroughmode) {
    switch (c) {
      case C_RESET:          return "C_RESET"; break;
      case C_NMI:            return "C_NMI";   break;
    }
    sprintf(str, "%02X", c);
      return str;
  }
        
  switch (c) {
    case C_RESET:          return "C_RESET"; break;
    case C_NMI:            return "C_NMI";   break;
    case COMMAND_PREFIX1:  return "P1";      break;
    case COMMAND_PREFIX2:  return "P2";      break;

    case C_DOWNLOAD:  case C_UPLOAD:     case C_CHECKSUM:  case C_END:
    case C_GO:        case C_DATASTART:  case C_CHECKSUMERR:
    case C_ACK:
    case C_DATAEND:   case C_FILL:       case C_RETPTRS:   case C_EXCEPTION:
    case C_DBWRITE:   case C_DBREAD:     case C_SYNC:      
    case C_DATAERROR: case C_UPLOADNOINIT: case C_CHECKSUMNOINIT:
    case C_SEARCH:    case C_COPYMEM:    case C_UPLOADUSER:
    case C_UPLOADNOINITUSER:             case C_DOWNLOADUSER:
    case C_EXPECTEDTOKEN:                case C_COMPRESSERR:
    case C_COMMERR:   case C_BADCOMMAND: case C_188SYSCALL:
      if (prev_char == COMMAND_PREFIX1) {
        return comm_names[c - C_DOWNLOAD];
      }
      break;

    default:
      break;
  }
            
  sprintf(str, "%02X", c);
  return str;
}

/*
 * Returns true if the passed token indicates the target detected an
 * error.
 */
static boolean iserrtoken(token)
    u_char token;
{
  return token == C_CHECKSUMERR   ||
         token == C_EXPECTEDTOKEN ||
         token == C_COMPRESSERR   ||
         token == C_COMMERR       ||
         token == C_BADCOMMAND;
}

/*
 * This resets our output buffer, the one we use for sending bytes
 * to the target.
 */
static void init_output_buffer()
{
  output_buffercnt = 0;
  out_bp = &output_buffer[0];
}


/*
 * Sends the passed command to the other agent.
 */
void send_command(command)
  u_char command;
{
  put_remote_char(COMMAND_PREFIX1);
  put_remote_char(command);
}

/*
 * This initializes the checksum
 */
void init_checksum()
{
  checksum = 0;
  checksumming = true;
}

/*
 * Sends the checksum to the other agent.
 */
void send_checksum()
{
	checksumming = false;
	send_word(checksum);
}

/*
 * This sends the passed word to the other agent.  It does the
 * data compression.
 */
void send_word(word)
    u_long word;
{
	struct compress *ct = &compress_table[0];

	while (ct->length == 4 || ct->length == 0) {
		if (ct->pattern == word && ct->length == 4) {
			put_remote_char((u_char)(ct - &compress_table[0]));
			return;
		}
		ct++;
	}
	send_short((u_short)((word >> 16) & 0xffff));
	send_short((u_short)(word & 0xffff));
}

/*
 * This sends a short to the other agent.
 */
void send_short(s)
	u_short s;
{
	struct compress *ct = &compress_table[SHORT_OFFSET];

	while (ct->length == 2 || ct->length == 0) {
		if (ct->pattern == s && ct->length == 2) {
			put_remote_char((u_char)(ct - &compress_table[0]));
			return;
		}
		ct++;
	}
	send_byte((s >> 8) & 0xff);
	send_byte(s & 0xff);
}

/*
 * This sends a byte to the other agent.
 */
void send_byte(byte)
	u_char byte;
{
	struct compress *ct = &compress_table[BYTE_OFFSET];

	while (ct < &compress_table[256]) {
		if (ct->pattern == byte && ct->length == 1) {
			put_remote_char((u_char)(ct - &compress_table[0]));
			return;
		}
		ct++;
	}
	/*
	 * We couldn't compress the byte.  Send it using the two byte
	 * sequence.
	 */
	if (byte & 0x80) {
		put_remote_char(COMMAND_PREFIX2);
	} else {
		put_remote_char(COMMAND_PREFIX1);
	}
	put_remote_char(byte & 0x7f);
}

/*
 * This returns an unsigned word from the comm port (from other agent).
 */
unsigned get_word()
{
	unsigned t = 0;
	unsigned i;

	for (i = 0 ; i < 4 ; i++) {
		t <<= 8;
		t |= get_byte();
	}
	return t;
}

/*
 * This returns an unsigned short from the comm port (from other agent).
 */
unsigned get_short()
{
        unsigned w = get_byte();

	return (w << 8) | get_byte();
}

/*
 * This returns a decode byte from the comm port (from other agent).
 */
unsigned get_byte()
{
	unsigned c;
	struct compress *ct;

	if (partial_length) {
		partial_length--;
		c = (partial >> 24) & 0xff;
		partial <<= 8;
		return c;
	}

	c = get_remote_char(ta_warning, 1 /* second */);
	ct = &compress_table[c];
	switch (ct->length) {
		case L_QUOTED1:
			c = get_remote_char(ta_warning, 1 /* second */);
                        if (c > 0x7f) {
                            switch (c) {
                                case C_DATAERROR:
                                    dacc_rerr("in get_byte()");

                                case C_CHECKSUMERR:
                                case C_COMMERR:
                                case C_BADCOMMAND:
                                case C_COMPRESSERR:
                                case C_EXPECTEDTOKEN:
                                    handle_target_rerr(c);
                                    break;

                                default:
                                    rerr("Unexpected: %s", 
                                            comm_name(c, L_QUOTED1));
                            }
                        }
			return c;

		case L_QUOTED2:
			c = get_remote_char(ta_warning, 1 /* second */);
                        if (c > 0x7f) {
                            rerr("Unexpected value after L_QUOTED2: %d", c);
                        }
			return c + 0x80;

		case L_BYTE:
			return ct->pattern;

		case L_SHORT:
			partial_length = 1;
			partial = ct->pattern << 24;
			return (ct->pattern >> 8) & 0xff;

		case L_WORD:
			partial_length = 3;
			partial = ct->pattern << 8;
			return (ct->pattern >> 24) & 0xff;

		default:
			rerr("Case error in get_byte()");
			/*NOTREACHED*/
	}
	/*NOTREACHED*/
}

/*
 * This reads the checksum from the comm line and compares it
 * with the value in the global 'checksum'.
 */
void verify_checksum()
{
	u_long received_checksum;

	checksumming = false;
	received_checksum = get_word();
	if (checksum != received_checksum) {
		rerr("Checksum error, expected=0x%x received=0x%x",
                                              checksum, received_checksum);
	}
}

/*
 * This sends the passed character without any compression or
 * interpretation to the target.
 */
void put_remote_char(c)
    u_char c;
{
  static u_char prev_char;

  if (out_bp == nil) {
    rerr("put_remote_char: output buffer not initialized\n");
  }
  if (checksumming) {
    add_to_checksum(c);
  }
  *out_bp++ = c;
  output_buffercnt++;
  add_to_buffer(transmit_buffer, c);

  if (output_buffercnt == BUFSIZ) {
    flush_output_buffer();
  }
  if (varvalue("tracetransmit")) {
    if (direction != transmitting) {
      ui_fprintf(stderr, "\ntransmitting:\n");
      direction = transmitting;
    }
    ui_fprintf(stderr, "%s ", comm_name(c, prev_char));
    prev_char = c;
  }
}

/*
 * This sends any bytes that are in the output buffer to the remote.
 */
static void flush_output_buffer()
{
  int cnt;
  struct timeval tv;
  fd_set fdset;

  if (output_buffercnt == 0) {
    return;
  }
  tv.tv_sec = 2;
  tv.tv_usec = 0;
  FD_ZERO(&fdset);
  FD_SET(remote_fd, &fdset);
  if (select(FD_SETSIZE, (int *)0, &fdset, (int *)0, &tv) < 0) {
    ui_badnews(-1, "f-o-b: Select returns error code, errno=%d", errno);
  }
  cnt = write(remote_fd, (char *)&output_buffer[0], output_buffercnt);
  if (cnt != output_buffercnt) {
    rerr("Error: tried to write %d bytes, wrote %d to remote on %s", 
                                    output_buffercnt, cnt, remote_tty_name);
  } else {
    bytes_transmitted += output_buffercnt;
  }
  init_output_buffer();
}

/* Reset the variables associated with the input buffer. */

static void init_input_buffer()
{
  input_buffer_cnt = 0;
  input_buffer_p = &input_buffer[0];
}

/* Fetech a character from the input buffer.  It is an error to
   call this when there are not characters in the input buffer.  */
  
u_char char_from_input_buffer()
{
  u_char c;

  if (input_buffer_cnt <= 0) {
    ui_badnews(-1, "Attempt to remove a character from empty buffer");
  }
  input_buffer_cnt--;
  bytes_received++;
  c = *input_buffer_p++;
  add_to_buffer(receive_buffer, c);
  if (checksumming) {
     add_to_checksum(c);
  }
  if (varvalue("tracereceive")) {
    if (direction != receiving) {
      ui_fprintf(stderr, "\nreceiving:\n");
      direction = receiving;
    }
    ui_fprintf(stderr, "%s ", comm_name(c, prev_char));
    prev_char = c;
  }
  return c;
}

#ifdef	SIGIO_WORKS	/* Doesn't work in SUN-OS   91.1.1 */

/* This is called when our process has the possibility of doing I/O.
   This serves to interrupt the pause() call below */

void sigio_handler()
{
  if (varvalue("traceremote")) {
    ui_fprintf(stderr, "<SIGIO>\n");
  }
}
#endif

/*
 * Returns a character from the remote device.
 */
u_char get_remote_char(timeout_action, timeout)
  timeout_action_t timeout_action;
  int timeout;
{
  int firsttime = true;

  if (input_buffer_cnt > 0) {
    return char_from_input_buffer();
  }
  init_input_buffer();
  flush_output_buffer();
  for (;;) {
    time_t start_time = time((time_t *)0);
    do {
      struct timeval tv;
      fd_set fdset;

#ifdef	SIGIO_WORKS	/* Doesn't work in SUN-OS   91.1.1 */
      signal(SIGIO, sigio_handler);
      pause();
#else
      /* We call select as an alternative to spin-waiting for characters.
         If select wakes up when it shouldn't, that's ok. */

      tv.tv_sec = timeout;
      tv.tv_usec = 0;
      FD_ZERO(&fdset);
      FD_SET(remote_fd, &fdset);
      if (select(FD_SETSIZE, &fdset, (int *)0, (int *)0, &tv) < 0) {
        ui_badnews(-1, "Select returns error code, errno=%d", errno);
      }
#endif

      input_buffer_cnt = read(remote_fd, input_buffer, BUFSIZ);
      if (input_buffer_cnt > 0) {
        if (!firsttime && timeout_action == ta_warning) {
          ui_fprintf(stderr, "\n");
        }
        return char_from_input_buffer();
      }
      spllo();
    } while (start_time + timeout > time((time_t *)0));
      
    switch (timeout_action) {
      case ta_none:
        break;

      case ta_warning:
        if (firsttime) {
          firsttime = false;
          ui_fprintf(stderr, "\nWaiting for target");
        } else {
          ui_fprintf(stderr, ".");
        }
        break;

      default:
        longjmp(timeout_action, 1);
     }
  }
}

/*
 * Disable interrupts (i.e., control-C).
 */
void splhi()
{
    (void)sigblock(1 << (SIGINT - 1));
}

/*
 * Enable interrupts (i.e., control-C).
 */
void spllo()
{
  signal(SIGINT, passthroughmode ? pass_siginthandler : request_quit);
  sigsetmask(sigblock(0) & ~(1 << (SIGINT - 1)));
}

/* Return a pointer to the string that names the tty poosrt that has
   the reset/abort hardware on it */

char *reset_tty_name()
{
  static char buf[200];
  char *s, *getenv();

  if (s = getenv("G88_CONTROL_PORT")) {
    return s;
  }
  strcpy(buf, remote_tty_name);
  buf[strlen(buf)-1]--;
  return buf;
}

static control_fd = -1;

/* Open the control port if it isn't already. */

static void open_control_port()
{
  if (control_fd == -1) {
    if ((control_fd = open(reset_tty_name(), O_RDWR|O_NDELAY)) < 0) {
      ui_badnews(-1, "cannot open %s, err code = %d", 
                                  reset_tty_name(), control_fd);
    }
  }
}

/* Close the control port if it is open */

void close_control_port()
{
  if (control_fd > 0) {
    if (close(control_fd) < 0) {
      ui_badnews(-1, "error in close_control_port");
    }
    control_fd = -1;
  }
}

/* Reset the target */
void send_reset_signal()
{
  struct termio t;
  int i,flags;

  open_control_port();
  ioctl(control_fd,I_POP,0);
  ioctl(control_fd,I_POP,0);

  ioctl(control_fd,TIOCMGET,&flags);
  i =  flags & ~TIOCM_DTR;			/* set DTR bit */
  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
  i = flags | TIOCM_DTR;	/* reset DTR bit */

  /* For some reason SUN-OS delays for 3 seconds with DTR active.  So
     there is no need to delay here. */

  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
}

/* Interrupt the target */
void send_interrupt_signal()
{
  struct termio t;
  int i,flags;
  
  open_control_port();
  ioctl(control_fd,I_POP,0);
  ioctl(control_fd,I_POP,0);

  ioctl(control_fd,TIOCMGET,&flags);
  i =  flags & ~TIOCM_RTS;
  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
  i = flags | TIOCM_RTS;	/* reset RTS bit */
  sleep(1);
  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
}

_initialize_remote()
{
  _initialize_simgdb();
  init_globals();
}
@


1.32
log
@Many changes:  Now have SUN-OS send start/stop characters to the target
to do flow control (nothing else worked, when SUN-OS gets an input 
overrun it freaks).  Much reformatting.  Now use asynchronous I/O with
target (but not SIGIO :-(, it doesn't work).  Renamed some functions.
Many tweaks.
@
text
@d5 1
a5 1
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.31 90/12/29 21:26:14 robertb Exp Locker: robertb $
d36 1
d46 2
d113 1
d119 5
a123 1
u_long mon_register_area_addr;	/* Target address of monitor's register area  */
d125 2
a126 1
u_long mon_version_addr;	/* Target address of version string           */
d280 1
d327 9
a335 10
    /*
     * After any error, the target calls restart() (see mon.c and monstart.s),
     * which reenters the monitor, so we should expect a reset exception
     * code to come up the hose.  This doesn't mean that the target really
     * took an exception.
     */
    if (!wait_for_exception(TR_RESET, ta_warning, 1)) {
        rerr("Target was unable to restart monitor after error");
    } else {
        rerr("");
d344 6
d462 1
d488 1
d490 6
d499 7
a505 3
          for (i = 0 ; i < cnt && i < SHOWCNT ; i++) {
            ui_fprintf(stderr, "%s ", comm_name(buf[i], prev_char));
            prev_char = buf[i];
d559 1
a559 1
    unsigned exception_code;
d564 1
d566 2
a567 1
        ui_fprintf(stderr, "\nTarget took ");
d607 46
d664 1
a664 1
  unsigned i;
d667 3
d689 1
d695 1
d697 1
d699 9
d745 1
a747 3
        } else {
          if (ui_fgets(buf, (int)length, stdin) == 0) {
            rerr("dbread: error doing ui_fgets, length=%d", length);
d749 18
a766 1
        actual_length = strlen(buf);
d768 3
a770 3
        if (actual_length > length) {
          ui_fprintf(stderr, "dbread: ui_fgets read too much\n");
          actual_length = length;
d772 3
a774 1
        splhi();
a783 1
        target_running = true;
d814 1
a814 1
        target_running = true;
d930 4
a933 2
/* Send the 0x82 code to the target in order to interrupt it.  The kludge
   board will see this code and pull 88k's interrupt line.  */
d1019 1
a1019 4
    if (varvalue("motomode")) {
      mon_dacc_address_addr = get_word();
      traceremote("mon_dacc_address_addr=0x%x\n", mon_dacc_address_addr);
    } else {
d1024 8
a1031 2
    mon_register_area_addr = get_word();
    traceremote("mon_register_area_addr=0x%x\n", mon_register_area_addr);
d1036 2
a1037 2
    mon_version_addr = get_word();
    traceremote("mon_version_addr=0x%x\n", mon_version_addr);
d1039 2
a1040 1
    mon_panic_code_addr = get_word();
d1042 1
a1042 7
    /*
     * This is a patch, devised by Rob.  The call return point used to be
     * location 8, but this is also the ROM's interrupt exception vector, so
     * ^C would mess things up.  Rob is pretty sure that this location is
     * not changed during a "call" statement.  /AJK
     */
    /* call_return_point = mon_panic_code_addr; */
d1044 2
a1045 1
    traceremote("mon_panic_code_addr=0x%x\n", mon_panic_code_addr);
d1052 1
a1052 4
    if ((mon_register_area_addr & 7) != 0) {
        ui_fprintf(stderr, "WARNING: monitor's register area is misaligned.\n");
    }
    addr = mon_version_addr;
d1058 6
d1065 1
a1065 1
    ui_fprintf(stdout, buf);
d1247 1
a1247 1
    ui_fprintf(stdout, "Target alive and was already in debug monitor\n");
d1658 1
a1668 1
      spllo();
a1690 1
        target_running = false;
d1693 2
a1694 1
    } while (start_time + timeout >= time((time_t *)0));
@


1.31
log
@Many tweaks.  send_interrupt_signal() wasn't reseting its
signal, this is fixed.  open_tty_line() is now open_debug_port(), etc.
@
text
@d5 1
a5 1
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.30 90/12/10 21:19:59 robertb Exp Locker: robertb $
d20 3
d65 2
a66 3
#define OUT_BUFFSIZ 999
static u_long out_buffcnt;
static unsigned char out_buff[OUT_BUFFSIZ];
d68 1
d70 6
a76 1
jmp_buf timeout_env;
a101 1
void open_debug_port();
d135 2
a142 1
static void (*old_signalrm)();
a224 1
  init_globals();
d354 2
a355 1
  init_out_buff();
d359 1
a359 1
#define BUFFERSIZE	(100)
d377 1
a377 1
    setvar("buffersize", buffersize = 100);
a468 4
    if (fcntl(remote_fd, F_SETFL, FNDELAY) < 0) {
        rerr("flush_tty_line: Error doing fcntl to set flags on %s", 
                                                     remote_tty_name);
    }
d470 1
a470 1
    init_out_buff();
d486 1
a486 1
                flush_out_buff();
a491 1
    }
d495 1
a495 4
    if (fcntl(remote_fd, F_SETFL, 0) < 0) {
        rerr("flush_tty_line: Error doing fcntl to set flags on %s", 
                                                     remote_tty_name);
    }
d506 1
a506 1
    enum timeout_action timeout_action;
d582 4
a585 4
static boolean wait_for_exception(expected_exception, timeout_action, timeout)
    unsigned expected_exception;
    enum timeout_action timeout_action;
    int     timeout;
d587 5
a591 5
    u_char c;
    char *buf;
    unsigned i;
    u_long actual_length;	/* # of characters read to satisfy db_read */
    u_long length;		/* Length of target's db_read buffer       */
d593 8
a600 10
    while (1) {
        init_checksum();
        while ((c = get_remote_char(timeout_action, timeout)) != 
                                                        COMMAND_PREFIX1) {
            if (!ignore_errors) {
                ui_fprintf(stderr, 
                       "wait_for_exception: looking for P1, got instead: %s\n", 
                                                               comm_name(c, 0));
                if (c == '\r' && varvalue("motomode")) {
                  ui_fprintf(stderr, 
d602 20
a621 7
                    resetting_remote = false;
                    do_pass_command("", true, true);
                    flush_tty_line();
                    rerr("");
                } 
            }
            init_checksum();
d623 4
d628 3
a630 3
        c = get_remote_char(timeout_action, timeout);
        switch (c) {
            unsigned exception_code;
d632 14
a645 16
            case C_EXCEPTION:
                invalidate_mem_cache();
                exception_code = get_word();
                if (exception_code == expected_exception) {
                    traceremote("Expected and received the exception: %s\n",
                                 exception_name(exception_code));
                    return true;
                }
                switch (expected_exception) {
                    case TR_TRC:
                        rerr("Target got %s while trying to single step.",
                                exception_name(exception_code));

                    case TR_BPT:
                        rerr("Target got %s.", exception_name(exception_code));
                        break;
d647 33
a679 14
                    default:
                        if (exception_code < 512) {
                            rerr("While waiting for %s, target got %s",
                                       exception_name(expected_exception),
                                       exception_name(exception_code));
                        } else {
                            rerr(
   "While waiting for %s, target got an exception, but the code was garbled.",
                                          exception_name(expected_exception));
                        }
                        break;
                }
                return false;
                break;
d681 29
a709 55
            case C_DBREAD:
                length = get_word();
                verify_checksum();
                if (length > 1024*1024) {
                    rerr("Received outrageous length, %d on dbread.", length);
                    break;
                }
                traceremote("reading %d character string for remote.\n", length);
                if (!(buf = malloc((unsigned)length))) {
                    rerr("dbread: unable to malloc a %d bytes", length);
                } else {
                    if (ui_fgets(buf, (int)length, stdin) == 0) {
                      rerr("dbread: error doing ui_fgets, length=%d", length);
                    }
                    actual_length = strlen(buf);
                }
                if (actual_length > length) {
                  ui_fprintf(stderr, "dbread: ui_fgets read too much\n");
                  actual_length = length;
                }
                splhi();
                init_checksum();
                send_command(C_DATASTART);
                send_word(actual_length);
                for (i = 0 ; i < actual_length ; i++) {
                    send_byte((u_char)buf[i]);
                }
                free(buf);
                send_command(C_DATAEND);
                send_checksum();
                target_running = true;
                spllo();
                break;

            case C_DBWRITE:
                length = get_word();
                if (length > 1024*1024) {
                    rerr("Received outrageous length, %d on dbwrite.", length);
                    break;
                }
                traceremote("receiving %d character string from remote.\n", 
                                       length);
                switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
                    case C_DATASTART:
                        for (i = 0 ; i < length ; i++) {
                            ui_putchar(get_byte());
                            ui_fflush(stdout);
                        }
                        if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
                            ui_fprintf(stderr, 
                                       "\nDidn't find C_DATAEND in DBWRITE\n");
                            break;
                        }
                        verify_checksum();
                        break;
d711 7
a717 2
                    case C_DATAERROR:
                        dacc_rerr("fetching characters for DBWWRITE");
d719 3
a721 18
                    default:
                        rerr("Didn't find C_DATASTART in DBWRITE");
                    break;
                }
                target_running = true;
                break;

            case C_CHECKSUMERR:
            case C_COMMERR:
            case C_BADCOMMAND:
            case C_COMPRESSERR:
            case C_EXPECTEDTOKEN:
                handle_target_rerr(c);
                return false;

            default:
                if (c == '\r' && varvalue("motomode")) {
                  ui_fprintf(stderr, 
d723 7
a729 10
                  resetting_remote = false;
                  do_pass_command("", true, true);
                  flush_tty_line();
                  rerr("");
                } 
                if (!ignore_errors) {
                    rerr("wait_for_exception: got %s", 
                                                 comm_name(c, COMMAND_PREFIX1));
                }
                break;
d731 1
d733 1
d743 1
d745 2
d812 1
a812 1
      if (wait_for_exception(TR_RESET, ta_longjmp, timeout)) {
d829 2
a830 1
    static boolean trying_to_sync = false;
d832 12
a843 13
    if (!trying_to_sync && !target_running) {
        trying_to_sync = true;
        if (setjmp(timeout_env) == 0) {
            traceremote("sending C_SYNC to target...\n");
            flush_tty_line();
            send_command(C_SYNC);
            flush_out_buff();
            if (wait_for_token(C_SYNC, C_NONE, ta_longjmp, 1) == C_SYNC) {
                trying_to_sync = false;
                stop_cause |= (1 << SIGINT);
                return;
            }
        }
d845 1
d847 24
a870 5
    trying_to_sync = false;
    nmiing_remote = true;
    if (setjmp(timeout_env)) {
        nmiing_remote = false;
        rerr("Timeout trying to interrupt target.");
d872 2
a873 23
        traceremote("Interrupting target ...\n");
        flush_tty_line();
        send_interrupt_signal();
        fflush(stdout);
        ignore_errors = true;
        invalidate_mem_cache();
        if (wait_for_exception(TR_INT, ta_longjmp, 2 /* seconds */)) {
            stop_cause |= (1 << SIGINT);
            traceremote("Target received debug interrupt.\n");
            check_for_delay_slot_after_interrupt();

            if ((remote_read_register(DMT0_REGNUM) & 1)) {
                    ui_fprintf(stdout, 
                          "Warning: DMU fault: DMT0=0x%x DMD0=0x%x DMA0=0x%x\n",
                      remote_read_register(DMT0_REGNUM), 
		      remote_read_register(DMD0_REGNUM),
		      remote_read_register(DMA0_REGNUM));
            }
        } else {
            nmiing_remote = false;
            rerr("Unable to interrupt target\n");
        }
        ignore_errors = false;
d875 4
a878 2
    nmiing_remote = false;
    fflush(stdout);
a958 1

a959 11
 * This is called if we time out waiting for the reset exception packet.
 */
static signalrm()
{
    static void reset_timer();

    reset_timer();
    longjmp(timeout_env, 1);
}

/*
a1012 1
  int baud_rate_flags;
d1032 5
a1036 1
  t.c_cflag = CS8 | CREAD | (t.c_cflag & CBAUD);
d1039 2
a1040 1
  t.c_cc[VMIN] = 1;	/* Make sure this is 0 or 1, doesn't matter which */
d1042 1
a1042 2
  t.c_iflag = IGNBRK | IGNPAR;

d1044 4
d1053 4
a1056 2
  /* Make IO with the remote device synchronous.  */
  if (fcntl(remote_fd, F_SETFL, 0) < 0) {
d1060 9
d1077 1
a1077 1
    struct internalvar *var;
d1079 5
a1083 5
    var = lookup_internalvar(varname);
    if (TYPE_CODE(VALUE_TYPE(var->value)) != TYPE_CODE_INT) {
        return 0;
    }
    return value_as_long(var->value);
d1094 2
a1095 2
    struct internalvar *var = lookup_internalvar(varname);
    set_internalvar(var, value_from_long(builtin_type_int, newvalue));
d1106 9
a1123 12
  /* Make sure that the target is not in FNDELAY mode.  We might have
     been in that mode when the user interrupted it */

  if (fcntl(remote_fd, F_SETFL, 0) < 0) {
    rerr("flush_tty_line: Error doing fcntl to set flags on %s", 
                                                     remote_tty_name);
  }
  if (resetting_remote || nmiing_remote) {
    resetting_remote = false;
    nmiing_remote = false;
    return_to_top_level();
  }
d1155 9
a1163 9
    static char str[100];
    static char *comm_names[] = 
           { "C_DOWNLOAD", "C_UPLOAD", "C_CHECKSUM", "C_END", "C_GO",
             "C_DATASTART", "C_CHECKSUMERR", "C_ACK", "C_DATAEND", "C_FILL",
             "C_RETPTRS", "C_EXCEPTION", "C_DBWRITE", "C_DBREAD", 
             "C_SYNC", "C_DATAERROR", "C_UPLOADNOINIT", "C_CHECKSUMNOINIT",
             "C_SEARCH", "C_COPYMEM", "C_UPLOADUSER", "C_UPLOADNOINITUSER",
             "C_DOWNLOADUSER", "C_EXPECTEDTOKEN", "C_COMMERR", 
             "C_COMPPRESSERR", "C_BADCOMMAND", "C_188SYSCALL" }; 
d1165 6
a1170 6
    if (passthroughmode) {
      switch (c) {
        case C_RESET:          return "C_RESET"; break;
        case C_NMI:            return "C_NMI";   break;
      }
      sprintf(str, "%02X", c);
d1172 1
a1172 1
    }
d1174 5
a1178 5
    switch (c) {
        case C_RESET:          return "C_RESET"; break;
        case C_NMI:            return "C_NMI";   break;
        case COMMAND_PREFIX1:  return "P1";      break;
        case COMMAND_PREFIX2:  return "P2";      break;
d1180 14
a1193 14
        case C_DOWNLOAD:  case C_UPLOAD:     case C_CHECKSUM:  case C_END:
        case C_GO:        case C_DATASTART:  case C_CHECKSUMERR:
        case C_ACK:
        case C_DATAEND:   case C_FILL:       case C_RETPTRS:   case C_EXCEPTION:
        case C_DBWRITE:   case C_DBREAD:     case C_SYNC:      
        case C_DATAERROR: case C_UPLOADNOINIT: case C_CHECKSUMNOINIT:
        case C_SEARCH:    case C_COPYMEM:    case C_UPLOADUSER:
        case C_UPLOADNOINITUSER:             case C_DOWNLOADUSER:
        case C_EXPECTEDTOKEN:                case C_COMPRESSERR:
        case C_COMMERR:   case C_BADCOMMAND: case C_188SYSCALL:
            if (prev_char == COMMAND_PREFIX1) {
                return comm_names[c - C_DOWNLOAD];
            }
            break;
d1195 3
a1197 1
    }
d1199 2
a1200 2
    sprintf(str, "%02X", c);
    return str;
d1210 5
a1214 5
    return token == C_CHECKSUMERR   ||
           token == C_EXPECTEDTOKEN ||
           token == C_COMPRESSERR   ||
           token == C_COMMERR       ||
           token == C_BADCOMMAND;
d1221 1
a1221 1
static void init_out_buff()
d1223 2
a1224 2
    out_buffcnt = 0;
    out_bp = &out_buff[0];
d1232 1
a1232 1
	u_char command;
d1234 2
a1235 2
	put_remote_char(COMMAND_PREFIX1);
	put_remote_char(command);
d1243 2
a1244 2
	checksum = 0;
	checksumming = true;
a1430 14
 * This resets the real interval timer and the timer signal hander.
 */
static void reset_timer()
{
    new_timerval.it_interval.tv_sec = 0;
    new_timerval.it_interval.tv_usec = 0;
    new_timerval.it_value = new_timerval.it_interval;
    if (setitimer(ITIMER_REAL, &new_timerval, &old_timerval) != 0) {
        rerr("reset_timer: Error doing setitimer");
    }
    signal(SIGALRM, SIG_IGN);
}

/*
d1437 1
a1437 1
    static u_char prev_char;
d1439 9
a1447 9
    if (out_bp == nil) {
        rerr("put_remote_char: output buffer not initialized\n");
    }
    if (checksumming) {
        add_to_checksum(c);
    }
    *out_bp++ = c;
    out_buffcnt++;
    add_to_buffer(transmit_buffer, c);
d1449 7
a1455 2
    if (out_buffcnt == OUT_BUFFSIZ) {
        flush_out_buff();
d1457 3
a1459 8
    if (varvalue("tracetransmit")) {
        if (direction != transmitting) {
            ui_fprintf(stderr, "\ntransmitting:\n");
            direction = transmitting;
        }
        ui_fprintf(stderr, "%s ", comm_name(c, prev_char));
        prev_char = c;
    }
d1465 1
a1465 1
void flush_out_buff()
d1467 3
a1469 3
    if (out_buffcnt == 0) {
        return;
    }
d1471 49
a1519 5
    if (write(remote_fd, (char *)&out_buff[0], out_buffcnt) != out_buffcnt) {
            rerr("flush_out_buff: Error writing %d bytes to remote on %s", 
                                    out_buffcnt, remote_tty_name);
    } else {
        bytes_transmitted += out_buffcnt;
d1521 4
a1524 1
    init_out_buff();
d1527 13
d1544 2
a1545 2
    enum timeout_action timeout_action;
    int timeout;
d1547 12
a1558 5
    u_char buf[1];
    struct timeval tv;
    int rmask = 1 << remote_fd;
    static u_char prev_char;
    boolean firsttime;
d1560 6
a1565 10
    flush_out_buff();
    tv.tv_sec = timeout;
    tv.tv_usec = 0;
    firsttime = true;
    while (select(sizeof(unsigned) * 8, &rmask, (int *)0, (int *)0, &tv) != 1) {
        /* If we time out, make sure that the user can interrupt us. */
        spllo();
        rmask = 1 << remote_fd;
	switch (timeout_action) {
		case ta_none: break;
d1567 8
a1574 8
		case ta_warning:
                    if (firsttime) {
                        firsttime = false;
                        ui_fprintf(stderr, "\nWaiting for target");
                    } else {
                        ui_fprintf(stderr, ".");
                    }
                    break;
d1576 4
a1579 4
		case ta_longjmp:        longjmp(timeout_env, 1);

                default:
                  rerr("Case error in get_remote_char()");
a1580 9
    }

    if (!firsttime && timeout_action == ta_warning) {
        ui_fprintf(stderr, "\n");
    }

    if (read(remote_fd, (char *)&buf[0], 1) != 1) {
        rerr("get_remote_char gets read error, errno=%d.", errno);
    } else {
d1582 7
a1588 3
        bytes_received++;
        add_to_buffer(receive_buffer, buf[0]);
    }
d1590 6
a1595 7
    if (checksumming) {
        add_to_checksum(buf[0]);
    }
    if (varvalue("tracereceive")) {
        if (direction != receiving) {
            ui_fprintf(stderr, "\nreceiving:\n");
            direction = receiving;
d1597 6
a1602 4
        ui_fprintf(stderr, "%s ", comm_name(buf[0], prev_char));
        prev_char = buf[0];
    }
    return buf[0];
a1637 27
#include <stropts.h>

#include <sys/types.h>
#include <sys/timeb.h>

/* Delay for the specified number of millisceconds by spin waiting
   on the system clock. */

void delay(milliseconds)
{
  struct timeb timeb;
  unsigned short start;

  if (milliseconds > 1000) {
    /* Efficiency move in case we are asked to wait longer than a second */
    sleep(milliseconds/1000);
    milliseconds %= 1000;
  }

  ftime(&timeb);
  start = timeb.millitm;
 
  while (timeb.millitm < start + milliseconds) {
    ftime(&timeb);
  }
}

d1679 5
a1683 2
  i =flags | TIOCM_DTR;	/* reset DTR bit */
  delay(50);
d1705 1
a1705 1
  delay(50);
d1714 1
@


1.30
log
@Added support for 9600 and 19200 baud in motomode.
Added use of G88_CONTROL_PORT to change default port for
sending reset and abort signal.
@
text
@d5 1
a5 1
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.29 90/11/27 01:02:47 robertb Exp Locker: robertb $
d92 4
a95 1
static void open_remote_tty();
d125 2
d155 45
d213 1
d219 1
a219 1
  open_remote_tty();
d237 12
d256 3
a258 7
    if (remote_fd > 0) {
        if (close(remote_fd) < 0) {
            ui_fprintf(stderr, "close_remote_tty: error closing %s.\n",
                                     remote_tty_name);
        }
        remote_fd = -1;
    }
d454 2
a455 1
#define FBUFSIZE (10)
d458 1
a458 1
    int  cnt, i;
d468 3
a470 1
        if (overall_cnt < FBUFSIZE || varvalue("traceremote")) {
d472 1
a472 1
          for (i = 0 ; i < cnt ; i++) {
a477 1
        overall_cnt += cnt;
d480 1
a480 1
            if (tolower(getchar()) == 'y') {
d489 3
d514 8
d558 8
d602 2
a603 1
                    ui_fprintf(stderr, "Entering pass-through mode\n");
d606 2
d724 8
d1021 1
a1021 1
static void open_remote_tty()
d1033 1
a1033 3
    if (close(remote_fd) != 0) {
      ui_fprintf(stderr, "\nUnable to close tty line\n");
    }
d1042 1
a1042 1
    rerr("open_remote_tty: Error in doing TCGETA ioctl");
d1055 1
a1055 1
    rerr("open_remote_tty: Error in doing TCSETA ioctl");
d1061 1
a1061 1
    rerr("open_remote_tty: Error doing fcntl to set flags on %s", 
d1110 7
d1585 1
d1591 51
d1646 1
a1646 1
  int fd,i,flags;
d1648 3
a1650 5
  if ((fd = open(reset_tty_name(), O_RDWR|O_NDELAY)) < 0) {
    ui_badnews(-1, "cannot open %s, err code = %d", reset_tty_name(), fd);
  }
  ioctl(fd,I_POP,0);
  ioctl(fd,I_POP,0);
d1652 1
a1652 1
  ioctl(fd,TIOCMGET,&flags);
d1654 2
a1655 2
  if(ioctl(fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET\n");
a1656 3
  if(ioctl(fd,TIOCMGET,&flags) < 0) {
    ui_badnews(-1, "Error performing TIOCMGET\n");
  }
d1658 3
a1660 3
  sleep(1);	/* hold it for a sec */
  if(ioctl(fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET\n");
a1661 4
  if(ioctl(fd,TIOCMGET,&flags) < 0) {
    ui_badnews(-1, "Error performing TIOCMGET\n");
  }
  (void)close(fd);
d1668 1
a1668 1
  int fd,i,flags;
d1670 3
a1672 5
  if ((fd = open(reset_tty_name(), O_RDWR|O_NDELAY)) < 0) {
    ui_badnews(-1, "cannot open %s, err code = %d", reset_tty_name(), fd);
  }
  ioctl(fd,I_POP,0);
  ioctl(fd,I_POP,0);
d1674 1
a1674 1
  ioctl(fd,TIOCMGET,&flags);
d1676 2
a1677 2
  if(ioctl(fd,TIOCMSET,&i) < 0) {
  	ui_badnews(-1, "Error performing TIOCMSET");
d1679 4
a1682 2
  if(ioctl(fd,TIOCMGET,&flags) < 0) {
  	ui_badnews(-1, "Error performing TIOCMGET");
a1683 3
  i = flags | TIOCM_RTS;	/* reset RTS bit */
  sleep(1);
  close(fd);
@


1.29
log
@Changed to using Horizon's reset/abort hardware.
Now support 9600, 19200, in addition to 38400 baud in motomode.
Now always set $motomode=1.
Fixed a segv in reset_remote() that had to do with timing out
while waiting for the reset exception.
Changed get_monitor_addresses slightly.
@
text
@d5 1
a5 1
   $Header: /home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.28 90/11/15 19:32:20 robertb Exp Locker: robertb $
d684 1
a684 2
      char init_string[1000];
      char buf[1000];
d687 1
a687 1
          strcpy(init_string, "*r\r*e\r*W188-Bug>\r*c\r");
d691 2
a692 1
          strcpy(init_string, "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b 19200\r*W188-Bug>\r*c\r");
d696 2
a697 1
          strcpy(init_string, "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b 19200\r*W188-Bug>\rmm fff82013;nb\r*p\r40\r*b 38400\r.\r*W188-Bug>\r*c\r");
d701 2
a702 1
          ui_badnews(-1, "$baudrate only supported for values of 9600, 19200, and 38400 in motomode");
d704 1
a704 2
      strcpy(buf, varvalue("traceremote") ? "" : "*t\r");
      do_pass_command(strcat(buf, init_string), 
d1477 3
d1483 1
d1485 3
a1488 1
  buf[strlen(buf)-1]--;
d1500 2
a1501 2
  if ((fd = open("/dev/ttya", O_RDWR|O_NDELAY)) < 0) {
    ui_badnews(-1, "cannot open /dev/ttya,err code = %d",fd);
d1531 2
a1532 2
  if ((fd = open("/dev/ttya", O_RDWR|O_NDELAY)) < 0) {
     ui_badnews(-1, "cannot open /dev/ttya,err code = %d",fd);
@


1.28
log
@Reapplied fix for no-printing-of-context-on-control-C-while-simulator
running bug.
@
text
@d5 1
a5 1
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.27 90/09/29 20:59:58 robertb Exp Locker: robertb $
d36 1
a36 1
#define	DEFAULT_RESET_TIMEOUT	(60)	/* Seconds to wait for target to reset*/
a127 1
static boolean newroms;		/* True if ROMs are 1.2 or newer              */
d159 1
d420 1
a420 2
                put_remote_char(C_RESET);
                put_remote_char(0);
d684 1
a684 1
      char *init_string = "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b 19200\r*W188-Bug>\rmm fff82013;nb\r*p\r40\r*b 38400\r.\r*W188-Bug>\r*c\r";
d686 16
d707 1
a707 2
      put_remote_char(C_RESET);
      put_remote_char(0); /* Clear the kludge board's UART read register. */
d710 11
a720 3
    if (wait_for_exception(TR_RESET, ta_longjmp, timeout)) {
      traceremote("Target received reset signal.\n");
      stop_cause = 0;
d722 7
a728 2
      resetting_remote = false;
      rerr("Unable to reset remote.");
d764 1
a764 2
        put_remote_char(C_NMI);
        flush_out_buff();
a801 3
    if (mon_register_area_addr != 0) {
        return;
    }
a864 3
    if (periodp = strchr(buf, '.')) {
        newroms = atoi(periodp + 1) > 1;
    }
d1474 67
@


1.27
log
@Fixed up handling of case when target has not been attached
sucessfully.  This mirrors patchs I made to the Tektronix code
@
text
@d5 1
a5 1
   $Header: /tmp_mnt/u2/cs568/g88/RCS/remote.c,v 1.26 90/08/19 21:19:54 robertb Exp Locker: robertb $
d996 1
@


1.26
log
@deleted redundant #include
@
text
@d5 1
a5 1
   $Header: /home/vlsi/u2/cs568/g88/RCS/remote.c,v 1.25 90/05/11 11:44:07 robertb Exp Locker: robertb $
a176 1
  remote_debugging = 1;
d183 1
d674 7
a680 1
      rerr("Timeout trying to reset target.");
a698 1
      remote_debugging = true;
a775 3
  if (!remote_debugging) {
    rerr("You must attach the target before using this command.\n");
  }
@


1.25
log
@Changed ioctl(remote_fd, TCSETA, ..) to ioctl(remote_fd, TCSETAW..)
so that characters in the kernel's output queue won't be munged
by data rate shifts.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.24 90/04/29 19:43:41 robertb Exp $
d8 1
a8 1
This file is part of GDB.
a9 4
GDB is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.
a10 9
GDB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GDB; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

a17 1
#include <sys/ioctl.h>
@


1.24
log
@Added support for the 88000 simulator.  There is a global 'simulator'
now and when it is true, many of the functions in the cross-debugging
part of gdb will call simulator routines instead of trying to interact
with a target via a tty line.  Most of gdb outside of the cross-debugging
part no nothing about the simulator and behave the same way with the
simulator as they do when cross-debugging.  When 'simulator' is true,
so is 'remote_debugging'.
Gdb can be built with or without the simulator.  When built without,
a stub file, sim.c, satisfies the references of simulator routines.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.23 90/04/27 18:33:51 robertb Exp $
d906 1
a906 2
    rerr(
             "setbaud: Error in doing TCGETA ioctl to %s", remote_tty_name);
d911 2
a912 3
  if (ioctl(remote_fd, TCSETA, &t) < 0) {
        rerr(
             "setbaud: Error in doing TCSETA ioctl to %s", remote_tty_name);
@


1.23
log
@Split into several files: remcmd.c, remrun.c, remmem.c.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.22 90/04/25 10:19:07 robertb Exp $
a30 2
#include <setjmp.h>
#include <sys/types.h>
d57 1
d281 1
a281 1
static void init_globals()
d1008 4
d1467 5
@


1.22
log
@Removed code for motomode and put it in a new file, 'motomode.c'
Removed decls needed by both remote.c and motomode.c and put
them in a file 'remote.h'.
Made 'regs' command work both when debugging processes and whe
cross-debugging.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.21 90/04/23 10:21:48 robertb Exp $
   $Locker:  $
a24 10
#include "defs.h"
#include "param.h"
#include "frame.h"
#include "inferior.h"
#include "wait.h"
#include "expression.h"
#include "symtab.h"
#include "ui.h"
#include "value.h"

d37 10
a46 3
#include "fields88.h"
#include "decode.h"
#include "format.h"
a49 9

#define badcaseval(v)  {ui_fprintf(stderr, "In %s, line %s, bad case value %d\n",\
                                __FILE__, __LINE__, v);}

#define boolean char
#define true 1
#define false 0
#define nil 0

a51 7
#define CAUGHT_EXCEPTION 1
#define CAUGHT_BREAKPOINT 2

#define M_USER 0
#define M_SUPERVISOR 1
#define M_CURMODE 2

d56 1
d58 1
a58 1
int stop_cause;
a59 4
#define transmitting    1
#define receiving       2
#define PAGESIZE (4096)

d75 2
a76 4

#define add_to_checksum(b) { register unsigned msb; \
  msb = (checksum += (b)) >> 31 ; checksum <<= 1; checksum |= msb; }

d81 3
a83 3
static jmp_buf controlc_env;
static u_long delayed_ip;
static u_long *delayed_p;
d85 3
d89 2
a90 1
static struct instr_info *instr_info;
d93 2
a94 1
char objname[200];              /* Filename of executable to download */
d96 1
a96 1
static u_long checksum;
d98 2
d101 2
d105 1
a105 1
static unsigned exception_code;
a106 8
#define CACHELINESIZE       (128)
#define CACHELINEMASK       (CACHELINESIZE - 1)

/*
 * Forward declarations of functions in this file.
 */
u_long remote_read_register();
void remote_write_register();
d108 1
a108 14
static void flush_tty_line();
static u_long forced_read_remote();
static boolean wait_for_remote();
static boolean dl_remote();
static void check_for_delay_slot_after_interrupt();
void decode_instr_before_stepping();
static u_char read_remote_b();
static u_short read_remote_h();
static u_long read_remote_w();
static void write_remote_b();
static void write_remote_h();
static void write_remote_w();
static void initglobals();
static void print_comm_statistics();
d110 1
a110 11
static boolean remote_v_to_p();
static boolean wait_for_exception();
static void reset_remote();
static boolean interrupt_remote();
static boolean dread_remote();
static void dwrite_remote();
u_long varvalue();
static char *commname();
static void ss_remote();
static int go_remote();
static char *regname();
a112 17
static boolean init_remote();
static void download();
static void download_command();
static void checkdl_command();
static void bzero_command();
static void bcopy_command();
static void flush_command();
static void init_command();
static void regs_command();
static void readbyte_command();
static void readhalf_command();
static void readword_command();
static void searchword_command();
static void writebyte_command();
static void writehalf_command();
static void writeword_command();
static void get_monitor_addresses();
a113 4
static u_long checksum_of();
static boolean ignore_errors; /* True while we are trying to interrupt target*/
static boolean in_rom();
static boolean in_sram();
d116 1
a116 6
static CORE_ADDR next_address;
static u_long mon_compress_table_addr;
static u_long mon_register_area_addr;
static u_long mon_single_step_trap_addr;
static u_long mon_version_addr;
static u_long mon_panic_code_addr;
d118 6
a123 11
static u_long bytes_transmitted;
static u_long total_bytes_transmitted;
static u_long bytes_received;
static u_long total_bytes_received;
static double start_time;
static double end_time;
static u_long total_bytes_downloaded;
boolean downloaded;
boolean warned;
CORE_ADDR bss_start, entry_point;
u_long bss_size;
d125 8
a132 1
char remote_tty_name[200];
d134 3
a136 2
int remote_fd = -1;	/* Force ioctl errors if not initialized */
int current_baud;
a137 2
static initializing = false;

d142 2
a143 3
static boolean target_running = false;
static int direction = 0;
static boolean newroms;       /* True if ROMs are 1.2 or newer */
a144 12
static void remote_zeromem(/* addr, length */);
static void remote_copymem(/*src_addr, dst_addr, length*/);
static u_long remote_searchmem();

struct mem_cache {
    int    usmode;
    u_long addr;
    struct mem_cache *next;
    u_char values[CACHELINESIZE]; } *mem_cache = nil;

boolean use_remote;

a150 49
/*
 * This is indexed by gdb register numbers and elements are word
 * offsets into the monitor ROM's register area.
 */
char regmap[] = {0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
                10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		30, 31,
		38,	/* best guess for $pc */
		33,	/* pid */
		35,	/* psr (really this is the epsr) */
		35,	/* epsr */
		36,	/* ssbr */
		37,	/* sxip */
		38,	/* snip */
		39,	/* sfip */
		40,	/* vbr */
		41,	/* dmt0 */
		42,	/* dmd0 */
		43,	/* dma0 */
		44,	/* dmt1 */
		45,	/* dmd1 */
		46,	/* dma1 */
		47,	/* dmt2 */
		48,	/* dmd2 */
		49,	/* dma2 */
		50,	/* sr0 */
		51,	/* sr1 */
		52,	/* sr2 */
		53,	/* sr3 */
		54,	/* fpecr */
		55,	/* fphs1 */
		56,	/* fpls1 */
		57,	/* fphs2 */
		58,	/* fpls2 */
		59,	/* fppt */
		60,	/* fprh */
		61,	/* fprl */
		62,	/* fpit */
		63,	/* fpsr */
		64,	/* fpcr */
		65,	/* ceimr */
		-1,	/* comefrom */
		-1,	/* membrk */
		-1,	/* stackbase */
		-1,	/* ramsize */
		-1,	/* synthfp */
	};

d176 1
a176 1
    error("Already attached to %s", remote_tty_name);
d181 1
a181 1
  initglobals();
a186 4
    /* This is a kludge.  We want to make sure that the delayed_p
       flag stays in sync with the target.  */
    delayed_p = (u_long *)0; 

d188 1
a188 3
    if (!interrupt_remote()) {
      error("Unable to interrupt target while trying to attach");
    }
a191 1
  initializing = true;
a193 1
  stop_cause = SIGTRAP;   /* What ptrace reports after attaching a process */
d195 2
a196 2
  get_monitor_addresses();
}
a197 37
int
remote_resume (step, signal_number)
     int step, signal_number;
{
  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    if (!downloaded && !warned) {
      warned = true;
      error("Target hasn't been downloaded yet");
    }
    if (step) {
        ss_remote();
    } else {
        go_remote();
    }
}

/* Wait until the remote machine stops, then return,
   storing status in STATUS just as `wait' would.  */

int
remote_wait (status)
     WAITTYPE *status;
{
  WSETEXIT ((*status), 0);
  initializing = false;
  WSETSTOP ((*status), stop_cause);
}

/* Read the remote registers into the block REGS.  */

void
remote_fetch_registers (regs)
     char *regs;
{
  int i;
a198 4

  for (i = 0; i < REGISTER_BYTES; i++) {
    regs[i] = read_remote_b(mon_register_area_addr + i, M_SUPERVISOR);
  }
a200 51
/* Store the remote registers from the contents of the block REGS.  */

void
remote_store_registers (regs)
     char *regs;
{
    int i;
    get_monitor_addresses();

    for (i = 0; i < REGISTER_BYTES; i++) {
        write_remote_b(mon_register_area_addr + i, regs[i], M_SUPERVISOR);
    }
}

/* Read a word from remote address ADDR and return it.
   This goes through the data cache.  */

int
remote_fetch_word (addr, usmode)
     CORE_ADDR addr;
     int usmode;
{
    return read_remote_w(addr, usmode);
}

/* Write a word WORD into remote address ADDR.
   This goes through the data cache.  */

void
remote_store_word (addr, word)
     CORE_ADDR addr;
     int word;
{
    write_remote_w (addr, word, M_SUPERVISOR);
}

char *exception_names[] = {
 "reset", "interrupt", "code access", "data access", "misaligned access",
 "unimplemented opcode", "privilege violation", "bounds check",
 "illegal integer divide", "integer overflow", "error"};

static void printsig(stream, code)
    u_short code;
{
    if (code < (sizeof exception_names) / sizeof (char *)) {
      ui_fprintf(stream, "%s exception", exception_names[code]);
    } else {
      ui_fprintf(stream, "exception number %d", code);
    }
}

d217 10
d230 1
a230 1
static void handle_target_error(c)
d242 1
a242 1
                           commname(get_byte(), COMMAND_PREFIX1));
d258 2
a259 2
                           commname(get_byte(), COMMAND_PREFIX1), 
                           commname(get_byte(), COMMAND_PREFIX1));
d263 1
a263 1
            badcaseval(c);
d273 1
a273 1
        error("Target was unable to restart monitor after error");
d275 1
a275 1
        error("");
a278 1

d282 1
a282 1
static void initglobals()
a285 1
  warned = false;
d304 1
d307 1
a307 9
/*
 * Allows the user to explicitly zero a block of memory.
 */
static void bzero_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    u_long length;
    char *space_index;
d309 1
a309 3
    if (*exp == '\0') {
      error("This command can not be repeated with a newline");
    }
d311 3
a313 7
    space_index = (char *) index (exp, ' ');
    if (space_index == (char *)0) {
      error("Usage: bzero <address> <length>");
    }
    *space_index = '\0';
    next_address = parse_and_eval_address (exp);
    length = parse_and_eval_address (space_index + 1);
d315 2
a316 3
   /* Cause expression not to be there any more
      if this command is repeated with Newline.
      But don't clobber a user-defined command's definition.  */
d318 8
a325 4
    if (from_tty) {
      *exp = '\0';
    }
    remote_zeromem(next_address, length);
d327 7
a333 1
}
d335 7
a341 10
/*
 * Allows the user to explicitly copy a block of memory.
 */
static void bcopy_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    u_long length, source_address, destination_address;
    char *first_space_index;
    char *second_space_index;
d343 6
a348 2
    if (*exp == '\0') {
      error("This command can not be repeated with a newline");
d350 8
d359 2
a360 6
    first_space_index = (char *) index (exp, ' ');
    if (first_space_index == (char *)0) {
      error("Usage: bcopy <source-address> <destination-address> <length>");
    }
    *first_space_index = '\0';
    source_address = parse_and_eval_address (exp);
d362 5
a366 17
    second_space_index = (char *) index (first_space_index + 1, ' ');
    if (second_space_index == (char *)0) {
      error("Usage: bcopy <source-address> <destination-address> <length>");
    }
    *second_space_index = '\0';
    destination_address = parse_and_eval_address (first_space_index + 1);

    length = parse_and_eval_address (second_space_index + 1);

   /* Cause expression not to be there any more
      if this command is repeated with Newline.
      But don't clobber a user-defined command's definition.  */

    if (from_tty) {
      *exp = '\0';
    }
    remote_copymem(source_address, destination_address, length);
d368 8
d378 5
a382 2
static void searchword_command(exp, from_tty)
    char *exp;
d384 3
a386 4
  if (exp) {
    u_long length, source_address, pattern;
    char *first_space_index;
    char *second_space_index;
a387 3
    if (*exp == '\0') {
      error("This command can not be repeated with a newline");
    }
d389 5
a393 6
    first_space_index = (char *) index (exp, ' ');
    if (first_space_index == (char *)0) {
      error("Usage: sw <address> <length> <pattern>");
    }
    *first_space_index = '\0';
    source_address = parse_and_eval_address (exp);
d395 6
a400 16
    second_space_index = (char *) index (first_space_index + 1, ' ');
    if (second_space_index == (char *)0) {
      error("Usage: sw <address> <length> <pattern>");
    }
    *second_space_index = '\0';
    length = parse_and_eval_address (first_space_index + 1);
    pattern = parse_and_eval_address (second_space_index + 1);

   /* Cause expression not to be there any more
      if this command is repeated with Newline.
      But don't clobber a user-defined command's definition.  */

    if (from_tty) {
      *exp = '\0';
    }
    remote_searchmem(source_address, length, pattern, 0, 0xffffffff, 0, 4);
d402 2
d406 1
a406 8
/*
 * Does the 'flush' command.
 */
static void flush_command()
{
    flush_tty_line();
    invalidate_mem_cache();
}
d408 1
a408 4
/*
 * This flushes any crud that might be waiting for us.
 */
static void flush_tty_line()
d417 1
a417 1
        error("flush_tty_line: Error doing fcntl to set flags on %s", 
d423 4
a426 7
        ui_fprintf(stderr, "flushed: ");
        for (i = 0 ; i < cnt ; i++) {
            if (varvalue("motomode") && isprint(buf[i])) {
              ui_fprintf(stderr, "%c", buf[i]);
            } else {
              ui_fprintf(stderr, "%s ", commname(buf[i], prev_char));
            }
d428 2
a430 1
        ui_fprintf(stderr, "\n");
d445 1
a445 1
        error("flush_tty_line: Error doing fcntl to set flags on %s", 
d461 1
a461 1
    u_char c;
d463 1
a464 1

d466 4
a469 4
        if (!ignore_errors) {
            error("Received %s instead of COMMAND_PREFIX1", commname(c, 0));
        }
        return 0;
d473 4
d478 14
a491 2
    if (c != token1 && c != token2) {
        unsigned exception_code;
d493 7
a499 16
        switch (c) {
            case C_EXCEPTION:
                invalidate_mem_cache();
                exception_code = get_word();
                ui_fprintf(stderr, "\nTarget took ");
                if (exception_code < 512) {
                    printsig(stderr, exception_code);
                } else {
                    ui_fprintf(stderr, 
                                  "an exception, but the code was garbled.\n");
                }
                ui_fprintf(stderr, 
                  ".  This happened while waiting for a %s or a %s\n",
                                        commname(token1, COMMAND_PREFIX1), 
                                        commname(token2, COMMAND_PREFIX2));
                break;
d501 7
a507 17
            case C_CHECKSUMERR:
            case C_COMMERR:
            case C_BADCOMMAND:
            case C_COMPRESSERR:
            case C_EXPECTEDTOKEN:
                handle_target_error(c);
                break;

            default:
                flush_tty_line();
                error("Received %s instead of %s or a %s",
                              commname(c, COMMAND_PREFIX1), 
                              commname(token1, COMMAND_PREFIX1), 
                              commname(token2, COMMAND_PREFIX1));
                break;
        }
        return C_NONE;
d509 3
a511 1
    return c;
d536 1
a536 1
                                                               commname(c, 0));
d554 2
a555 6
                    if (varvalue("traceremote")) {
                        ui_fprintf(stderr,
                                       "Expected and received the exception: ");
                        printsig(stderr, exception_code);
                        ui_fprintf(stderr, "\n");
                    }
d560 2
a561 3
                        ui_fprintf(stderr, "\nTarget got ");
                        printsig(stderr, exception_code);
                        error(" while trying to single step.");
d564 1
a564 3
                        ui_fprintf(stderr, "\nTarget got ");
                        printsig(stderr, exception_code);
                        error("");
a567 2
                        ui_fprintf(stderr, "\nWhile waiting for ");
                        printsig(stderr, expected_exception);
d569 3
a571 2
                            ui_fprintf(stderr, ", target got ");
                            printsig(stderr, exception_code);
d573 3
a575 2
                            ui_fprintf(stderr, 
                       " target got an exception, but the code was garbled.");
a576 1
                        error("");
d586 1
a586 1
                    error("Received outrageous length, %d on dbread.", length);
d589 1
a589 4
                if (varvalue("traceremote")) {
                    ui_fprintf(stderr, 
                           "reading %d character string for remote.\n", length);
                }
d591 1
a591 1
                    error("dbread: unable to malloc a %d bytes", length);
d594 1
a594 1
                      error("dbread: error doing ui_fgets, length=%d", length);
d612 1
d619 1
a619 1
                    error("Received outrageous length, %d on dbwrite.", length);
d622 2
a623 4
                if (varvalue("traceremote")) {
                    ui_fprintf(stderr, 
                     "receiving %d character string from remote.\n", length);
                }
d639 1
a639 2
                        ui_fprintf(stderr,
          "\nTarget got data exception while fetching characters to send up\n");
a640 3
                        error("the comm line for remote console output.");
                        break;

d642 1
a642 1
                        error("Didn't find C_DATASTART in DBWRITE");
d645 1
d653 1
a653 1
                handle_target_error(c);
d658 2
a659 2
                    error("wait_for_exception: got %s", 
                                                 commname(c, COMMAND_PREFIX1));
d670 1
a670 1
static void reset_remote()
d674 1
a674 1
  initglobals();
d689 1
a689 1
      ui_badnews(-1, "Timeout trying to reset target.");
d706 1
a706 3
      if (varvalue("traceremote")) {
        ui_fprintf(stderr, "Target received reset signal.\n");
      }
d711 1
a711 1
      ui_badnews(-1, "Unable to reset remote.");
d717 4
a720 7
/*
 * Send the 0x82 code to the target in order to interrupt it.  The kludge
 * board will see this code and pull 88k's interrupt line.  Returns
 * true if it was successful in interrupting the target.
 */
static
boolean interrupt_remote()
a721 1
    boolean b = true;
d727 1
a727 3
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "sending C_SYNC to target...\n");
            }
d733 2
a734 1
                return true;
d742 2
a743 1
        error("Timeout trying to interrupt target.");
d745 1
a745 3
        if (varvalue("traceremote")) {
            ui_fprintf(stderr, "Interrupting target ...\n");
        }
d753 2
a754 4
            stop_cause = SIGINT;
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "Target received debug interrupt.\n");
            }
d765 2
a766 2
            ui_fprintf(stdout, "Unable to interrupt target\n");
            b = false;
a771 1
    return b;
d779 1
a779 1
static void get_monitor_addresses()
d787 1
a787 1
    ui_badnews(-1, "You must attach the target before using this command.\n");
d804 1
a804 2
            spllo();
            error("Target got error while sending monitor addresses");
d807 1
a807 2
            spllo();
            error("Didn't find C_DATASTART in get_monitor_addresses");
a808 1
    mon_compress_table_addr = get_word();
d810 6
a815 3
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "mon_compress_table_addr=0x%x\n", 
                         mon_compress_table_addr);
d819 1
a820 5
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "mon_register_area_addr=0x%x\n", 
                         mon_register_area_addr);
    }

d822 1
a823 5
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "mon_single_step_trap_addr=0x%x\n", 
                         mon_single_step_trap_addr);
    }

d825 1
a826 4
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "mon_version_addr=0x%x\n", mon_version_addr);
    }

d837 1
a837 3
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "mon_panic_code_addr=0x%x\n", mon_panic_code_addr);
    }
d840 1
a840 1
        error("Didn't find C_DATAEND in get_monitor_addresses\n");
d904 1
a904 1
      ui_badnews(-1, "Can't set remote tty line to %d baud", new_baud);
d907 1
a907 1
    ui_badnews(-1, 
d914 1
a914 1
        ui_badnews(-1, 
d943 1
a943 1
    ui_badnews(-1, "Cannot open %s", remote_tty_name);
d947 1
a947 1
    ui_badnews(-1, "open_remote_tty: Error in doing TCGETA ioctl");
d960 1
a960 1
    ui_badnews(-1, "open_remote_tty: Error in doing TCSETA ioctl");
d966 1
a966 1
    ui_badnews(-1, "open_remote_tty: Error doing fcntl to set flags on %s", 
a971 800
 * Check the text passed in against the text in the target's memory.
 */
static void check_remote(object_fd, t_start, t_length)
    int object_fd;
    u_long  t_start; 
    u_long  t_length;
{
    u_long *checksums;
    u_long blocks;
    u_long i;
    u_long *wp;
    u_long addr;

    /*
     * We first find the checksum of each 4K block
     * in the the target by doing a checksum command to the
     * target.  Then we checksum each 4K block to be downloaded.
     * We then upload and compare blocks that were different.
     */

    assert((t_length & 3) == 0);

    /*
     * Allocate an array of booleans to store the flag for each
     * block.
     */
    blocks = (t_length + (PAGESIZE - 1)) / PAGESIZE;
    checksums = (u_long *)malloc((unsigned)(blocks * sizeof(unsigned *)));

    /*
     * Send the checksum command to the target.
     */
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, 
           "Asking target for checksums on %d blocks starting at 0x%x\n",
                                                blocks, t_start);
    }

    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "Checksumming 0x%x bytes starting at 0x%x\n",
                            t_length, t_start);
    }
    init_checksum();
    splhi();
    send_command(varvalue("noparityinit") ? C_CHECKSUMNOINIT : C_CHECKSUM);
    send_word(t_start);
    send_word(t_length);
    send_command(C_END);
    send_checksum();

    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 3 /* seconds */)) {
        case C_DATASTART:
            break;

        case C_DATAERROR:
            spllo();
            error("Target was unable to checksum block at 0x%x\n", t_start);

        default:
            spllo();
            error("Didn't find C_DATASTART in checkdl");
    }
    for (i = 0 ; i < blocks ; i++) {
        checksums[i] = get_word();
    }

    if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
        spllo();
        error("Didn't find C_DATAEND in checkdl");
    }
    spllo();

    addr = t_start;
    for (i = 0 ; i < blocks ; i++) {
        u_long block_size;
        u_long buf[PAGESIZE/sizeof(u_long)];
        u_long *wp, filebuffer[PAGESIZE/sizeof(u_long)];
	QUIT;
        block_size = (i == (blocks - 1)) ? (t_length % PAGESIZE) : PAGESIZE;
        if (block_size == 0) {
            block_size = PAGESIZE;
        }
        wp = filebuffer;
        if (read(object_fd, &wp[0], block_size) != block_size) {
            error("Error reading from object file");
        }

        if (checksums[i] != checksum_of(wp, block_size)) {
            unsigned cnt;

            if (varvalue("tracedownload")) {
                ui_fprintf(stderr, 
                       "Uploading block %d at address 0x%x of length %d\n",
                              i, addr, block_size);
            } 
            if (dread_remote((u_char *)&buf[0], addr, block_size, M_SUPERVISOR)) {
                error("Error reading %d bytes at 0x%x in checkdl", block_size, addr);
            }
            for (cnt = 0 ; cnt < block_size ; cnt += sizeof(u_long)) {
	        QUIT;
                if (*wp != buf[cnt / sizeof(u_long)]) {
                    ui_fprintf(stdout, "%08x : expected: %08x  target: %08x\n",
                              addr, *wp, buf[cnt / sizeof(u_long)]);
                }
                wp++;
                addr += sizeof(u_long);
            }
        } else {
            wp += block_size / sizeof(u_long);
            addr += block_size;
        }
    }
    free((char *)checksums);
}

/*
 * Download the target system.  Returns true if the download was
 * successful, returns false if an error was detected.
 */
boolean dl_remote(object_fd, t_start, t_length, 
                             d_start, d_length, 
                             b_start, b_length)
    int object_fd;
    u_long  t_start; 
    u_long  t_length;
    u_long  d_start;
    u_long  d_length;
    u_long  b_start;
    u_long  b_length;
{
    struct timeval tv;
    struct timezone tz;

    total_bytes_transmitted = 0;
    total_bytes_received = 0;
    total_bytes_downloaded = t_length + d_length;

    gettimeofday(&tv, &tz);
    start_time = (double)tv.tv_sec + (double)tv.tv_usec / 1000000.0;

    /*
     * Download the text and data, zero bss.
     */
    download(object_fd, t_start, t_length);
    mark_breakpoints_out();
    download(object_fd, d_start, d_length);
    remote_zeromem(b_start, b_length);

    gettimeofday(&tv, &tz);
    end_time = (double)tv.tv_sec + (double)tv.tv_usec / 1000000.0;

    print_comm_statistics();

    downloaded = true;
    return true;
}

/*
 * This fills a block of target memory with zeros.
 */
static void remote_zeromem(addr, length)
    u_long addr;
    int length;
{
  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    splhi();

    invalidate_mem_cache();
    init_checksum();
    send_command(C_FILL);
    send_word(addr);
    send_word(length);
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "Zeroing memory from 0x%x to 0x%x\n", 
                                          addr, addr + length);
    }
    send_command(C_END);
    send_checksum();
    if (wait_for_token(C_ACK, C_NONE, ta_warning, 
                                  (int)(2+length/500000)) !=C_ACK) {
        spllo();
        error("Didn't find C_ACK in remote_zeromem");
    }
    spllo();
}

/*
 * This copies a block of target memory
 */
static void remote_copymem(src_addr, dst_addr, length)
    u_long src_addr, dst_addr;
    int length;
{
  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    splhi();
    invalidate_mem_cache();
    init_checksum();
    send_command(C_COPYMEM);
    send_word(src_addr);
    send_word(dst_addr);
    send_word(length);
    send_word(!varvalue("noparityinit"));
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "Copying memory 0x%x - 0x%x to 0x%x\n", 
                                 src_addr, src_addr + length - 1, dst_addr);
    }
    send_command(C_END);
    send_checksum();
    if (wait_for_token(C_ACK, C_NONE, ta_warning, (int)(2+length/50000)) !=C_ACK) {
        spllo();
        error("Didn't find C_ACK in remote_copymem");
    }
    spllo();
}
/*
 * This searches target memory 
 */
u_long remote_searchmem(addr, length, pattern1, pattern2, mask1, mask2, stride)
    u_long addr, pattern1, pattern2, mask1, mask2;
    long length, stride;
{
    u_long search_addr;

  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }

    if ((mask1 & pattern1) != pattern1) {
        error("Mask of 0x%x, pattern of 0x%x can not match any word",
                                                              mask1, pattern1);
    }
    if ((mask2 & pattern2) != pattern2) {
        error("Mask of 0x%x, pattern of 0x%x can not match any word", 
                                                              mask2, pattern2);
    }
    init_checksum();
    splhi();
    send_command(C_SEARCH);
    send_word(addr);
    send_word(length);
    send_word(stride);
    send_word(pattern1);
    send_word(pattern2);
    send_word(mask1);
    send_word(mask2);
    send_word(!varvalue("noparityinit"));
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "Searching memory at 0x%x\n", addr);
    }
    send_command(C_END);
    send_checksum();

    init_checksum();
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, (2+length/50000)) ) {
        case C_DATASTART:
            search_addr = get_word();
            if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
                spllo();
                error("Didn't find C_DATAEND in search");
            }
            verify_checksum();
            break;

        case C_DATAERROR:
            spllo();
            error("DACC while searching, check search range");
            break;

        default:
            spllo();
            error("Didn't get C_DATASTART from target");
            break;
    }
    spllo();
    if (search_addr == 0xffffffff) {
        ui_fprintf(stdout, "No match\n");
        return addr;
    }
    ui_fprintf(stdout, "Match at 0x%x:", search_addr);
    ui_fprintf(stdout, " 0x%x", read_remote_w(search_addr, M_SUPERVISOR));
    ui_fprintf(stdout, " 0x%x\n", read_remote_w(search_addr + 4, M_SUPERVISOR));
    return search_addr;
}

/*
 * This displays some statistics.
 */
static void print_comm_statistics()
{
    double elapsed_time;
    double bytes_per_second;
    double effective_bps;

    if (varvalue("tracedownload")) {

        ui_fprintf(stdout, "Total of %d bytes received\n", 
                total_bytes_received + bytes_received);

        ui_fprintf(stdout, "Total of %d bytes transmitted\n", 
                total_bytes_transmitted + bytes_transmitted);

        elapsed_time = end_time - start_time;

        if (elapsed_time > 0.0) {
            bytes_per_second = (double)total_bytes_transmitted / elapsed_time;
            effective_bps = (double)total_bytes_downloaded / elapsed_time;

            ui_fprintf(stdout, "\n");
            ui_fprintf(stdout, 
           "Elapsed time of last download = %8.2f\n", elapsed_time);

            ui_fprintf(stdout, 
           "Actual transfer rate of last download %8.2f\n", bytes_per_second);

            ui_fprintf(stdout, 
           "Effective transfer rate of last download = %8.2f\n", effective_bps);
        }
    }
}

/*
 * Download the data pointed to by the first parameter to
 * the target.  We first find the checksum of each 4K block
 * in the the target by doing a checksum command to the
 * target.  Then we checksum each 4K block to be downloaded.
 * Only blocks whose checksums don't match are downloaded.
 */
static void download(object_fd, start_addr, length)
    int object_fd;
    u_long start_addr;
    u_long length;
{
    u_long *checksums;
    u_long blocks;
    u_long i;
    u_long *wp;
    u_long addr;

    assert((length & 3) == 0);

    total_bytes_transmitted += bytes_transmitted;
    total_bytes_received += bytes_received;
    bytes_transmitted = 0;
    bytes_received = 0;

    /*
     * Allocate an array of booleans to store the flag for each
     * block.
     */
    blocks = (length + (PAGESIZE - 1)) / PAGESIZE;
    checksums = (u_long *)malloc((unsigned)blocks * sizeof(unsigned *));

    /*
     * Send the checksum command to the target.
     */
    if (varvalue("tracedownload")) {
        ui_fprintf(stderr, 
           "Asking target for checksums on %d blocks starting at 0x%x\n",
                                                blocks, start_addr);
    }

    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "Checksumming 0x%x bytes starting at 0x%x\n",
                            length, start_addr);
    }
    init_checksum();
    splhi();
    send_command(varvalue("noparityinit") ? C_CHECKSUMNOINIT : C_CHECKSUM);
    send_word(start_addr);
    send_word(length);
    send_command(C_END);
    send_checksum();

    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 2)) {
        case C_DATASTART:
            break;

        case C_DATAERROR:
            spllo();
            error("DACC while downloading block at 0x%x", start_addr);

        default:
            spllo();
            error("Didn't find C_DATASTART in download");
    }
    for (i = 0 ; i < blocks ; i++) {
        u_long block_size;

        block_size = (i == (blocks - 1)) ? (length % PAGESIZE) : PAGESIZE;
        if (block_size == 0) {
            block_size = PAGESIZE;
        }
        checksums[i] = get_word();
    }

    if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
        spllo();
        error("Didn't find C_DATAEND in download");
    }
    spllo();

    addr = start_addr;
    invalidate_mem_cache();
    for (i = 0 ; i < blocks ; i++) {
        u_long block_size;
        u_long *wp, filebuffer[PAGESIZE/sizeof(u_long)];

        block_size = (i == (blocks - 1)) ? (length % PAGESIZE) : PAGESIZE;
        if (block_size == 0) {
            block_size = PAGESIZE;
        }
        QUIT;
        wp = filebuffer;
        if (read(object_fd, &wp[0], block_size) != block_size) {
            error("Error reading block %d from %s", i, objname);
        }

        if (checksums[i] != checksum_of(wp, block_size)) {
            unsigned cnt;

            if (varvalue("tracedownload")) {
                ui_fprintf(stderr, "Downloading %d bytes to 0x%x\n",
                              block_size, addr);
            } else {
                ui_fprintf(stderr, "*");
            }
            init_checksum();
            splhi();
            send_command(C_DOWNLOAD);
            send_word(addr);
            send_word(block_size);
            for (cnt = 0 ; cnt < block_size ; cnt += 4) {
                send_word(*wp++);
            }
            send_command(C_END);
            send_checksum();
            switch (wait_for_token(C_ACK, C_DATAERROR, ta_warning, 2)) {
                case C_ACK:
                    break;

                case C_DATAERROR:
                    spllo();
                    error("DACC while writing at 0x%x", addr);
                  
                default:
                    spllo();
                    error("Didn't find C_ACK in download");
            }
            spllo();
        } else {
            ui_fprintf(stderr, ".");
            wp += block_size / sizeof(unsigned *);
        }
        addr += block_size;
    }
    if (varvalue("tracedownload")) {
        ui_fprintf(stderr, "%d bytes sent to target.\n", bytes_transmitted);
        ui_fprintf(stderr, "%d bytes received from target.\n", bytes_received);
    } else {
        ui_fprintf(stderr, "\n");
    }
    free((char *)checksums);
}

/*
 * This returns the checksum of the array of words pointed to
 * by the first parameter.  'length' is in bytes, it should be
 * a multiple of 4.
 */
static u_long checksum_of(wp, length)
    register u_long *wp;
    register u_long length;
{
    assert((length & 3) == 0);

    init_checksum();
    while (length != 0) {
        add_to_checksum(*wp++);
        length -= 4;
    }
    return checksum;
}

/* Reset the target.  We may have done this after the target went out
   to lunch, make sure that we've removed any breakpoints.  */ 
static void init_command()
{
  reset_remote();
  remove_breakpoints ();
  remove_step_breakpoint ();
}

/* Print many of the useful 88100 registers.  This overlaps with "info regs."
   We print the Data Memory Unit registers if they are valid. */
static void regs_command()
{
  int j, i;

  for (i = 0 ; i < 8 ; i++) {
    for (j = i ; j < i + 25 ; j += 8) {
      if (i == 0 && j == 0) {
        ui_fprintf(stdout, "                   ");
      } else {
        ui_fprintf(stdout, "r%-3d 0x%08x    ", j, read_hard_register(j));
      }
    }
    ui_fprintf(stdout, "\n");
  }

  ui_fprintf(stdout, "sxip 0x%08x    ", read_hard_register(SXIP_REGNUM));
  ui_fprintf(stdout, "snip 0x%08x    ", read_hard_register(SNIP_REGNUM));
  ui_fprintf(stdout, "sfip 0x%08x    ", read_hard_register(SFIP_REGNUM));
  ui_putchar('\n');

  if (remote_debugging) {
    ui_fprintf(stdout, "vbr  0x%08x    ", remote_read_register(VBR_REGNUM));
    ui_fprintf(stdout, "psr  0x%08x    ", remote_read_register(PSR_REGNUM));
    if (!varvalue("motomode")) {
      ui_fprintf(stdout, "ceimr 0x%08x", remote_read_register(CEIMR_REGNUM));
    }

    ui_putchar('\n');
    ui_fprintf(stdout, "sr0  0x%08x    ", remote_read_register(SR0_REGNUM));
    ui_fprintf(stdout, "sr1  0x%08x    ", remote_read_register(SR1_REGNUM));
    ui_fprintf(stdout, "sr2  0x%08x    ", remote_read_register(SR2_REGNUM));
    ui_fprintf(stdout, "sr3  0x%08x    ", remote_read_register(SR3_REGNUM));
    ui_putchar('\n');
  
    if (remote_read_register(DMT0_REGNUM) & 1) {
      ui_fprintf(stdout, "dmt0 0x%08x    ", remote_read_register(DMT0_REGNUM));
      ui_fprintf(stdout, "dmd0 0x%08x    ", remote_read_register(DMD0_REGNUM));
      ui_fprintf(stdout, "dma0 0x%08x    ", remote_read_register(DMA0_REGNUM));
      ui_putchar('\n');
    }
  
    if (remote_read_register(DMT1_REGNUM) & 1) {
      ui_fprintf(stdout, "dmt1 0x%08x    ", remote_read_register(DMT1_REGNUM));
      ui_fprintf(stdout, "dmd1 0x%08x    ", remote_read_register(DMD1_REGNUM));
      ui_fprintf(stdout, "dma1 0x%08x    ", remote_read_register(DMA1_REGNUM));
      ui_putchar('\n');
    }
  
    if (remote_read_register(DMT2_REGNUM) & 1) {
      ui_fprintf(stdout, "dmt2 0x%08x    ", remote_read_register(DMT2_REGNUM));
      ui_fprintf(stdout, "dmd2 0x%08x    ", remote_read_register(DMD2_REGNUM));
      ui_fprintf(stdout, "dma2 0x%08x    ", remote_read_register(DMA2_REGNUM));
      ui_putchar('\n');
    }
  }
}
  
/*
 * This reads the code and data into simulator or remote memory.  It also
 * zero's the bss region.
 */
static void download_command(exp, from_tty)
    char *exp;
{
    int f;
    extern CORE_ADDR text_start, text_end;
    extern CORE_ADDR exec_data_start, exec_data_end;
    extern data_size, text_offset, exec_data_offset;
    
    u_long text_size = text_end - text_start;
    u_long data_size = exec_data_end - exec_data_start;

  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    remote_errno = false;
    f = open(objname, O_RDONLY, 0);
    if (f < 0) {
        error("can't open %s", objname);
    }

    if (text_start < (varvalue("motomode") ? 0x10000 : 0x8000)) {
      error("Text starts too low (0x%x), would overwrite ROM's area", 
             text_start);
    }
    lseek(f, text_offset, 0);
    if (!dl_remote(f, text_start, text_size,
                      exec_data_start, data_size,
                      bss_start, bss_size)) {
        error("Error in download");
    } else {
        setvar("noparityinit", 1);
    }

    remote_write_register(SNIP_REGNUM, entry_point | IP_VALID);
    remote_write_register(SFIP_REGNUM, (entry_point + 4) | IP_VALID);
    decode_instr_before_stepping(fetch_instruction(entry_point));  
    if (close(f) < 0) {
        error("Error closing object file.\n");
    }
}

/*
 * This checks that the host's copy of the text and data matches that
 * in the target.
 */
static void checkdl_command(exp, from_tty)
    char *exp;
{
    int f;
    extern CORE_ADDR text_start, text_end;
    extern text_offset;
    
    u_long text_size = text_end - text_start;

  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    remote_errno = false;

    f = open(objname, O_RDONLY, 0);
    if (f < 0) {
        error("can't open %s", objname);
    }

    lseek(f, text_offset, 0);
    check_remote(f, text_start, text_size);

    if (close(f) < 0) {
        error("Error closing object file.\n");
    }
}

/*
 * Read a single byte, no more, no less, from the target.
 */
static void readbyte_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    if (*exp != '\0') {
      next_address = parse_and_eval_address (exp);

     /* Cause expression not to be there any more
         if this command is repeated with Newline.
         But don't clobber a user-defined command's definition.  */

      if (from_tty) {
        *exp = '\0';
      }
    }
    ui_fprintf(stdout, "0x%08x: 0x%02x\n", next_address, 
              forced_read_remote(next_address, sizeof(char), M_SUPERVISOR));
  }
}

/*
 * Read a single halfword, no more, no less, from the target.
 */
static void readhalf_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    if (*exp != '\0') {
      next_address = parse_and_eval_address (exp);

     /* Cause expression not to be there any more
         if this command is repeated with Newline.
         But don't clobber a user-defined command's definition.  */

      if (from_tty) {
        *exp = '\0';
      }
    }
    ui_fprintf(stdout, "0x%08x: 0x%02x\n", next_address, 
           forced_read_remote(next_address, sizeof(short), M_SUPERVISOR));
  }
}

/*
 * Read a single word, no more, no less, from the target.
 */
static void readword_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    if (*exp != '\0') {
      next_address = parse_and_eval_address (exp);

     /* Cause expression not to be there any more
         if this command is repeated with Newline.
         But don't clobber a user-defined command's definition.  */

      if (from_tty) {
        *exp = '\0';
      }
    }
    ui_fprintf(stdout, "0x%08x: 0x%02x\n", next_address, 
                forced_read_remote(next_address, sizeof(long), M_SUPERVISOR));
  }
}

/*
 * Write a single byte to target memory.
 */
static void writebyte_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    u_long data_to_write;
    char *space_index;

    if (*exp == '\0') {
      error("This command can not be repeated with a newline");
    }

    space_index = (char *) index (exp, ' ');
    if (space_index == (char *)0) {
      error("Usage: wb <address> <byte>");
    }
    *space_index = '\0';
    next_address = parse_and_eval_address (exp);
    data_to_write = parse_and_eval_address (space_index + 1);

   /* Cause expression not to be there any more
      if this command is repeated with Newline.
      But don't clobber a user-defined command's definition.  */

    if (from_tty) {
      *exp = '\0';
    }
    write_remote_b(next_address, data_to_write, M_SUPERVISOR);
  }
}

/*
 * Write a halfword to target memory.
 */
static void writehalf_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    u_long data_to_write;
    char *space_index;

    if (*exp == '\0') {
      error("This command can not be repeated with a newline");
    }

    space_index = (char *) index (exp, ' ');
    if (space_index == (char *)0) {
      error("Usage: wh <address> <half-word>");
    }
    *space_index = '\0';
    next_address = parse_and_eval_address (exp);
    data_to_write = parse_and_eval_address (space_index + 1);

   /* Cause expression not to be there any more
      if this command is repeated with Newline.
      But don't clobber a user-defined command's definition.  */

    if (from_tty) {
      *exp = '\0';
    }
    write_remote_h(next_address, data_to_write, M_SUPERVISOR);
  }
}

/*
 * Write a word that we read from standard input to target memory.
 */
static void writeword_command(exp, from_tty)
    char *exp;
{
  if (exp) {
    u_long data_to_write;
    char *space_index;

    if (*exp == '\0') {
      error("This command can not be repeated with a newline");
    }

    space_index = (char *) index (exp, ' ');
    if (space_index == (char *)0) {
      error("Usage: ww <address> <word>");
    }
    *space_index = '\0';
    next_address = parse_and_eval_address (exp);
    data_to_write = parse_and_eval_address (space_index + 1);

   /* Cause expression not to be there any more
      if this command is repeated with Newline.
      But don't clobber a user-defined command's definition.  */

    if (from_tty) {
      *exp = '\0';
    }
    write_remote_w(next_address, data_to_write, M_SUPERVISOR);
  }
}

/*
d1003 2
a1004 1
  boolean tr;	/* True if the target was running before we interrupted it */
d1015 8
a1022 8
  /*
   * Attempt to interrupt the target.  If we are successful, unwind
   * the stack and let go_remote return to its caller.
   */
  if (tr = target_running) {
    quit_flag = 0;
  }
  if (interrupt_remote() == true) {
d1024 1
a1024 3
    if (stop_cause == SIGINT && tr) {
      longjmp(controlc_env, 1);
    }
a1025 1
}
d1027 3
a1029 11
/*
 * Decode the instruction that we are about to execute.  If it is
 * a load or store, calculate the effective address.  We will use this
 * later in "print_effect", but we must calculate it now in case one
 * of the registers used to form the address is the destination of a
 * load instruction.
 */
void decode_instr_before_stepping(iword)
    u_long iword;
{
    int shift;
d1031 4
a1034 24
    last_iword = iword;
    instr_info = instruction_lookup(iword);
    switch (instr_info->format) {
        case LDLIT: case STLIT:
            ld_st_addr = read_register(S1(iword)) + LIT16(iword);
            break;

        case LDRO: case STRO:
            ld_st_addr = read_register(S1(iword)) + 
                         read_register(S2(iword));
            break;

        case LDRI: case STRI:
            switch ((iword >> 10) & 3) {
                case 0: shift = 3; break;
                case 1: shift = 2; break;
                case 2: shift = 1; break;
                case 3: shift = 0; break;
            }
 
            ld_st_addr = read_register(S1(iword)) + 
                         (read_register(S2(iword)) << shift);
            break;
    }
a1037 36
 * Print the effect of this instruction.  We assume that this was
 * the instruction that was just executed.  XMEM instructions are not
 * handled correctly.
 */
void print_effect()
{
    int r;

    if (last_iword == 0) {
        return;
    }
    r = D(last_iword);
    switch (instr_info->format) {
        case INTRL: case INTRR: case BITFIELD: case INTRR2OP:
        case LDCR:  case FLDCR: case ROT: case INTRR_S1_S2:
            ui_fprintf(stdout, "r%-2d=0x%-8x\n",
                             r, read_register(r));
            break;

        case LDLIT: case LDRO: case LDRI:
            ui_fprintf(stdout, "r%-2d=0x%-8x loaded from 0x%-8x\n", 
                             r, read_register(r), ld_st_addr);
            break;

        case STLIT: case STRO: case STRI:
            ui_fprintf(stdout, "r%-2d=0x%-8x stored to 0x%-8x\n", 
                             r, read_register(r), ld_st_addr);
            break;

        default:
            break;
    }
    last_iword = 0;
}

/*
d1039 1
a1039 1
 * 'prev_char' is the previous character.  This helps commname 
d1042 1
a1042 1
static char *commname(c, prev_char)
d1047 1
a1047 1
    static char *commnames[] = 
d1061 1
a1061 1
      sprintf(str, "0x%x", c);
d1082 1
a1082 1
                return commnames[c - C_DOWNLOAD];
d1088 1
a1088 1
    sprintf(str, "0x%x", c);
d1259 1
a1259 1
                                    error("Target got DACC");
d1266 1
a1266 1
                                    handle_target_error(c);
d1270 2
a1271 2
                                    error("Unexpected: %s", 
                                            commname(c, L_QUOTED1));
d1279 1
a1279 1
                            error("Unexpected value after L_QUOTED2: %d", c);
d1297 1
a1297 1
			error("Case error in get_byte()");
d1314 1
a1314 1
		error("Checksum error, expected=0x%x received=0x%x",
d1328 1
a1328 1
        error("reset_timer: Error doing setitimer");
a1333 487
 * Returns a register from the target.
 */
u_long remote_read_register(n)
    unsigned n;
{
  get_monitor_addresses();

  /*
   * The register numbering in the U-area, and thus of gdb, is
   * a different from the register numbering in the target
   * debug ROMs.  
   */
  return read_remote_w(mon_register_area_addr + 4 * regmap[n], M_SUPERVISOR);
}

/*
 * Puts a new value into a register in the target.
 */
void remote_write_register(n, w)
    unsigned n;
    u_long   w;
{
    int oldn = n;
    get_monitor_addresses();

    write_remote_w(mon_register_area_addr + 4 * regmap[n], w, M_SUPERVISOR);
}

/*
 * Read for the remote's data space.
 */
static boolean dread_remote(buff, addr, nbytes, usmode)
    u_char *buff;
    u_long addr;
    u_long nbytes;
    int usmode;
{
    int i;

    if (usmode != M_USER && usmode != M_SUPERVISOR) {
        usmode = (((remote_read_register(PSR_REGNUM) >> 31) & 1) == 0) ? 
				M_USER : M_SUPERVISOR;
    }
    /*
     * Read as manys full words as we can.
     */
    for (i = 0 ; i < (int)nbytes - 3 ; addr += 4) {
        u_long w;
        int j;

        w = read_remote_w(addr, usmode);
        if (remote_errno) {
            return true;
        }
        for (j = 24 ; j >= 0 && i < nbytes ; i++, j -= 8 ) {
            buff[i] = w >> j;
        }
    }

    /*
     * Now read a halfword, if we can.
     */
    for ( ; i < (int)nbytes - 1 ; i += 2, addr += 2) {
        u_long w;

        w = read_remote_h(addr, usmode);
        if (remote_errno) {
            return true;
        }
        buff[i] = w >> 8;
        buff[i+1] = w;
    }

    /*
     * Now read a byte, if we can.
     */
    for ( ; i < nbytes ; i++, addr++) {
        buff[i] = read_remote_b(addr, usmode);
        if (remote_errno) {
            return true;
        }
    }
    return false;
}

/*
 * Write to the remote data space.
 */
static void dwrite_remote(buff, addr, nbytes, usmode)
    unsigned char *buff;
    u_long addr;
    u_long nbytes;
    int usmode;
{
    int i;

    if (usmode != M_USER && usmode != M_SUPERVISOR) {
        usmode = (((remote_read_register(PSR_REGNUM) >> 31) & 1) == 0) ? M_USER : M_SUPERVISOR;
    }
    for (i = 0 ; i < (int)nbytes - 3 ; addr += 4) {
        u_long w;
        int j;

        w = 0;
        for (j = 24 ; j >= 0  && i < nbytes ; i++, j -= 8 ) {
            w |= (buff[i] & 0xff) << j;
        }
        write_remote_w(addr, w, usmode);
        if (remote_errno) {
            error("dwrite: error at physical address 0x%x\n", addr);
        }
    }

    /*
     * Now write halfwords, if we can.
     */
    for ( ; i < (int)nbytes - 1 ; i += 2, addr += 2) {
        u_short w;

        w = (buff[i] << 8) | buff[i+1];
        write_remote_h(addr, w, usmode);
        if (remote_errno) {
            error("dwrite: error at physical address 0x%x\n", addr);
        }
    }

    /*
     * Now write bytes, if we can.
     */
    for (; i < nbytes ; i++, addr++) {
        write_remote_b(addr, buff[i], usmode);
        if (remote_errno) {
            error("dwrite: error at physical address 0x%x\n", addr);
        }
    }
}

/*
 * Read a byte, short, or word from the target
 */
static u_long forced_read_remote(addr, size, usmode)
    u_long addr;
    int    size;
{
    u_long w;
    u_char command;

  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    remote_errno = false;
    if (addr & (size - 1)) {
        error("Reading %d bytes from 0x%x would cause a MA exception.",
          size, addr);
    }
    splhi();
    init_checksum();
    if (varvalue("noparityinit")) {
        command = (usmode == M_USER) ? C_UPLOADNOINITUSER : C_UPLOADNOINIT;
    } else {
        command = (usmode == M_USER) ? C_UPLOADUSER : C_UPLOAD;
    }
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, "forced_read_remote: at 0x%x, size=%d", addr, size);
    }
    send_command(command);
    send_word(addr);
    send_word((u_long)size);
    send_command(C_END);
    send_checksum();

    init_checksum();
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
        case C_DATASTART:
            switch (size) {
                case 1: w = get_byte(); break;
                case 2: w = get_short(); break;
                case 4: w = get_word(); break;
                default:
                    spllo();
                    badcaseval(size);
            }
           
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, ", target returns 0x%x\n", w);
            }
            if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
                spllo();
                error("forced_read_remote: Didn't find C_DATAEND");
            } else {
                verify_checksum();
            }
            break;

        case C_DATAERROR:
            remote_errno = true;
            w = 0;
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, ", target gets DACC\n");
            }
            break;

        default:
            ui_fprintf(stderr, 
                             "forced_read_remote: Didn't find C_DATASTART\n");
            w = 0;
    }
    spllo();
    return w;
}

/*
 * Read a byte, short, or long from the remote.
 */
static u_long read_remote(addr, size, usmode)
    u_long addr;
    int size;
{
    u_long offset;
    u_char *p;
    int s;

    struct mem_cache *m = mem_cache;
    remote_errno = false;

  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    /*
     * If we are reading regular memory, and not IO space, cache
     * the data that we read back.  Also, read more than we need
     * for this request.
     */
    if (addr >= 0x80000000 && !in_rom(addr) && !in_sram(addr)) {
        return forced_read_remote(addr, size, usmode);
    }

    offset = addr & CACHELINEMASK;

    while (m) {
        if (m->addr == (~CACHELINEMASK & addr) && m->usmode == usmode) {
            break;
        }
        m = m->next;
    }
        
    /*
     * If we couldn't find the data we need in cache, then read a line
     * out of memory.
     */
    if (m == nil) {
        int i;
        u_char command;

        splhi();
        m = (struct mem_cache *)malloc(sizeof(struct mem_cache));
        init_checksum();
        m->addr = addr & ~CACHELINEMASK;
        m->usmode = usmode;
        if (varvalue("traceremote")) {
            ui_fprintf(stderr, "read_remote: filling cache line, addr=0x%x\n",
                              m->addr);
        }
        if (varvalue("noparityinit")) {
            command = (usmode == M_USER) ? C_UPLOADNOINITUSER : C_UPLOADNOINIT;
        } else {
            command = (usmode == M_USER) ? C_UPLOADUSER : C_UPLOAD;
        }
        send_command(command);
        send_word(m->addr);
        send_word((u_long)CACHELINESIZE);
        send_command(C_END);
        send_checksum();

        init_checksum();
        switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
            case C_DATASTART:
                for (i = 0 ; i < CACHELINESIZE ; i++) {
                    m->values[i] = get_byte();
                }
                if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
                    free(m);
                    spllo();
                    error("read_remote: Didn't find C_DATAEND.");
                } else {
                    verify_checksum();
                }
                m->next = mem_cache;
                mem_cache = m;
                break;

            case C_DATAERROR:
                remote_errno = true;
                if (varvalue("traceremote")) {
                    ui_fprintf(stderr, "read_remote: dacc at 0x%x\n", addr);
                }
                free((char *)m);
                m = nil;
                break;

            default:
                spllo();
                free((char *)m);
                m = nil;
                error("read_remote: Didn't find C_DATASTART.");
                break;
        }
        spllo();
    }

    /*
     * In the unlikely case that this access spans a cache-line
     * boundary, or if there was a problem reading the whole block,
     * just read it explicitly from the target.
     */
    if (m == nil) {
        return forced_read_remote(addr, size, usmode);
    }
    p = &m->values[offset];
    switch (size) {
        case 1: return *p;            break;
        case 2: return *(u_short *)p; break;
        case 4: return *(u_long  *)p; break;
        default:
            badcaseval(size);
            /* NOTREACHED */
    }
#ifdef lint
    return 0;
#endif
}

/*
 * Read a byte from the remote's memory.
 */
static u_char read_remote_b(addr, usmode)
    u_long addr;
{
    return (u_char)read_remote(addr, 1, usmode);
}

/*
 * Read a half word from the remote's memory.
 */
static u_short read_remote_h(addr, usmode)
    u_long addr;
{
    return (u_short)read_remote(addr, 2, usmode);
}

/*
 * Read a word from the remote's memory.
 */
static u_long read_remote_w(addr, usmode)
    u_long addr;
{
    return read_remote(addr, 4, usmode);
}

/*
 * This updates our memory cache.
 */
static void write_thru_mem_cache(addr, w, size, usmode)
    u_long addr;
    u_long w;
    int    size;
{
    struct mem_cache *m = mem_cache;
    u_long offset;

    while (m && (m->addr != (addr & ~CACHELINEMASK) || m->usmode != usmode)) {
        m = m->next;
    }
    if (m != nil) {
        offset = addr & CACHELINEMASK;
        switch (size) {
            case 1:               m->values[offset] = w; break;
            case 2:  *(u_short *)&m->values[offset] = w; break;
            case 4:  *(u_long  *)&m->values[offset] = w; break;
            default:
                badcaseval(size);
        }
    }
}

/*
 * Write a byte, short, or word into the remote's memory.
 */
static void write_remote(addr, w, size, usmode)
    u_long addr;
    u_long w;
    int    size;
{
    int s;

  if (!remote_debugging) {
    ui_badnews(-1, "You must attach the target before using this command.\n");
  }
    remote_errno = false;
    if (size != 1 && size != 2 && size != 4) {
        error("write_remote: bad size");
    }
    if (usmode != M_USER && usmode != M_SUPERVISOR) {
        usmode = (((remote_read_register(PSR_REGNUM) >> 31) & 1) == 0) ? M_USER : M_SUPERVISOR;
    }

    splhi();
    if (varvalue("traceremote")) {
        int a;

        get_monitor_addresses();
        ui_fprintf(stderr, "writing 0x%x to target at 0x%x ", w, addr);
        a = addr - mon_register_area_addr;
        /*
         * '66' below should really be a symbolic constant.  Anyway,
         * its the number of register slots in the monitor register
         * array. -rcb
         */
        if (0 <= a && a < (66 * 4)) {
            ui_fprintf(stderr, " (%s)\n", regname(a/4));
        } else {
            ui_fprintf(stderr, "\n");
        }
    }
    write_thru_mem_cache(addr, w, size, usmode);
    init_checksum();
    send_command((usmode == M_USER) ? C_DOWNLOADUSER : C_DOWNLOAD);
    send_word(addr);
    send_word((u_long)size);
    switch (size) {
        case 1: send_byte((u_char)w); break;
        case 2: send_short((u_short)w); break;
        case 4: send_word(w); break;
    }

    send_command(C_END);
    send_checksum();
    switch (wait_for_token(C_ACK, C_DATAERROR, ta_warning, 1)) {
        case C_ACK:
            break;

        case C_DATAERROR:
            remote_errno = true;
            sleep(1);
            flush_tty_line();
            spllo();
            error("DACC while trying to write 0x%x", addr);
            break;

        default:
            spllo();
            error("Didn't find C_ACK in write_remote");
    }
    spllo();
}

/*
 * Write a byte into the remote's memory.
 */
static void write_remote_b(addr, w, usmode)
    u_long addr;
    u_char w;
{
    write_remote(addr, (u_long)w, 1, usmode);
}

/*
 * Write a halfword into the remote's memory.
 */
static void write_remote_h(addr, w, usmode)
    u_long addr;
    u_short w;
{
    write_remote(addr, (u_long)w, 2, usmode);
}

/*
 * Write a word into the remote's memory.
 */
static void write_remote_w(addr, w, usmode)
    u_long addr;
    u_long w;
{
    write_remote(addr, w, 4, usmode);
}

/*
d1343 1
a1343 1
        error("put_remote_char: output buffer not initialized\n");
d1350 1
d1360 1
a1360 1
        ui_fprintf(stderr, "%s ", commname(c, prev_char));
d1375 1
a1375 1
            error("flush_out_buff: Error writing %d bytes to remote on %s", 
d1419 1
a1419 1
                    badcaseval(timeout_action);
d1428 1
a1428 1
        error("get_remote_char gets read error, errno=%d.", errno);
d1432 1
d1443 1
a1443 1
        ui_fprintf(stderr, "%s ", commname(buf[0], prev_char));
a1449 16
 * This invalidates the cache that we keep of target memory.  Every time
 * the target executes, even for a single-step, we dump this cache.
 */
void invalidate_mem_cache()
{
    struct mem_cache *m1, *m = mem_cache;

    mem_cache = nil;
    while (m) {
        m1 = m->next;
        free((char *)m);
        m = m1;
    }
}

/*
a1463 856
}

/*
 * Codes returned by classify_instruction(), used in ss_remote().
 */
#define I_NON_CONTROL   1
#define I_CBRANCH       2
#define I_CBRANCH_N     3
#define I_TRAP          4
#define I_JMP           5
#define I_JMP_N         6
#define I_BSR           7
#define I_BSR_N         8
#define I_JSR		9
#define I_JSR_N		10
#define I_BR		11
#define I_BR_N		12
#define I_BB		13
#define I_BB_N		14
#define	I_TRAP_NOT_TAKEN 15

/*
 * This classifies the passed 88000 instruction for ss_remote().  This
 * code could be in ss_remote, since that is the only place this is called,
 * but I thought it was clearer to make a function out of it.
 */
static int classify_instruction(instr)
    u_long instr;
{
    struct instr_info *instr_info;
    extern edata;

    instr_info = instruction_lookup(instr);
    if (instr_info == (struct instr_info *)0) {
      error("classify: could not find instruction 0x%08x in table\n", instr);
    }
    switch (instr_info->format) {
        case IPREL:
            if (((instr >> 27) & 0x1f) == 0x19) {
                return (instr & 0x04000000) ? I_BSR_N : I_BSR;
            }
            return (instr & 0x04000000) ? I_BR_N : I_BR;

        case BITBRANCH:
            return (instr & 0x04000000) ? I_BB_N : I_BB;

        case CBRANCH:
            return (instr & 0x04000000) ? I_CBRANCH_N : I_CBRANCH;

        case JMP:
            if ((instr & 0xfffffbe0) == 0xf400c800) {
                return (instr & 0x00000400) ? I_JSR_N : I_JSR;
            }
         
            return (instr & 0x00000400) ? I_JMP_N : I_JMP;

        case TRAP:
            /* Return I_TRAP_NOT_TAKEN if the this instruction won't
               trap.  This way we can single step over these traps.
               Otherwise we have to tell the user that we can't do it */
            if (((remote_read_register(S1(instr)) & (1 << B5(instr))) != 0)
                        != ((instr & 0x800) != 0)) {
                return I_TRAP_NOT_TAKEN;
            }
            /* Assume tbnd, and tcnd instructions trap */
        case TBND:
        case TCND:
        case RTE:
            return I_TRAP;

        default:
            /* Special case for reg-reg tbnd instruction, because
               it is marked a reg-reg instruction (probably to make
               disassembly of it correct. */
            if (0xf400f800 == (instr & 0xffe0ffe0)) {
                return I_TRAP;
            }
            return I_NON_CONTROL;
    }
}

/*
 * Single steps the processor.  If the instruction that the IP is pointing
 * at is a control instruction then we must simulate it.  Sometimes we
 * do this by calling the simulator.  In simple cases we just do the
 * instruction right here.
 */
static void ss_remote()
{
    u_long instr;
    u_long real_ip, new_ip;
    extern u_long delayed_ip;
    boolean success;

    get_monitor_addresses();
    real_ip = remote_read_register(SNIP_REGNUM) & ~(IP_VALID|IP_EXCEPTION);
    if (dread_remote(&instr, real_ip, sizeof(instr), M_CURMODE)) {
        error("ss_remote: unable to read address 0x%x\n", real_ip);
    }
    switch (classify_instruction(instr)) {
        case I_NON_CONTROL:
            if ((remote_read_register(PSR_REGNUM) & 0x80000000) == 0) {
                error("Sorry, can't single step in user mode\n");
                /* NOTREACHED */
            }

            if (varvalue("traceremote")) {
              ui_fprintf(stderr, 
                "Single-stepping target with snip=0x%x sfip=0x%x\n",
                         remote_read_register(SNIP_REGNUM), 
                         mon_single_step_trap_addr | IP_VALID);
            }
            splhi();
            /*
             * Single step the processor by pointing the 
             * Next-Instruction-Pointer at the instruction to be 
             * executed and the Fetched-Instruction-Pointer at the
             * trap instruction in the ROM.
             */
            remote_write_register(SFIP_REGNUM,
				  mon_single_step_trap_addr | IP_VALID);

            invalidate_mem_cache();
            init_checksum();
            send_command(C_GO);
            send_command(C_END);
            send_checksum();
            if (wait_for_token(C_ACK, C_NONE, ta_warning, 1) != C_ACK) {
                ui_fprintf(stderr, "Didn't find C_ACK in ss_remote\n");
            } else {
                success = wait_for_exception(TR_TRC, ta_warning, 1);
                if (!success) {
                    ui_fprintf(stderr, "the ip may be incorrect.\n");
                }

                /*
                 * If the instruction that we just executed on the target
                 * was in a branch delay slot, then we get the new IP value
                 * from 'delayed_ip', the simulator variable that is sometimes
                 * also set in this function.  Otherwise, we just 
                 * increment the previous IP value.
                 */
                if (delayed_p) {
                    new_ip = (u_long)delayed_ip;
                    delayed_p = nil;
                } else {
                    new_ip = real_ip + 4;
                }
                /*
                 * Make the sxip, snip, and sfip look reasonable.  After
                 * the single-step they are pointing at instructions in
                 * the ROM.
                 */
                remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
                remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
                remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            }
            spllo();
            break;

        case I_BR:
            if (delayed_p) {
                error("ss_remote: br instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote: simulating br instr.\n");
            }
            new_ip = REL26(instr) + (int)real_ip;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            break;

        case I_BR_N:
            if (delayed_p) {
                error("ss_remote: br.n instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating br.n instr.\n");
            }
            new_ip = real_ip + 4;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            delayed_p = (u_long *)1;
            delayed_ip = REL26(instr) + real_ip;
            remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
            break;

        case I_BB:
            if (delayed_p) {
                error("ss_remote: bb? instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote: simulating bb? instr.\n");
            }
            /*
             * Exclusive-or the "this-is-a-bb1-instruction" bit with
             * the selected bit in the register designated in the instruction
             * that we are simulating.
             */
            if (((instr >> 27) & 1) ==
                  ((remote_read_register(S1(instr)) >> B5(instr)) & 1)) {
              new_ip = REL16(instr) + (int)real_ip;
            } else {
              new_ip = real_ip + 4;
            }
             /*
              * Make the sxip, snip, and sfip look reasonable.  After
              * the single-step they are pointing at instructions in
              * the ROM.
              */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            break;

        case I_BB_N:
            if (delayed_p) {
                error("ss_remote: bb?.n instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating bb?.n instr.\n");
            }
            new_ip = real_ip + 4;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);

            /*
             * Exclusive-or the "this-is-a-bb1-instruction" bit with
             * the selected bit in the register designated in the instruction
             * that we are simulating.
             */
            if (((instr >> 27) & 1) ==
                  ((remote_read_register(S1(instr)) >> B5(instr)) & 1)) {
              delayed_p = (u_long *)1;
              delayed_ip = REL16(instr) + real_ip;
              remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
            } else {
              new_ip = real_ip + 4;
              remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            }
            break;

        case I_CBRANCH:
            if (delayed_p) {
                error("ss_remote: bcnd instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote: simulating bcnd instruction\n");
            }
            {
              int m5 = M5(instr);
              int r = remote_read_register(S1(instr));
              int index_into_m5 = (((r >> 31) & 1) << 1) | 
                                   ((r & 0x7fffffff) == 0);
              if ((m5 >> index_into_m5) & 1) {
                new_ip = REL16(instr) + (int)real_ip;
              } else {
                new_ip = real_ip + 4;
              }
            }
             /*
              * Make the sxip, snip, and sfip look reasonable.  After
              * the single-step they are pointing at instructions in
              * the ROM.
              */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            break;

        case I_CBRANCH_N:
            if (delayed_p) {
                error("ss_remote: bcnd.n instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating bcnd.n instruction\n");
            }
            new_ip = real_ip + 4;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            {
              int m5 = M5(instr);
              int r = remote_read_register(S1(instr));
              int index_into_m5 = (((r >> 31) & 1) << 1) | 
                                   ((r & 0x7fffffff) == 0);
              if ((m5 >> index_into_m5) & 1) {
                delayed_p = (u_long *)1;
                delayed_ip = REL16(instr) + real_ip;
                remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
              } else {
                new_ip = real_ip + 4;
                remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
              }
            }
            break;

        case I_BSR:
            if (delayed_p) {
                error("ss_remote: bsr in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote: simulating bsr instr.\n");
            }
            remote_write_register(R1_REGNUM, real_ip + 4);
            new_ip = REL26(instr) + (int)real_ip;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            break;

        case I_BSR_N:
            if (delayed_p) {
                error("ss_remote: bsr.n instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating bsr.n instr.\n");
            }
            delayed_p = (u_long *)1;
            delayed_ip = REL26(instr) + real_ip;
            remote_write_register(R1_REGNUM, real_ip + 8);
            new_ip = real_ip + 4;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
            break;

        case I_JMP:
            if (delayed_p) {
                error("ss_remote: jmp instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating normal jmp instr.\n");
            }
            new_ip = remote_read_register(S2(instr));
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            break;

        case I_JMP_N:
            if (delayed_p) {
                error("ss_remote: jmp.n instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating jmp.n instr.\n");
            }

            new_ip = real_ip + 4;
            delayed_ip = remote_read_register(S2(instr));
            delayed_p = (u_long *)1;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
            break;

        case I_JSR:
            if (delayed_p) {
                error("ss_remote: jsr instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating normal jsr instr.\n");
            }
            new_ip = remote_read_register(S2(instr));
            remote_write_register(R1_REGNUM, real_ip + 4);
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | IP_VALID);
            break;

        case I_JSR_N:
            if (delayed_p) {
                error("ss_remote: jsr.n instruction in delay slot");
            }
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote simulating jsr.n instr.\n");
            }

            new_ip = real_ip + 4;
            remote_write_register(R1_REGNUM, real_ip + 8);
            delayed_ip = remote_read_register(S2(instr));
            delayed_p = (u_long *)1;
            /*
             * Make the shadow ip's look like they would on the
             * real machine if the real machine had hit a breakpoint here.
             */
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
            break;

        case I_TRAP_NOT_TAKEN:
            /*
             * We know that this won't really trap, just advance the pc.
             */
            if (varvalue("traceremote")) {
                ui_fprintf(stderr, "ss_remote: tb0 or tb1 that won't trap\n");
            }
            new_ip = real_ip + 4;
            remote_write_register(SXIP_REGNUM, real_ip | IP_VALID);
            remote_write_register(SNIP_REGNUM, new_ip | IP_VALID);
            remote_write_register(SFIP_REGNUM, delayed_ip + 4 | IP_VALID);
            break;

        case I_TRAP:
            ui_badnews(-1, 
           "Can't single-step this instruction (tb0, tb1, tcnd, tbnd, or rte)");
             break;

        default:
            ui_fprintf(stderr, "ss_remote: case error at 0x%x\n", real_ip);
            break;
    }
    stop_cause = SIGTRAP;
    if (nmiing_remote) {
        error("Remote stopped after single-stepping");
    }
}

/*
 * See if we stopped in a branch delay slot.  If so, set 'delayed_p'
 * to a non-zero value and set 'delayed_ip' to the delayed-branch 
 * target.
 */
static void check_for_delay_slot_after_breakpoint()
{
    u_long sxip = remote_read_register(SXIP_REGNUM);
    u_long snip = remote_read_register(SNIP_REGNUM);
    /*
     * Since we the last instruction that was executed was
     * a trap, the SXIP_REGNUM should be valid with no exception
     * pending.
     */
    if ((sxip & (IP_VALID|IP_EXCEPTION)) != IP_VALID) {
        ui_fprintf(stderr, "Warning: sxip=0x%x\n", sxip);
    }
    sxip &= ~(IP_VALID|IP_EXCEPTION);
    /*
     * Test to see if we hit a breakpoint in a branch delay
     * slot by comparing the sxip and the snip.
     */
    if ((snip & (IP_VALID|IP_EXCEPTION)) == IP_VALID) {
        snip &= ~(IP_VALID|IP_EXCEPTION);
        if (sxip != snip - 4) {
            delayed_p = (u_long *)1;
            delayed_ip = snip;
        } else {
            delayed_p = (u_long *)0;
        }
    }
}

/*
 * See if we stopped in a branch delay slot.  If so, set 'delayed_p'
 * to a non-zero value and set 'delayed_ip' to the delayed-branch 
 * target.
 */
static void check_for_delay_slot_after_interrupt()
{
    u_long snip = remote_read_register(SNIP_REGNUM);
    u_long sfip = remote_read_register(SFIP_REGNUM);

    /*
     * Test to see if we hit a breakpoint in a branch delay
     * slot by comparing the snip and the sfip to see if they
     * are adjacent.
     */
    if ((snip & (IP_VALID|IP_EXCEPTION)) == IP_VALID &&
	(sfip & (IP_VALID|IP_EXCEPTION)) == IP_VALID) {
        snip &= ~(IP_VALID|IP_EXCEPTION);
        sfip &= ~(IP_VALID|IP_EXCEPTION);
        if (snip != sfip - 4) {
            delayed_p = (u_long *)1;
            delayed_ip = sfip;
        } 
    }
}

kludge_pc()
{
  remote_write_register(SNIP_REGNUM, remote_read_register(SXIP_REGNUM));
  remote_write_register(SFIP_REGNUM, remote_read_register(SXIP_REGNUM)+4);
}

/*
 * Let the processor run until it hits a breakpoint.
 */
static int go_remote()
{
#ifdef NOT_DEF /* We don't want to do this with gdb, right? */
    /*
     * If we are stopped in a branch delay slot, point the snip
     * at the instruction in the branch delay slot and the sfip
     * at the delayed-branch target.
     *
     * Otherwise mark the snip invalid (with a zero) and point
     * the sfip at the instruction to execute.
     */
    if (delayed_p) {
        delayed_p = 0;
        remote_write_register(SFIP_REGNUM, delayed_ip | IP_VALID);
    } else {
        remote_write_register(SNIP_REGNUM, 0);
    }
#endif

    if (varvalue("traceremote")) {
      ui_fprintf(stderr, "Starting target with snip=0x%x sfip=0x%x\n",
                         remote_read_register(SNIP_REGNUM), 
                         remote_read_register(SFIP_REGNUM));
    }
    invalidate_mem_cache();
    init_checksum();
    splhi();
    send_command(C_GO);
    send_command(C_END);
    send_checksum();
    if (wait_for_token(C_ACK, C_NONE, ta_warning, 1) != C_ACK) {
        ui_fprintf(stderr, "Didn't find C_ACK in go_remote\n");
    } else {
        target_running = true;
        if (varvalue("exitaftercontinue")) {
            ui_fprintf(stderr, "Target left running ..\n");
            exit(0);
        }
        spllo();
        if (setjmp(controlc_env)) {
          return CAUGHT_EXCEPTION;
        }

        if (wait_for_exception(TR_BPT, ta_none, 5)) {
            if (varvalue("traceremote")) {
                ui_fprintf(stderr,
                          "After breakpoint, sxip=0x%x snip=0x%x sfip=0x%x\n",
                       remote_read_register(SXIP_REGNUM), 
                       remote_read_register(SNIP_REGNUM), 
                       remote_read_register(SFIP_REGNUM));
            }
            check_for_delay_slot_after_breakpoint();
            kludge_pc();
            stop_cause = SIGTRAP;
            return CAUGHT_BREAKPOINT;
        } 
    }
    spllo();
    return CAUGHT_EXCEPTION;
}

u_long data_cmmu_address;

/*
 * This finds a working CMMU and puts its base address in data_cmmu_address.
 */
static void findcmmu()
{
  int i;

  if (data_cmmu_address != 0) {
      return;
  }
  if (varvalue("motomode")) {
    data_cmmu_address = 0xfff6f000;
    return;
  }

  for (i = 0 ; i < 4 ; i++) {
    u_long sapr_address = 0xfff00000 + (i * PAGESIZE) + 0x200;
    u_long sapr = read_remote_w(sapr_address, M_SUPERVISOR);
    if (sapr != sapr_address) {
      data_cmmu_address = 0xfff00000 + (i * PAGESIZE);
      return;
    }
  }
  error("findcmmu(): couldn't find a working CMMU");
}

/* This is the cross-debugger's routine to translate kernel virtual
   addresses to physical addresses.  */
static boolean remote_v_to_p(addr, pa_ptr, usmode)
    u_long *pa_ptr;
    u_long addr;
    int    usmode;
{
    u_long  system_status_register;
    u_long  area_pointer = read_remote_w(data_cmmu_address + 
                                      (usmode ? 0x204 : 0x200), M_SUPERVISOR);
    findcmmu();
    if ((area_pointer & 1) == 0) {
        *pa_ptr = addr;
        return false;
    }

    /* Write the system address register of one of the data
       CMMU's with the address that we want to translate.  */
    write_remote_w(data_cmmu_address + 0xc, addr, M_SUPERVISOR);

    /* Write the system command register of one of the data
       CMMU's with the probe-user command.  */
    write_remote_w(data_cmmu_address + 4, 
                   (usmode == M_USER) ? 0x20 : 0x24, M_SUPERVISOR);

    /* Test the valid bit of the system status register to
       make sure that the translation was valid.  */
    system_status_register = read_remote_w(data_cmmu_address + 8, M_SUPERVISOR);
    if ((system_status_register & 1) == 0) {
        return true;
    }
    *pa_ptr = read_remote_w(data_cmmu_address + 0xc, M_SUPERVISOR);
    return false;
}

/* List of names of bits in the 88200's system status register.  */
char *ssr_fieldlist[] = {
    "valid",                 /* bit 0 */
    "batc",                  /* bit 1 */
    "write protected",       /* bit 2 */
    "used",                  /* bit 3 */
    "modified",              /* bit 4 */
    "",                      /* bit 5 */
    "cache inhibit",         /* bit 6 */
    "global",                /* bit 7 */
    "supervisor only",       /* bit 8 */
    "write through",         /* bit 9 */
    "", "", "", "",          /* bit 10 through 13 */
    "bus error" };           /* bit 14 */

/* Print the system status register.  */
static void print_ssr()
{
    int i;
    u_long system_status_register;

    findcmmu();

    system_status_register = read_remote_w(data_cmmu_address + 8, M_SUPERVISOR);

    ui_fprintf(stderr, "ssr: 0x%08X ", system_status_register);
    for (i = 0 ; i < sizeof(ssr_fieldlist)/sizeof(char *) ; i++) {
        if (system_status_register & (1 << i)) {
            ui_fprintf(stderr, "<%s>", ssr_fieldlist[i]);
        }
    }
    ui_fprintf(stderr, "\n");
}

char *apr_fieldlist[] = {
    "translation enable",    /* bit 0 */
    "",                      /* bit 1 */
    "",                      /* bit 2 */
    "",                      /* bit 3 */
    "",                      /* bit 4 */
    "",                      /* bit 5 */
    "cache inhibit",         /* bit 6 */
    "global",                /* bit 7 */
    "",                      /* bit 8 */
    "write through"          /* bit 9 */
};

static void print_apr()
{
    int i;
    u_long area_pointer;

    findcmmu();
    ui_fprintf(stderr, "supervisor area pointer: 0x%08X ", 
                      read_remote_w(data_cmmu_address + 0x200, M_SUPERVISOR));
    for (i = 0 ; i < sizeof(apr_fieldlist)/sizeof(char *) ; i++) {
        if (area_pointer & (1 << i)) {
            ui_fprintf(stderr, "<%s>", apr_fieldlist[i]);
        }
    }
    ui_fprintf(stderr, "\n");

    ui_fprintf(stderr, "user area pointer: 0x%08X ", 
                    read_remote_w(data_cmmu_address + 0x204, M_SUPERVISOR));
    for (i = 0 ; i < sizeof(apr_fieldlist)/sizeof(char *) ; i++) {
        if (area_pointer & (1 << i)) {
            ui_fprintf(stderr, "<%s>", apr_fieldlist[i]);
        }
    }
    ui_fprintf(stderr, "\n");
}

static void print_pfar()
{
    u_long pbus_fault_address_register;

    findcmmu();
    pbus_fault_address_register = 
                       read_remote_w(data_cmmu_address + 0x10c, M_SUPERVISOR);
    ui_fprintf(stderr, "Physical address of last pde or sde fetched: 0x%x\n", 
                                                  pbus_fault_address_register);
}

/* Called to probe kernel and user virtual addresses */
static void do_probe_command(exp, from_tty, usmode)
  char *exp;
{
  CORE_ADDR address_to_probe, physical_address;

  if (!exp) {
    ui_badnews(-1, "usage: probe <addr>");
  }
  address_to_probe = parse_and_eval_address (exp);
  if (remote_v_to_p(address_to_probe, &physical_address, usmode)) {
    ui_fprintf(stderr, "No translation of 0x%x\n", address_to_probe);
    print_apr();
    print_pfar();
  } else {
    ui_fprintf(stdout, "physical address: 0x%08X\n", physical_address);
    print_ssr();
  }
}

/* Tell the user what physical address a given virtual address maps to. */
static void probe_command(exp, from_tty)
  char *exp;
{
  do_probe_command(exp, from_tty, M_SUPERVISOR);
}

/* Tell the user what physical address a given virtual address maps to. */
static void uprobe_command(exp, from_tty)
  char *exp;
{
  do_probe_command(exp, from_tty, M_USER);
}

/*
 * Returns true if the passed address is in ROM, false otherwise
 */
static boolean in_rom(addr)
    u_long addr;
{
  if (varvalue("motomode")) {
    return (0xffc00000 <= addr && addr <= 0xffc7ffff);
  } else {
    return (0xfe000000 <= addr && addr <= 0xfe03ffff);
  }
}

/*
 * Returns true if the passed address is in static RAM, false otherwise
 */
static boolean in_sram(addr)
    u_long addr;
{
  if (varvalue("motomode")) {
    return (0xffe00000 <= addr && addr <= 0xffe1ffff);
  } else {
    return false;
  }
}

static char *reg_name[] = {
 "$r0",    "$r1",    "$r2",    "$r3",    "$r4",    "$r5",    "$r6",    "$r7", 
 "$r8",    "$r9",    "$r10",   "$r11",   "$r12",   "$r13",   "$r14",   "$r15", 
 "$r16",   "$r17",   "$r18",   "$r19",   "$r20",   "$r21",   "$r22",   "$r23", 
 "$r24",   "$r25",   "$r26",   "$r27",   "$r28",   "$r29",   "$r30",   "$r31", 

 "$ip",    "$pid",   "$psr",   "$epsr",  "$ssbr",  "$sxip",  "$snip",  "$sfip", 

 "$vbr",   "$dmt0",  "$dmd0",  "$dma0",  "$dmt1",  "$dmd1",  "$dma1", "$dmt2",
 "$dmd2",  "$dma2",  "$sr0",   "$sr1",   "$sr2",   "$sr3",   
 "$fpecr", "$fphs1", "$fpls1", "$fphs2", "$fpls2", "$fppt",  "$fprh",  "$fprl",
 "$fpit",  "$fpsr",  "$fpcr", 
 "$ceimr", "$comefrom", "$membrk", "$stackbase", "$ramsize"};

/*
 * Returns the register name for the passed register number.
 */
static char *regname(n)
    unsigned n;
{
    char *s;
    if (n < sizeof(reg_name)/sizeof(char *)) {
        s = reg_name[n];
        if (s == nil) {
            s = "invalid-register-number";
        }
    } else {
        s = "out-of-range-register-number";
    }
    return s;
}

void
_initialize_remote()
{
  add_com("dl", class_run, download_command,
     "Download text and data to target.");
  add_com("checkdl", class_run, checkdl_command,
     "Check downloaded text and data in target match host copy.");
  add_com("bzero", class_run, bzero_command,
     "Zero a block of target memory, usage: bzero <address> <length>");
  add_com("bcopy", class_run, bcopy_command,
     "Copy a block of target memory, usage: bcopy <saddr> <daddr> <length>");
  add_com("flush", class_run, flush_command,
     "Flush the host cache of target memory and target comm buffer.");
  add_com("init", class_run, init_command, "Reset the target.");
  add_com("probe", class_run, probe_command, 
     "Translate a kernel virtual address to a physical address.");
  add_com("uprobe", class_run, uprobe_command, 
     "Translate a user virtual address to a physical address.");
  add_com("regs", class_run, regs_command, "Print the registers.");
  add_com("rb", class_run, readbyte_command,
     "Read a single byte from the target memory.");
  add_com("rh", class_run, readhalf_command,
     "Read a single halfword from the target memory.");
  add_com("rw", class_run, readword_command,
     "Read a single word from the target memory.");
  add_com("sw", class_run, searchword_command,
"Search target memory for a word pattern, usage: sw <addr> <length> <pattern>.");
  add_com("wb", class_run, writebyte_command,
     "Write a single byte to the target memory.");
  add_com("wh", class_run, writehalf_command,
     "Write a single halfword to the target memory.");
  add_com("ww", class_run, writeword_command,
     "Write a single word from the target memory.");

@


1.21
log
@Added support for Motorola 188's as targets.
Numereous fixes, simplifications.  Turning on/off of SIGINT
is better and simpler.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.20 90/03/29 15:46:55 robertb Exp $
   $Locker: robertb $
a49 1
#include "wait.h"
d51 1
a52 1
#define	TARGET_IS_88K
a75 1
boolean vaddrs;
a81 42
enum timeout_action { ta_none, ta_warning, ta_longjmp };

#define	C_RESET			(0x81)
#define	C_NMI			(0x82)

#define	COMMAND_PREFIX1	(0x83)
#define	COMMAND_PREFIX2	(0x84)

/*
 * Commands that the host sends to the monitor.
 */
#define C_NONE			(-1)
#define	C_DOWNLOAD		(0x91)
#define	C_UPLOAD		(0x92)
#define	C_CHECKSUM		(0x93)
#define	C_END			(0x94)
#define	C_GO			(0x95)

#define	C_DATASTART		(0x96)
#define	C_CHECKSUMERR		(0x97)
#define	C_ACK			(0x98)
#define	C_DATAEND		(0x99)
#define	C_FILL			(0x9a)
#define	C_RETPTRS		(0x9b)
#define	C_EXCEPTION		(0x9c)
#define	C_DBWRITE		(0x9d)
#define	C_DBREAD		(0x9e)
#define C_SYNC			(0x9f)
#define C_DATAERROR		(0xa0)
#define C_UPLOADNOINIT		(0xa1)
#define C_CHECKSUMNOINIT	(0xa2)
#define C_SEARCH		(0xa3) 
#define C_COPYMEM		(0xa4)
#define C_UPLOADUSER		(0xa5)
#define C_UPLOADNOINITUSER	(0xa6)
#define C_DOWNLOADUSER		(0xa7)
#define C_EXPECTEDTOKEN		(0xa8)
#define C_COMMERR		(0xa9)
#define	C_COMPRESSERR		(0xaa)
#define	C_BADCOMMAND		(0xab)
#define C_188SYSCALL		(0xac)

a94 17
static void send_word();
static void send_short();
static void send_byte();

static unsigned get_char();
static unsigned get_byte();
static unsigned get_word();

static void init_checksum();
static void verify_checksum();
static void send_checksum();
static void send_command();

extern u_char get_remote_char();
static void put_remote_char();
static void flush_out_buff();
static void init_out_buff();
a96 4
static void pass_command();
static void do_pass_command();
static boolean passthroughmode;
static void setbaud();
a104 1
static jmp_buf timeout_env;
d109 1
a109 1
static u_long last_iword;
d115 4
a118 4
u_long checksum;
u_long checksumming;
u_long partial;
u_long partial_length;
d136 1
a136 1
static void decode_instr_before_stepping();
a142 1
static void invalidate_mem_cache();
a152 1
static void setvar();
d202 1
a202 1
static char remote_tty_name[200];
d204 2
a205 2
static int remote_fd = -1;	/* Force ioctl errors if not initialized */
static int current_baud;
a228 2
void splhi();
void spllo();
d286 1
a286 1
static boolean
a338 877
/* The next 768 or so lines supports communication with the Motorola 188BUG
   monitor.  There is a small amount code for this support in other places
   in this file.  */

static void wait_for_remote_string();
static void send_remote_string();
static unsigned long download_or_checksum_monitor();
static boolean waiting_for_echoed_character;
static boolean verbose;			/* Print lots of info in pass mode   */
static boolean terminal_mode_altered;	/* True if we've diddled the terminal*/
static struct termio old_terminal_mode;
static struct termio old_remote_mode;
static int terminal_fd = 0;		/* We do ioctl's on this             */
static jmp_buf int_env;                 /* longjmp on this on SIGINT sometimes*/
static jmp_buf pass_env;		/* longjmp on this to bale out of pass*/
static boolean show_target_output_mode;
static long monitor_start_addr;
static long monitor_end_addr;		/* monitor_start_addr + monitor_length*/
static long monitor_length;		/* Gotten from COFF file with monitor*/
static char *mfname1 = "tek188mon";	/* COFF file with monitor text+data  */
static char *mfname2 = "/UTek/tools/lib/tek188mon";
#define	BUG_RETURN	(0x63)		/* Return to 188BUG 'syscall' code   */

/* This does a BUG188 system call.  */
static unsigned long 
remote_188syscall(code, arg1, arg2, arg3, arg4, timeout_action, timeout)
    unsigned long code, arg1, arg2, arg3, arg4, timeout;
    enum timeout_action timeout_action;
{
    unsigned long return_val;
    splhi();

    invalidate_mem_cache();
    init_checksum();
    send_command(C_188SYSCALL);
    send_word(code);
    send_word(arg1);
    send_word(arg2);
    send_word(arg3);
    send_word(arg4);
    if (varvalue("traceremote")) {
        ui_fprintf(stderr, 
    "Doing 188BUG syscall code=0x%x arg1=0x%x arg2=0x%x arg3=0x%x arg4=0x%x\n", 
                         code, arg1, arg2, arg3, arg4);
    }
    send_command(C_END);
    send_checksum();
    if (wait_for_token(C_ACK, C_NONE, ta_warning, 2) !=C_ACK) {
        spllo();
        error("Didn't find C_ACK in remote_188syscall");
    }
    spllo();
    if (code == BUG_RETURN) {
      do_pass_command("", true, true);
    }
    init_checksum();
    switch (wait_for_token(C_DATASTART, C_DATAERROR, timeout_action, timeout)) {
        case C_DATASTART:
            return_val = get_word();
            if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
                error("Didn't find C_DATAEND in remote_188syscall");
            }
            verify_checksum();
            break;

        case C_DATAERROR:
            error("DACC while doing 188BUG syscall");
            break;

        default:
            error("Didn't get C_DATASTART from target");
            break;
    }

    return return_val; 
}

/* Turn off echoing of characters typed at the terminal. */
static void init_terminal_mode()
{
  struct termio t;
 
  if (ioctl(terminal_fd, TCGETA, &t) < 0) {
    ui_fprintf(stderr, "init_terminal_mode: Error in TCSETA ioctl");
  }
  t.c_iflag &= ~(INLCR|IGNCR|ICRNL);

  /* Turn off echoing of characters on the terminal.  The target will
     echo the characters and we display everyting that the target
     sends to us. */

  t.c_lflag &= ~(ECHO|ECHOE|ICANON|ECHOK|ECHONL|XCASE);
  t.c_lflag |= ISIG;

  t.c_cc[VMIN] = 0;
  t.c_cc[VTIME] = 1;	/* Tenth's of seconds to wait for chars */
  
  if (ioctl(terminal_fd, TCSETA, &t) < 0) {
    ui_badnews(-1, "init_terminal_mode: Error in TCSETA ioctl with terminal");
  }
  terminal_mode_altered = true;
}

/* Restore the terminal mode to be the way it was
   when we entered do_pass_command().  */
static void restore_terminal_mode()
{
  if (!terminal_mode_altered) {
    return;
  }
  if (ioctl(terminal_fd, TCSETA, &old_terminal_mode) < 0) {
    fatal("restore_terminal_mode: Error in TCSETA ioctl");
  }
  terminal_mode_altered = false;
}

/* Restore the remote tty mode to be the way it was
   when we entered do_pass_command().  */
static void restore_remote_mode()
{
  if (ioctl(remote_fd, TCSETA, &old_remote_mode) < 0) {
    fatal("restore_remote_mode: Error in TCSETA ioctl");
  }
}

/* Return true if the checksum of the text segment of the file mfname1 
   or mfname2 matches the checksum of the string of words of the same length at
   address 'monitor_start_addr' in the target's memory. */
static boolean monitor_checksum_matches()
{
  unsigned cs;
  char c, buf[20];
  int i;

  cs = download_or_checksum_monitor(mfname1, 
                                    mfname2, 
                                    false, 
                                    &monitor_length, 
                                    &monitor_start_addr);
  sprintf(buf, "%0X", cs);
  if (verbose) {
    ui_fprintf(stdout, "Host checksum =%s\n", buf);
  }
  monitor_end_addr = monitor_start_addr + monitor_length;
  send_remote_string("cs %x %x\r", monitor_start_addr, monitor_end_addr);
  wait_for_remote_string("Effective address: %0X\r\n", monitor_start_addr);
  wait_for_remote_string("Effective address: %0X\r\n", monitor_end_addr - 1);
  wait_for_remote_string("Checksum: ");
  for (i = 0 ; i < 8 ;i++) {
    c = get_remote_char(ta_none, 1);
    if (verbose)
      ui_putc(c, stdout);
    if (c != buf[i]) {
      return false;
    }
  }
  return true;
}

/* Do the "*w" command (of pass-through mode).  Warm-start the Tektronix
   debug monitor.  We send a control-X to clear 188BUG's command line
   buffer in case there are already some characters in it. */
static void pass_warm_start_cmd()
{
  if (!monitor_checksum_matches()) {
    ui_fprintf(stdout, "Monitor checksum doesn't match, can't warm-start\n");
    return;
  }
  passthroughmode = false;
  send_remote_string("g %0x\r", monitor_start_addr + 4);
  wait_for_remote_string("Effective address: %0X\r\n", monitor_start_addr + 4);
  ui_fprintf(stdout, "All general register values except r9's copied to\n");
  ui_fprintf(stdout, "Tektronix monitor register image.\n");
}

/* Handle SIGINT while in do_pass_command().  */
static void pass_siginthandler()
{
  if (resetting_remote) {
    passthroughmode = false;
    spllo();
    longjmp(timeout_env, 1);
  }
  spllo();
  if (waiting_for_echoed_character) {
    waiting_for_echoed_character = false;
    longjmp(int_env, 1);
  } else {
    if (passthroughmode) {
      char c, buf[2];

      passthroughmode = false;
      restore_terminal_mode();
      c = '\0';
      while (c != 'y' && c != 'n') {
        ui_fprintf(stderr, "Attempt to warm start Tektronix debug monitor ?");
        ui_fgets(buf, sizeof buf, stdin);
        c = tolower(buf[0]);
        ui_putc('\n', stdout);
      }
      if (c == 'y') {
        pass_warm_start_cmd();
      }
    }
    /* If we didn't execute the above then clause (i.e., passthroughmode
       was false) then we must have gotten a second control-C while 
       trying unsuccessfully to warm-start the Tektronix debug monitor.  
       Just bale out of do_pass_command(). */
    longjmp(pass_env, 1);
  }
}

/* Handle SIGTSTP while in do_pass_command().  We change the action
   on SIGTSTP to be default action, i.e., process suspension.  Then
   we propogate the signal by sending it to ourselves.  This will cause
   the process to be suspended, and if we are running under the C
   shell, the user will get a C shell prompt.  When and if we are resumed
   control will be just after the call to kill() below.  We change
   the action for SIGTSTP back to be calling this function, we
   reset the terminal mode to raw, and we send a <RET> to 188BUG to
   get a fresh prompt.  */
static void pass_sigstphandler()
{
  passthroughmode = false;
  restore_terminal_mode();
  signal(SIGTSTP, SIG_DFL);
  kill(getpid(), SIGTSTP);
  signal(SIGTSTP, pass_sigstphandler);
  passthroughmode = true;
  init_terminal_mode();
  put_remote_char('\r');
}

/* Wait for the passed character to return from the remote tty line.
   Don't expect a control-X to be echoed as itself. */
static void wait_for_echoed_character(char_to_match)
  char char_to_match;
{
  char char_just_read;
  if (char_to_match == ('x' & 0x1f)) {
    return;
  }
  while (1) {
    if (resetting_remote) {
      char_just_read = (char)get_remote_char(ta_longjmp, 
                                             varvalue("resettimeout"));
      if (show_target_output_mode) {
        ui_putc(char_just_read, stdout);
        ui_fflush(stdout);
      }

      if (char_to_match == char_just_read) {
        break;
      }
    } else {
      if (setjmp(timeout_env) == 0) {
        char_just_read = (char)get_remote_char(ta_longjmp, 1);
        if (show_target_output_mode) {
          ui_putc(char_just_read, stdout);
          ui_fflush(stdout);
        }
  
        if (char_to_match == char_just_read) {
          break;
        }
      } else {
        if (isprint(char_to_match)) {
          ui_fprintf(stderr, "<Timeout waiting for %c to echo>\n", 
                                                   char_to_match);
        } else {
          ui_fprintf(stderr, "<Timeout waiting for 0x%x to echo>\n", 
                                             (unsigned char)char_to_match);
        }
        break;
      }
    }
  }
}

/* Wait for the passed string to be emitted by the target. */
static void wait_for_remote_string(fmt, a, b, c, d, e, f)
  char *fmt;
{
  char buf[1000], *p;

  sprintf(buf, fmt, a, b, c, d, e, f);
  p = buf;

  while (*p) {
    wait_for_echoed_character(*p++);
  }
}

/* Send the passed string to the target. */
static void send_remote_string(fmt, a, b, c, d, e, f)
  char *fmt;
{
  char buf[1000], *s;

  sprintf(buf, fmt, a, b, c, d, e, f);
  s = buf;
  while (*s) {
    put_remote_char(*s);
    wait_for_echoed_character(*s);
    s++;
  }
}

/* Download an 80 byte program that will read bytes from the serial line
 * and stuff them into memory.  We send the Tektronix debug monitor to
 * the target this way, it is much faster. */
static void download_monitor_boot()
{
  static char *s[] = { 
    "c622007\r",  "d003ffff\r", "c82200f\r", 
    "64c40080\r", "e846eff9\r", "64c40083\r", "e9a60005\r", "c622007\r", 
    "d003ffff\r", "c82200f\r",  "60840080\r", "2c850000\r", "60a50001\r", 
    "c3fffff3\r", ".\r",        "" };

  int i;
  unsigned long monitor_boot_addr = monitor_start_addr + 0x4000;

  send_remote_string("mm %x;n\r", monitor_boot_addr);
  send_remote_string("5c40fff8\r");

  /* This is "or.u r5,r0,hi16(monitor_start_addr)" */

  send_remote_string("5ca0%04x\r", 0xffff & (monitor_start_addr >> 16));

  /* This is "or r5,r5,lo16(monitor_start_addr)" */

  send_remote_string("58a5%04x\r", monitor_start_addr & 0xffff);

  for (i = 0 ; *s[i] ; i++) {
    send_remote_string(s[i]);
  }
  wait_for_remote_string("%s", "188-Bug>");
  send_remote_string("g %x\r", monitor_boot_addr);
  wait_for_remote_string("Effective address: %X\r\n",  monitor_boot_addr);
}

/*
 * This converts the debug monitor into a form that can be
 * fed to 188BUG.  This returns the checksum of the monitor loaded from the
 * COFF file whose file name is passed in the first argument.
 * If the second argument is true, the monitor is sent to the target.
 * The return value is the checksum of the monitor.  We use the
 * same algorithm as the 188BUG.  The word pointed to by the third
 * argument is set to the length of the monitor in bytes.
 */
#include <a.out.h>
#define TERMINAL_CHAR (0x80)  /* Tells monitor boot to jump to monitor */
static unsigned long 
download_or_checksum_monitor(filename1, 
                             filename2, 
                             download, 
                             monitor_length_p,
                             monitor_start_p)

  char *filename1, *filename2;  /* Two file names to find monitor in         */
  boolean download;		/* True => send monitor text to target       */
  int *monitor_length_p;	/* Var parameter, length of monitor in bytes */
  unsigned long *monitor_start_p; /* Var parameter, starting address of mon  */
{
  int fd;			/* File descriptor for monitor COFF file */
  unsigned char c;
  int i, not_at_text_yet;
  struct filehdr filehdr;	/* COFF file header structure for monitor */
  struct scnhdr scnhdr;		/* COFF section header structure for mon  */
  unsigned long checksum = 0;	/* Checksum of monitor text section       */
  unsigned long w, lower_half, lower_carry, upper_half, upper_carry;
  char *filename = filename1;	/* Name of monitor COFF file              */

  fd = open(filename1, O_RDONLY);
  if (fd <= 0) {
    fd = open(filename2, O_RDONLY);
    filename = filename2;
  }
  if (fd > 0) {
    if(read(fd, &filehdr, sizeof filehdr) != sizeof filehdr) {
      ui_badnews(-1, "Unable to read %s", filename);
    }
    if (filehdr.f_magic != MC88MAGIC) {
      ui_badnews(-1, "%s is not an 88000 coff file", filename);
    }
    if (!(filehdr.f_flags & F_EXEC)) {
      ui_badnews(-1, "%s is not executable, check for unresolved symbols",
                       filename);
    }
    lseek(fd, filehdr.f_opthdr, 1); /* Skip the optional header */
    not_at_text_yet = 1;
    while (not_at_text_yet) {
      if (read(fd, &scnhdr, sizeof scnhdr) != sizeof scnhdr) {
        ui_badnews(-1, "Error reading section header");
      }
      not_at_text_yet = !(scnhdr.s_flags & STYP_TEXT);
    }
    lseek(fd, scnhdr.s_scnptr, 0); /* Seek to start of raw section */
    if (monitor_length_p) {
      *monitor_length_p = scnhdr.s_size;
    }
    if (monitor_start_p) {
      *monitor_start_p = scnhdr.s_paddr;
    }
    for (i = 0 ; i < scnhdr.s_size ; i += sizeof w) {
      if (read(fd, &w, 4) != 4) {
        ui_badnews(-1, "Error reading 4 bytes for section '%s' of %s",
                                    scnhdr.s_name, filename);
      }
      if (download) {
        int j;

        for (j = (sizeof w) - 1 ; j >= 0 ; j--){
          c = (w >> (j*8)) & 0xff;
          if (TERMINAL_CHAR <= c && c <= COMMAND_PREFIX1) {
            put_remote_char(COMMAND_PREFIX1);
            c &= 0x7f;
          }
          put_remote_char(c);
        }
      }
      lower_half = (checksum & 0xffff) + (w & 0xffff);
      lower_carry = lower_half >> 16;
      lower_half &= 0xffff;

      upper_half = ((checksum >> 16) & 0xffff) + ((w >> 16) & 0xffff);
      upper_half += lower_carry;
      upper_carry = upper_half >> 16;
      upper_half &= 0xffff;

      checksum = (upper_half << 16) + lower_half + upper_carry;
    }
    if (download)
      put_remote_char(TERMINAL_CHAR);
  } else {
    ui_badnews(-1, "Counldn't open %s for reading", filename);
  }
  return checksum;
}

/* Tell the serial driver to do flow control.  We do this to the remote
   tty when we are talking to 188BUG. */
static void turn_on_xon_mode(fd)
  int fd;
{
  struct termio t;

  if (ioctl(fd, TCGETA, &t) < 0) {
    fatal("turn_on_xon_mode: Error in doing TCGETA ioctl");
  }

  t.c_iflag |= IXON | IXOFF | IXANY;

  if (ioctl(fd, TCSETA, &t) < 0) {
    fatal("turn_on_xon_mode: Error in doing TCSETA ioctl");
  }
}
 
/* Command to pass ascii between gdb user and 188BUG */
static void pass_command(str, from_tty)
{
  do_pass_command(str, from_tty, from_tty);
}

/* Command to return to 188BUG and pass ascii between gdb user and 188BUG */
static void bug_command(str, from_tty)
{
  ui_fprintf(stdout, "All register values except r9's copied to\n");
  ui_fprintf(stdout, "188BUG register image (copy r9 manually if you care).\n");
  remote_188syscall(BUG_RETURN, 0, 0, 0, 0, ta_warning, 1);
}

/* Send characters received from target to the gdb user and send
   characters typed by the user to the target.
  
   There are several commands that the user can do by typing an
   asterick at the start of a line followed by a command character.
   They are described in the help message (see code for case 'h' below).

   We put the terminal into raw mode and read characters with read()
   and write them with ui_putc(.., stdout) and ui_fprintf(stdout, ..).
   This may seem odd, but the formatted output of ui_fprintf is
   handy and I have to read characters asychronously (thus the need
   to call read()).

   We handle both SIGINT and SIGTSTP while executing in this function.
   We just propogate SIGTSTP after resetting the terminal and the 
   handler for SIGTSTP.  SIGINT does different things depending on
   what we are doing at the time. */

static void do_pass_command(str, from_tty, verbose_parameter)
  char *str;
  boolean from_tty;
  boolean verbose_parameter;
{
#define BUFSIZE (100)
  boolean next_char_is_command = false;
  boolean this_line_is_a_command = false;
  boolean wait_for_echo_mode = false;
  boolean file_open = false;	/* True => we are taking input from file   */
  int i;
  int arg_char_index;		/* Index into command_argument             */
  int column;			/* Used to figure if '*' is start of command*/
  char c, command_char;
  char *b, *p;
  char command_argument[BUFSIZE]; /* Argument buffer for '*s', '*W', '*b'   */
  int redirect_count;		/* # of characters read w/ last '*s' command*/
  char *fname;			/* Name of file that we are sourcing        */
  FILE *file;			/* File pointer for file we are sourcing    */

  if (!valid_baud(varvalue("kludgebaud"))) {
    setvar("kludgebaud", 38400);
  }
  if (!valid_baud(varvalue("resetbaud"))) {
    setvar("resetbaud", 9600);
  }
  if (setjmp(pass_env)) {
    passthroughmode = false;
    spllo();	/* This will reset handler to be request_quit() */
    signal(SIGTSTP, SIG_DFL);
    restore_terminal_mode();
    restore_remote_mode();
    return;
  }
  verbose = verbose_parameter;
  if (ioctl(terminal_fd, TCGETA, &old_terminal_mode) < 0) {
    ui_badnews(-1, "do_pass_command: Error in TCGETA ioctl with terminal");
  }
  if (ioctl(remote_fd, TCGETA, &old_remote_mode) < 0) {
    ui_badnews(-1, "do_pass_command: Error in TCGETA ioctl with remote");
  }
  passthroughmode = true;
  spllo();
  if (from_tty) {
    verbose = true;
    signal(SIGTSTP, pass_sigstphandler);
    init_terminal_mode(); 
  }
 
  turn_on_xon_mode(remote_fd);
  if (verbose) {
    ui_fprintf(stdout, "Connected to target on %s at %d baud\n", 
                                               remote_tty_name, current_baud);
  }
  show_target_output_mode = true;
  while (passthroughmode) {

    /* Read as many characters as we can from the target and display
       them on the terminal.  Don't echo <RET> characters from the
       target, the terminal serial driver will do it for us. */

    while (1) {
      if (!resetting_remote && setjmp(timeout_env) == 0) {
        c = get_remote_char(ta_longjmp, 0);
        if (c != '\r' && show_target_output_mode) {
          ui_putc(c, stdout);
        }
      } else {
        break;
      }
    }
    ui_fflush(stdout);

    /* Read a character from the current source file.  If we can't get a
       character there, look for one from the terminal.  */

    if (file_open) {
      c = fgetc(file);
      if (c == EOF) {
        file_open = false;
        if (verbose) {
          ui_fprintf(stdout, 
               "Finished redirecting input from %s (read %d characters).\n", 
                                                fname, redirect_count);
        }
        close(file);
      } else {
        redirect_count++;
      }
    }
    if (!file_open) {
      c = *str;
      if (c != '\0') {
        str++;
      } else {
        char buf[1];
        if (from_tty && read(terminal_fd, &buf[0], sizeof buf) > 0) {
          c = buf[0];
        } else {
          c = 0;
        }
      }
    }
    if (c != 0) {

      /* Keep track of what column this is so that we know whether an
         asterick is a command character or not. */

      if (c == '\r' || c == '\n') {
        column = 0;
      } else {
        column++;
      }

      /* If we've seen an asterik, interpret the command, otherwise send  
         the character that we just got from the terminal to the target. */
  
      if (this_line_is_a_command) {
        if (c != '\r' && c != '\n') {
          if (arg_char_index < (BUFSIZE - 1)) {
            command_argument[arg_char_index++] = c;
            command_argument[arg_char_index] = '\0';
          } else {
            ui_fprintf(stderr, "Argument buffer overflow\n");
          }
          if (verbose)
            ui_putc(c, stdout);
        } else {
          if (verbose)
            ui_fprintf(stdout, "\n");
          switch (command_char) {
            case 'b':
              b = &command_argument[0];
              while (*b && isspace(*b)) b++;
              i = atoi(b);
              if (!valid_baud(i)) {
                ui_fprintf(stderr, "%d is not a valid baud.\n", i);
              } else if (i == current_baud) {
                if (verbose)
                  ui_fprintf(stderr, 
                         "Target tty line data rate is already at %d baud.\n", 
                                                    current_baud);
              } else {
                setbaud(i);
                if (verbose)
                  ui_fprintf(stdout, "Target tty line now set at %d baud\n", 
                                 current_baud);
              }
              break;

            case 'B':
              if (ioctl(remote_fd, TCSBRK, 0) < 0) {
                ui_fprintf(stderr, 
             "Error doing TCSBRK ioctl, trying to send break to target on %s\n",
                                                            remote_tty_name);
              }
              break;
             

            case 'c':
              if (!monitor_checksum_matches()) {
                download_monitor_boot();
                (void)download_or_checksum_monitor(mfname1, mfname2, true, 0, 0);
                goto eat_it_Dijkstra;
              }
              send_remote_string("g %0x\r", monitor_start_addr);
              wait_for_remote_string("Effective address: %0X\r\n", 
                                                          monitor_start_addr);
eat_it_Dijkstra:
              passthroughmode = false;
              break;

            case 'e':
              wait_for_echo_mode = true;
              if (verbose) {
                  ui_fprintf(stdout, "Wait-for-echo on\n");
              }
              break;
  
            case 'i':
              i = current_baud;
              setbaud(varvalue("kludgebaud"));
              if (verbose) 
                ui_fprintf(stdout, "Sending interrupt character at %d baud\n", 
                                 current_baud);
              put_remote_char(C_NMI);
              put_remote_char(0);
              flush_out_buff();
              setbaud(i);
              if (verbose) 
                ui_fprintf(stdout, "Target tty line now set at %d baud\n", 
                                 current_baud);
              break;

            case 'p':
              /* Loop here waiting for characters from the target until
                 none has been recieved for a whole second. */
              while (1) {
                if (setjmp(timeout_env) == 0) {
                  c = get_remote_char(ta_longjmp, 1);
                  if (c != '\r' && show_target_output_mode) {
                    ui_putc(c, stdout);
                  }
                } else {
                  break;
                }
              }
              break;

            case 'q':
              passthroughmode = false;
              break;

            case 'r':
              setbaud(varvalue("kludgebaud"));
              if (verbose) {
                ui_fprintf(stdout, 
                        "Sending reset character at %d baud\n", current_baud);
              }
             /* Mabe if we send four reset characters instead of just one,
                the 188 board will see it every time */
              put_remote_char(C_RESET);  
              put_remote_char(C_RESET);
              put_remote_char(C_RESET);
              put_remote_char(C_RESET);
              put_remote_char(0);
              flush_out_buff();
              setbaud(varvalue("resetbaud"));
              if (verbose) 
                ui_fprintf(stdout, "Target tty line now set at %d baud\n", 
                                 current_baud);
              break;
  
            case 'h':
              ui_fprintf(stdout, "\n");
              ui_fprintf(stdout, 
              " *b rate  - make rate (currently %d) the new baud setting\n", 
                                              current_baud);
              ui_fprintf(stdout,
              " *B       - send a .25 second break to target\n");

              ui_fprintf(stdout, 
              " *c       - cold-start the Tektronix debug monitor\n");

              ui_fprintf(stdout, 
              " *e       - turn on wait-for-echo mode (currently %s)\n", 
                                            wait_for_echo_mode ? "on" : "off");
  
              ui_fprintf(stdout, 
              " *h       - print this command list\n");

              ui_fprintf(stdout, 
              " *i       - send an interrupt signal to the target at %d baud\n",
                                                      varvalue("kludgebaud"));
              ui_fprintf(stdout, 
              " *p       - pause for 1 second while waiting for target\n");

              ui_fprintf(stdout, 
              " *q       - leave pass-through-mode, return to gdb mode\n");

              ui_fprintf(stdout, 
              " *r       - send a reset signal to the target at %d baud\n",
                                                      varvalue("kludgebaud"));
              ui_fprintf(stdout,
              "            and then switch to %d baud\n", 
                                                      varvalue("resetbaud"));
              ui_fprintf(stdout, 
              " *s fname - send contents of file 'fname' to the target\n");

              ui_fprintf(stdout, 
              " *t       - toggle show-target-output mode (currently %s)\n",
                                        show_target_output_mode ? "on" : "off");

              ui_fprintf(stdout, 
              " *w       - warm-start Tek monitor, return to gdb mode\n");

              ui_fprintf(stdout, 
              " *Wstring - wait for 'string' from target\n");

              ui_fprintf(stdout, 
              " *z       - turn off wait-for-echo mode\n");
              break;

            case 's':
              fname = &command_argument[0];
              while (*fname && isspace(*fname)) fname++;
              file = fopen(fname, "r");
              if (file == 0) {
                ui_fprintf(stderr, "Couldn't open %s for reading\n", fname);
              } else {
                if (verbose)
                  ui_fprintf(stdout, "Redirecting input from %s\n", fname);
                file_open = true;
                redirect_count = 0;
              }
              break;

            case 't':
              show_target_output_mode = !show_target_output_mode;
              if (verbose)
                ui_fprintf(stdout, "Show-target-output-mode is %s\n",
                                  show_target_output_mode ? "on" : "off");
              break;

            case 'w':
              pass_warm_start_cmd();
              break;

            case 'W':
              wait_for_remote_string("%s", command_argument);
              break;

            case 'z':
              if (wait_for_echo_mode) {
                wait_for_echo_mode = false;
                ui_fprintf(stdout, "Wait-for-echo mode turned off\n");
              }
              break;

            default:
              ui_fprintf(stderr, 
                "Unknown command character '%c', type '*h' for help.\n", 
                                                                 command_char);
              break;
          }
          this_line_is_a_command = false;
        }
      } else {

        /* If the last character was an asterik in column 1, this character
           is the command character.  Save it and echo it to the terminal */

        if (next_char_is_command) {
          command_char = c;
          if (verbose)
            ui_fprintf(stdout, "%c", c);
          ui_fflush(stdout);
          arg_char_index = 0;
          next_char_is_command = false;
          this_line_is_a_command = true;
          continue;
        }

        /* If this is a command character, echo it here and don't send it
           to the target. */

        if (c == '*' && column == 1) {
          next_char_is_command = true;
          if (verbose)
            ui_fprintf(stdout, "%c", c);
        } else {
          put_remote_char(c);
          if (wait_for_echo_mode) {
            if (setjmp(int_env)) {
              if (file_open) {
                ui_fprintf(stderr, 
               "Terminating redirection of %s, (%d characters read so far).\n", 
                                           fname, redirect_count);
                ui_fprintf(stderr, "Was waiting for the echo of %c (0x%x)\n", 
                                           isprint(c) ? c : ' ', c);
                file_open = false;
                fclose(file);
              } else {
                ui_fprintf(stderr, 
         "<gdb ascii mode interrupted (was waiting for echo of %c (0x%x))>\n",
                                  isprint(c) ? c : ' ', c);
              }
              column = 0;
              next_char_is_command = false;
              this_line_is_a_command = false;
            } else {
              waiting_for_echoed_character = true;
              wait_for_echoed_character(c);
              waiting_for_echoed_character = false;
            }
          }
        }
      }
    }
    ui_fflush(stdout);
  }
  spllo();	/* This will reset handler to be request_quit() */
  signal(SIGTSTP, SIG_DFL);
  restore_terminal_mode();
  restore_remote_mode();
}

a352 1
        last_iword = 0;
d673 5
a677 1
            ui_fprintf(stderr, "%s ", commname(buf[i], prev_char));
d706 1
a706 1
static int wait_for_token(token1, token2, timeout_action, timeout)
d1026 1
a1026 5
#ifdef TARGET_IS_88K
        if (wait_for_exception(TR_INT, ta_longjmp, 5 /* seconds */)) {
#else
        if (wait_for_exception(TR_NMI, ta_longjmp, 5 /* seconds */)) {
#endif
a1030 1
#ifdef TARGET_IS_88K
a1039 1
#endif
d1166 1
a1166 1
static void setbaud(new_baud)
d1406 1
d1749 2
a1750 2
/*
 */ 
d1754 2
d1758 2
d1762 1
a1762 1
    int j, i;
d1764 7
a1770 9
    for (i = 0 ; i < 8 ; i++) {
        for (j = i ; j < i+25 ; j += 8) {
            if (i == 0 && j == 0) {
                ui_fprintf(stdout, "                   ");
            } else {
                ui_fprintf(stdout, "r%-3d 0x%08x    ", j, remote_read_register(j));
            }
        }
        ui_fprintf(stdout, "\n");
d1772 9
d1786 1
d1788 4
a1791 3
    ui_fprintf(stdout, "sxip 0x%08x    ", remote_read_register(SXIP_REGNUM));
    ui_fprintf(stdout, "snip 0x%08x    ", remote_read_register(SNIP_REGNUM));
    ui_fprintf(stdout, "sfip 0x%08x    ", remote_read_register(SFIP_REGNUM));
d1793 22
d1816 1
a1816 1

d1841 2
a1842 2
    if (text_start < 0x8000) {
      error("Text starts too low (0x%x), would overwrite debugger variables", 
d1856 1
d2080 1
a2080 1
static void setvar(varname, newvalue)
d2126 1
a2126 1
static void decode_instr_before_stepping(iword)
d2135 1
a2135 1
            ld_st_addr = remote_read_register(S1(iword)) + LIT16(iword);
d2139 2
a2140 2
            ld_st_addr = remote_read_register(S1(iword)) + 
                         remote_read_register(S2(iword));
d2151 2
a2152 2
            ld_st_addr = remote_read_register(S1(iword)) + 
                         (remote_read_register(S2(iword)) << shift);
d2174 1
a2174 1
                             r, remote_read_register(r));
d2179 1
a2179 1
                             r, remote_read_register(r), ld_st_addr);
d2184 1
a2184 1
                             r, remote_read_register(r), ld_st_addr);
a2192 1

d2276 1
a2276 1
static void send_command(command)
d2286 1
a2286 1
static void init_checksum()
d2295 1
a2295 1
static void send_checksum()
d2305 1
a2305 1
static void send_word(word)
d2324 1
a2324 1
static void send_short(s)
d2343 1
a2343 1
static void send_byte(byte)
d2370 1
a2370 1
static unsigned get_word()
d2385 1
a2385 1
static unsigned get_short()
d2395 1
a2395 1
static unsigned get_byte()
d2463 1
a2463 1
static void verify_checksum()
a2474 1

d2495 1
a2495 1
    get_monitor_addresses();
d2497 6
a2502 11
    if (n == SR3_REGNUM) {
        ui_fprintf(stderr, 
      "Warning: SR3 is modified by boot roms made after 8/15/89\n");
    }

    /*
     * The register numbering in the U-area, and thus of gdb, is
     * a different from the register numbering in the target
     * debug ROMs.  
     */
    return read_remote_w(mon_register_area_addr + 4 * regmap[n], M_SUPERVISOR);
d2980 1
a2980 1
static void put_remote_char(c)
d3010 1
a3010 1
static void flush_out_buff()
d3028 1
a3028 1
static unsigned char get_remote_char(timeout_action, timeout)
d3094 1
a3094 1
static void invalidate_mem_cache()
d3109 1
a3109 1
static void splhi()
d3117 1
a3117 1
static void spllo()
d3140 1
d3178 8
d3192 6
a3219 1
    decode_instr_before_stepping(instr);
d3548 1
a3548 1
        case I_TRAP:
d3550 1
a3550 1
             * Note that we treat trap instructions as NOP's.
d3553 1
a3553 1
                ui_fprintf(stderr, "ss_remote: treating TRAP as a NOP\n");
d3561 5
a3945 2
  add_com("bug", class_run, bug_command,
     "Return to 188BUG, the ROM monitor on the Motorola 188 board.");
a3956 2
  add_com("pass", class_run, pass_command, 
     "Pass ascii between user and target (for talking to 188BUG).");
@


1.20
log
@Fixed two declarations that were causing error messages from the 1.8.5
GH compiler.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.19 90/03/28 14:26:21 robertb Exp $
d24 1
d72 1
a79 3
FILE *consf_in;
FILE *consf_out;

a83 2

enum reset_status { reset_ok, reset_notok, reset_cantopen };
d124 1
d157 5
a171 1
static int resettimeout = 25;
a190 1

d196 1
a196 1
static boolean open_remote_tty();
a210 2
static void start_establish_remote_link();
static void finish_establish_remote_link();
d215 2
a216 2
static int reset_remote();
boolean interrupt_remote();
d219 1
a219 1
static u_long varvalue();
d246 1
a246 1
static boolean ignore_errors;
d248 2
d272 2
a273 1
static int remote_fd;
d297 2
a298 2
int splhi();
void splx();
d354 15
d378 1
a378 1
  if (remote_debugging) {
d381 3
a383 27
  add_com("dl", class_run, download_command,
     "Download text and data to target.");
  add_com("checkdl", class_run, checkdl_command,
     "Check downloaded text and data in target match host copy.");
  add_com("bzero", class_run, bzero_command,
     "Zero a block of target memory, usage: bzero <address> <length>");
  add_com("bcopy", class_run, bcopy_command,
     "Copy a block of target memory, usage: bcopy <saddr> <daddr> <length>");
  add_com("flush", class_run, flush_command,
     "Flush the host cache of target memory and target comm buffer.");
  add_com("init", class_run, init_command, "Reset the target.");
  add_com("regs", class_run, regs_command, "Print the registers.");
  add_com("rb", class_run, readbyte_command,
     "Read a single byte from the target memory.");
  add_com("rh", class_run, readhalf_command,
     "Read a single halfword from the target memory.");
  add_com("rw", class_run, readword_command,
     "Read a single word from the target memory.");
  add_com("sw", class_run, searchword_command,
"Search target memory for a word pattern, usage: sw <addr> <length> <pattern>.");
  add_com("wb", class_run, writebyte_command,
     "Write a single byte to the target memory.");
  add_com("wh", class_run, writehalf_command,
     "Write a single halfword to the target memory.");
  add_com("ww", class_run, writeword_command,
     "Write a single word from the target memory.");

d386 15
a400 2
  start_establish_remote_link(varvalue("resetonattach"));
  finish_establish_remote_link(varvalue("resetonattach"));
d409 877
d1287 2
a1288 2
remote_resume (step, signal)
     int step, signal;
d1290 3
d1389 1
a1389 1
    if (remote_fd) {
d1394 1
a1394 1
        remote_fd = 0;
d1407 1
a1407 1
                  "Target got checksum error, it expected 0x%X but got 0x%X\n",
d1418 1
a1418 1
                    "Target got communication error on receive, status=0x%X\n",
d1456 21
a1476 20
    stop_cause = 0;
    target_running = false;
    warned = false;
    downloaded = false;
    resetting_remote = false;
    nmiing_remote = false;
    ignore_errors = false;
    remote_errno = false;
    total_bytes_transmitted = 0;
    total_bytes_received = 0;
    bytes_transmitted = 0;
    bytes_received = 0;
    start_time = 0.0;
    end_time = 0.0;
    partial = 0;
    partial_length = 0;
    checksumming = 0;
    checksum = 0;
    invalidate_mem_cache();
    init_out_buff();
d1617 1
d1630 2
a1643 37
/*
 * This opens the debug line tty port and sends a reset.  We don't
 * wait for the reset exception from the target.  The code in
 * 'finish_establish_remote_link()' will do this.  This way we can
 * overlap the reading of the symbol table with the reseting of
 * the target.  Right now, it takes about 10 seconds for the target
 * to reset and Brent says that that number will grow.
 */
static void start_establish_remote_link(reset)
    boolean reset;
{
    if (reset) {
        if (reset_remote(false) != reset_ok) {
            exit(1);
        }
  
#ifdef TARGET_IS_88K
        /*
         * This is a kludge.  We want to make sure that the delayed_p
         * flag stays in sync with the target.
         */
        { 
            delayed_p = (u_long *)0; 
        }
#endif
    } else { 
        /*
         * Now we must do these two things since reset_remote()
         * normally do them for us.
         */
        initglobals();
        open_remote_tty();
        if (!interrupt_remote()) {
            error("Unable to interrupt target");
        }
    }
}
a1645 25
 * This expects that the target has been reset already by a call to
 * start_establish_remote_link().
 */
static void finish_establish_remote_link(reset)
    boolean reset;
{
    boolean success = false;

    if (reset) {
        while (!success) {
            if (setjmp(timeout_env)) {
                error("Unable to reset remote");
            } else {
                success = 
		wait_for_exception(TR_RESET, ta_longjmp, resettimeout);
            }
        }
        if (varvalue("traceremote")) {
            ui_fprintf(stderr, "Target received reset signal.\n");
        }
    }
    print_comm_statistics();
}

/*
d1721 2
a1722 4
    int s;
    u_long actual_length, length;
    boolean first_time;
    static boolean very_first_time = true;
a1725 1
        first_time = true;
d1729 8
a1736 11
                if (first_time) {
                    if (very_first_time && c == ']') {
                        ui_fprintf(stderr,
                               "Target seems to have old remote adb ROM's\n");
                    }
                    very_first_time = false;
                    ui_fprintf(stderr, 
                         "wait_for_exception: looking for P1, got instead: ");
                }
                first_time = false;
                ui_fprintf(stderr, "%s\n", commname(c, 0));
d1787 1
a1795 4
                verify_checksum();
                init_checksum();
                s = splhi();
                send_command(C_DATASTART);
d1799 4
a1802 1
                    actual_length = strlen(fgets(buf, (int)length, consf_in));
d1804 7
d1818 1
a1818 1
                splx(s);
d1834 2
a1835 1
                            putc(get_byte(), consf_out);
d1880 1
a1880 2
static int reset_remote(wait_for_reset)
    boolean wait_for_reset;
d1882 1
a1882 1
    boolean b = true;
d1884 5
a1888 3
    initglobals();
    resetting_remote = true;
    open_remote_tty();
d1890 4
a1893 12
    /*
     * The user may be reseting the target because power was
     * cycled.  If this happens, we will start getting parity errors
     * when d88 tries to access target memory unless we tell the
     * target monitor to initialize parity before reading.
     */
/*
 * Hmmm, how is this done in gdb?
    if (varvalue("noparityinit")) {
        undefvar(identname("noparityinit", true));
    }
 */
d1895 15
a1909 3
    if (setjmp(timeout_env)) {
        ui_fprintf(stderr, "Timeout trying to reset target.\n");
        b = false;
d1911 2
a1912 19
        flush_tty_line();
        invalidate_mem_cache();
        put_remote_char(C_RESET);
        /*
         * Clear the kludge board's UART read register.
         */
        put_remote_char(0);
        flush_out_buff();
        if (wait_for_reset) {
            if (wait_for_exception(TR_RESET, ta_longjmp, resettimeout)) {
                if (varvalue("traceremote")) {
                    ui_fprintf(stderr, "Target received reset signal.\n");
                }
                stop_cause = 0;
            } else {
                ui_fprintf(stdout, "Unable to reset remote\n");
                b = false;
            }
        }
d1914 13
a1926 2
    resetting_remote = false;
    return b ? reset_ok : reset_notok;
d1934 1
d1984 1
a1984 1
                          "Warning: DMU fault: DMT0=0x%X DMD0=0x%X DMA0=0x%X\n",
d2009 1
a2009 1
    int     i, s, c;
d2013 3
d2020 1
a2020 1
    s = splhi();
d2026 1
a2026 1
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 2 /* seconds */)) {
d2031 1
d2035 1
d2041 1
a2041 1
        ui_fprintf(stderr, "mon_compress_table_addr=0x%X\n", 
d2048 1
a2048 1
        ui_fprintf(stderr, "mon_register_area_addr=0x%X\n", 
d2055 1
a2055 1
        ui_fprintf(stderr, "mon_single_step_trap_addr=0x%X\n", 
d2062 1
a2062 1
        ui_fprintf(stderr, "mon_version_addr=0x%X\n", mon_version_addr);
d2076 1
a2076 1
        ui_fprintf(stderr, "mon_panic_code_addr=0x%X\n", mon_panic_code_addr);
d2098 1
a2098 2
    splx(s);
    return;
d2113 8
d2122 38
d2164 1
a2164 1
static boolean open_remote_tty()
d2166 4
a2169 4
    struct termio t;
    char *env_tty_name;
    char *getenv();
    int baud_rate_flags;
d2171 7
a2177 20
    /*
     * Determine the baud rate.
     */
    switch(varvalue("baudrate")) {
	case 50:	baud_rate_flags = B50;		break;
	case 75:	baud_rate_flags = B75;		break;
	case 110:	baud_rate_flags = B110;		break;
	case 150:	baud_rate_flags = B150;		break;
	case 200:	baud_rate_flags = B200;		break;
	case 300:	baud_rate_flags = B300;		break;
	case 600:	baud_rate_flags = B600;		break;
	case 1200:	baud_rate_flags = B1200;	break;
	case 1800:	baud_rate_flags = B1800;	break;
	case 2400:	baud_rate_flags = B2400;	break;
	case 4800:	baud_rate_flags = B4800;	break;
	case 9600:	baud_rate_flags = B9600;	break;
	case 19200:	baud_rate_flags = EXTA;		break;

        case 0:
	case 38400:	baud_rate_flags = EXTB;		break;
d2179 1
d2181 4
a2184 9
    /*
     * If we already have a tty line open, close it to conserve
     * on file descriptors.
     */
    if (remote_fd) {
        if (close(remote_fd) != 0) {
            ui_fprintf(stderr, "\nUnable to close tty line\n");
        }
    }
d2186 3
a2188 16
    /*
     * The UTek kernel does not support O_NDELAY, so we set a signal
     * handler to prevent us from waiting for ever here.
     */
    old_signalrm = signal(SIGALRM, signalrm);
    new_timerval.it_interval.tv_sec = 1; /* Just in case we miss the first sig*/
    new_timerval.it_interval.tv_usec = 0;
    new_timerval.it_value.tv_sec = 1;
    new_timerval.it_value.tv_usec = 0;
    if (setitimer(ITIMER_REAL, &new_timerval, &old_timerval) != 0) {
        error("tty_line_init: Error doing setitimer (1)");
    }
    if (setjmp(timeout_env)) {
        ui_fprintf(stderr, 
   "\nTimeout waiting to open %s, perhaps pin 4 (RTS) of the RS-232 line\n", 
                                                              remote_tty_name);
d2190 3
a2192 2
        ui_fprintf(stderr, 
   "is not asserted.   You might try tying it to pin 6 (DSR) on the\n");
d2194 1
a2194 2
        ui_fprintf(stderr,
   "host side.  DSR is always asserted on a Tek host.\n\n");
d2196 1
a2196 22
        signal(SIGALRM, old_signalrm);
        new_timerval.it_interval.tv_sec = 0;
        new_timerval.it_interval.tv_usec = 0;
        if (setitimer(ITIMER_REAL, &new_timerval, &old_timerval) != 0) {
            error("tty_line_init: Error doing setitimer (2)");
        }
        return false;
    } else {
        if ((remote_fd = open(remote_tty_name, O_RDWR | O_NDELAY)) < 0) {
            remote_fd = 0;
            ui_fprintf(stderr, "\nCannot open %s\n", remote_tty_name);
            if (errno == EWOULDBLOCK) {
                ui_fprintf(stderr, "Perhaps pin 4 of the RS-232 line (RTS)\n");
                ui_fprintf(stderr, "is not asserted (try tying it to pin 6)\n");
            }
            return false;
        }
    }
    signal(SIGALRM, old_signalrm);
    if (setitimer(ITIMER_REAL, &old_timerval, &new_timerval) != 0) {
        error("tty_line_init: Error doing setitimer (3)");
    }
d2198 5
a2202 6
    t.c_iflag = IGNBRK | IGNPAR;
    t.c_oflag = 0;
    t.c_cflag = baud_rate_flags | CS8 | CREAD;
    t.c_lflag = 0;
    t.c_line = 0;
    t.c_cc[VMIN] = 0;
d2204 5
a2208 18
    /* Tenth's of seconds to wait for chars */
    t.c_cc[VTIME] = varvalue("timeout"); 

    if (ioctl(remote_fd, TCSETA, &t) < 0) {
        ui_fprintf(stderr, 
     "\ntty_line_init: Error in doing TCSETA ioctl to %s\n", remote_tty_name);
        return false;
    }

    /*
     * Make IO with the remote device synchronous.
     */
    if (fcntl(remote_fd, F_SETFL, 0) < 0) {
        ui_fprintf(stderr, 
    "\ntty_line_init: Error doing fcntl to set flags on %s\n", remote_tty_name);
        return false;
    }
    return true;
d2246 1
a2246 1
           "Asking target for checksums on %d blocks starting at 0x%X\n",
d2251 1
a2251 1
        ui_fprintf(stderr, "Checksumming 0x%X bytes starting at 0x%X\n",
d2255 1
d2267 2
a2268 1
            error("Target was unable to checksum block at 0x%X\n", t_start);
d2271 1
d2279 1
d2282 1
d2289 1
a2289 1

d2304 1
a2304 1
                       "Uploading block %d at address 0x%X of length %d\n",
d2311 1
a2363 6
    /*
     * How is this done in gdb?
    if (newroms && !varvalue("noparityinit")) {
        defvar(identname("noparityinit", true), nil);
    }
     */
d2375 4
a2378 1
    int s = splhi();
d2393 1
d2396 1
a2396 1
    splx(s);
d2406 4
a2409 2
    int s = splhi();

d2424 1
d2427 1
a2427 1
    splx(s);
a2436 1
    int s = splhi();
d2438 4
d2451 1
d2472 1
d2479 1
d2484 1
d2488 1
a2488 1
    splx(s);
d2510 1
a2510 1
        ui_fprintf(stderr, "Total of %d bytes received\n", 
d2513 1
a2513 1
        ui_fprintf(stderr, "Total of %d bytes transmitted\n", 
d2522 2
a2523 2
            ui_fprintf(stderr, "\n");
            ui_fprintf(stderr, 
d2526 1
a2526 1
            ui_fprintf(stderr, 
d2529 1
a2529 1
            ui_fprintf(stderr, 
d2572 1
a2572 1
           "Asking target for checksums on %d blocks starting at 0x%X\n",
d2577 1
a2577 1
        ui_fprintf(stderr, "Checksumming 0x%X bytes starting at 0x%X\n",
d2581 1
d2588 1
a2588 1
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 3)) {
d2593 2
a2594 1
            error("DACC while downloading block at 0x%X", start_addr);
d2597 1
d2611 1
d2614 1
d2626 1
a2626 1

d2636 1
a2636 1
                ui_fprintf(stderr, "Downloading %d bytes to 0x%X\n",
d2642 1
d2656 2
a2657 1
                    error("DACC while writing at 0x%X", addr);
d2660 1
d2663 1
d2702 1
a2702 2
    reset_remote(true);
    setvar("noparityinit", 0);
d2721 3
a2723 1
    ui_fprintf(stdout, "ceimr 0x%08x    ", remote_read_register(CEIMR_REGNUM));
d2746 4
a2767 2
    remote_write_register(SXIP_REGNUM, (entry_point - 4) | IP_VALID);/*is this right?*/
							      /*no!! --andrew */
d2788 5
d2977 1
a2977 1
static u_long varvalue(varname) 
d3001 3
a3003 4

/*
 * This is called when the user hits control-c.
 */
d3006 1
a3006 1
  boolean tr;
d3021 3
a3023 1
  tr = target_running;
d3124 1
a3124 1
             "C_COMPPRESSERR", "C_BADCOMMAND" }; 
d3126 9
d3150 1
a3150 1
        case C_COMMERR:   case C_BADCOMMAND:                   
d3158 1
a3158 1
    sprintf(str, "0x%X", c);
d3384 1
a3384 1
		error("Checksum error, expected=0x%X received=0x%X",
d3519 1
a3519 1
            error("dwrite: error at physical address 0x%X\n", addr);
d3532 1
a3532 1
            error("dwrite: error at physical address 0x%X\n", addr);
d3542 1
a3542 1
            error("dwrite: error at physical address 0x%X\n", addr);
a3554 1
    int s;
d3557 3
d3562 1
a3562 1
        error("Reading %d bytes from 0x%X would cause a MA exception.",
d3565 1
a3565 1
    s = splhi();
d3573 1
a3573 1
        ui_fprintf(stderr, "forced_read_remote: at 0x%X, size=%d", addr, size);
d3582 1
a3582 1
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 2)) {
d3589 1
d3594 1
a3594 1
                ui_fprintf(stderr, ", target returns 0x%X\n", w);
d3597 1
d3617 1
a3617 1
    splx(s);
d3635 3
d3643 1
a3643 1
    if (addr >= 0x80000000 && !in_rom(addr)) {
d3664 1
a3664 1
        s = splhi();
d3670 1
a3670 1
            ui_fprintf(stderr, "read_remote: filling cache line, addr=0x%X\n",
d3685 1
a3685 1
        switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 2)) {
d3692 1
d3704 1
a3704 1
                    ui_fprintf(stderr, "read_remote: dacc at 0x%X\n", addr);
d3711 1
a3711 1
                error("read_remote: Didn't find C_DATASTART.");
d3714 1
d3717 1
a3717 1
        splx(s);
d3805 3
d3816 1
a3816 1
    s = splhi();
d3821 1
a3821 1
        ui_fprintf(stderr, "writing 0x%x to target at 0x%X ", w, addr);
d3847 1
a3847 1
    switch (wait_for_token(C_ACK, C_DATAERROR, ta_warning, 2)) {
d3855 2
a3856 1
            error("DACC while trying to write 0x%X", addr);
d3860 1
d3863 1
a3863 1
    splx(s);
d3955 1
a3955 1
    static u_char  prev_char;
d3963 2
a3972 1
                        sigsetmask(sigblock(0) & ~(1 << (SIGINT - 1)));
d4029 1
a4029 1
static int splhi()
d4031 1
a4031 1
    return sigblock(1 << (SIGINT - 1));
d4035 1
a4035 1
 * Restore interrupts.
d4037 1
a4037 1
static void splx(oldsig)
d4039 2
a4040 1
    sigsetmask(oldsig);
a4042 1

a4118 1
    int s;
d4123 1
a4123 1
        error("ss_remote: unable to read address 0x%X\n", real_ip);
d4137 1
a4137 1
                         remote_read_register(SFIP_REGNUM));
d4139 1
a4139 1
            s = splhi();
d4154 1
a4154 1
            if (wait_for_token(C_ACK, C_NONE, ta_warning, 2) != C_ACK) {
d4157 1
a4157 1
                success = wait_for_exception(TR_TRC, ta_warning, 2);
d4159 1
a4159 1
                    ui_fprintf(stdout, "the ip may be incorrect.\n");
d4184 1
a4184 1
            splx(s);
d4468 1
a4468 1
            ui_fprintf(stderr, "ss_remote: case error at 0x%X\n", real_ip);
d4492 1
a4492 1
        ui_fprintf(stderr, "Warning: sxip=0x%X\n", sxip);
a4546 2
    int s;

d4571 1
a4571 1
    s = splhi();
d4575 1
a4575 1
    if (wait_for_token(C_ACK, C_NONE, ta_warning, 2) != C_ACK) {
d4583 1
a4583 1
        splx(s);
d4593 2
a4594 1
                       remote_read_register(SNIP_REGNUM), remote_read_register(SFIP_REGNUM));
d4597 1
a4597 7

        /*
         * How do we do this on system V?
         *    sigsetmask(sigblock(0) & ~(1<<(SIGINT - 1))); /* reenable C-C */

    kludge_pc();

a4598 1

d4602 1
a4602 1
    splx(s);
d4613 1
a4613 1
    int i;
d4615 7
a4621 3
    if (data_cmmu_address != 0) {
        return;
    }
d4623 6
a4628 7
    for (i = 0 ; i < 4 ; i++) {
        u_long sapr_address = 0xfff00000 + (i * PAGESIZE) + 0x200;
        u_long sapr = read_remote_w(sapr_address, M_SUPERVISOR);
        if (sapr != sapr_address) {
            data_cmmu_address = 0xfff00000 + (i * PAGESIZE);
            return;
        }
d4630 2
a4631 1
    error("findcmmu(): couldn't find a working CMMU");
d4634 2
a4635 5

/*
 * This is the cross-debugger's routine to translate kernel virtual
 * addresses to physical addresses.
 */
d4650 2
a4651 4
    /*
     * Write the system address register of one of the data
     * CMMU's with the address that we want to translate.
     */
d4654 2
a4655 4
    /*
     * Write the system command register of one of the data
     * CMMU's with the probe-user command.
     */
d4659 2
a4660 4
    /*
     * Test the valid bit of the system status register to
     * make sure that the translation was valid.
     */
d4669 1
a4669 3
/*
 * List of names of bits in the 88200's system status register.
 */
d4684 2
a4685 4
/*
 * Print the system status register.
 */
void print_ssr()
d4716 1
a4716 1
void print_apr()
d4741 1
a4741 1
void print_pfar()
d4748 1
a4748 1
    ui_fprintf(stderr, "Physical address of last pde or sde fetched: 0x%X\n", 
d4752 34
d4792 3
d4796 1
d4799 13
d4842 40
@


1.19
log
@Added a parameter to a call of remote_fetch_word() to support
reading from user space.  Invalidate host cache on bzero and bcopy
commands.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.18 90/03/15 09:26:57 andrew Exp $
d279 1
a279 1
static boolean target_running;
d297 1
a297 1
static int (*old_signalrm)();
a3170 2

static boolean target_running = false;
@


1.18
log
@Changes partially to accommodate register rework.
These have not been tested and are probably incomplete.
They should be visited when support for remote gdb begins anew.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.17 90/02/07 16:05:00 andrew Exp $
   $Locker: andrew $
d463 1
a463 1
remote_fetch_word (addr)
d465 1
d467 1
a467 1
    return read_remote_w(addr, M_SUPERVISOR);
d501 1
a501 1
void remote_close()
d1562 1
d1588 2
@


1.17
log
@Minor change in watchpoint hit mechanism.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.16 90/01/02 18:01:28 robertb Exp $
a23 42


/* 
 * Changes made by Tektronix are marked by TEK_HACK, TEK_PROG_HACK, 
 * and GHSFORTRAN.
 * Changes made by Data General are marked by DG_HACK.  Compiling without these
 * #defines should be equivalent to compiling vanilla 3.2, more or less.
 *
 * The changes done by Tektronix fit into three catagories:
 *	TEK_HACK -- these were done just to get GDB to work in our environment,
 *		    including work done to support the Green Hills C compiler.
 *	TEK_PROG_HACK -- These were done to extend GDB by adding programming
 *			 support: things like if-elif-else-endif, while, and
 *			 arguments to user defined commands.
 *	GHSFORTRAN -- These changes make (will make) GDB work with the Green
 *		      Hills Fortran compiler.
 *
 *
 * In addition, I/O routines were renamed so that I/O could be directed
 * to/from the X interface if used.  See the files ui.c and ui.h for
 * more information.  Here are the routines renamed:
 *    Old name:			Renamed to:
 *	fprintf			ui_fprintf
 *	printf			ui_fprintf(stdout
 *	putchar			ui_putchar
 *	putc			ui_putc
 *	fputc			ui_putc
 *	fputs			ui_fputs
 *	puts			ui_puts
 *	gets			ui_gets
 *	fgets			ui_fgets
 *	fflush			ui_fflush
 *	system			ui_system
 *	wait			ui_wait
 *	error			ui_badnews(-1
 *	fatal			ui_badnews(1
 *	getc, fgetc		replaced with ui_gets, ui_fgets
 * These changes are not demarcated by ifdef.   
 *
 *					November 16, 1989
 */

d307 1
a307 1
char regmap[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
d310 2
a311 4
		30,31,
		35,	/* psr (really this is the tpsr) */
		63,	/* fpsr */
		64,	/* fpcr */
d313 3
d342 9
a350 1
		65};	/* ceimr */
a351 34
#define R1_REGNUM	1
#define VBR_REGNUM	39
#define DMT0_REGNUM	40
#define DMD0_REGNUM	41
#define DMA0_REGNUM	42
#define DMT1_REGNUM	43
#define DMD1_REGNUM	44
#define DMA1_REGNUM	45
#define DMT2_REGNUM	46
#define DMD2_REGNUM	47
#define DMA2_REGNUM	48
#define SR0_REGNUM	49
#define SR1_REGNUM	50
#define SR2_REGNUM	51
#define SR3_REGNUM	52
#define FPECR_REGNUM	53
#define FPHS1_REGNUM	54
#define FPLS1_REGNUM	55
#define FPHS2_REGNUM	56
#define FPLS2_REGNUM	57
#define FPPT_REGNUM	58
#define FPRH_REGNUM	59
#define FPRL_REGNUM	60
#define FPIT_REGNUM	61
#define CEIMR_REGNUM	62

/*
 * These are in the simulator only, included here for documentation
 */
#define COMEFROM_REGNUM	166	/* debug "come from" register */
#define MEMBRK_REGNUM	167	/* memory breakpoint register */
#define STACKBASE_REGNUM	168
#define RAMSIZE 69	/* (read-only) amount of memory */

d1155 2
a1156 1
		      remote_read_register(DMD0_REGNUM), remote_read_register(DMA0_REGNUM));
d1921 4
a1924 3
    remote_write_register(SXIP_REGNUM, (entry_point - 4) | 2);/*is this right?*/
    remote_write_register(SNIP_REGNUM, entry_point | 2);
    remote_write_register(SFIP_REGNUM, (entry_point + 4) | 2);
a2124 36
 * Reads 'len' bytes from the target's register area starting at byte
 * offset 'regbyte'.
 */
void remote_read_register_bytes(regbyte, myaddr, len)
    int regbyte;
    char *myaddr;
    int len;
{
  get_monitor_addresses();
  for (; len > 0 ; len--) {
    int offset = regmap[regbyte/4]*4 + regbyte%4;
    *myaddr++ = read_remote_b(mon_register_area_addr + offset, M_SUPERVISOR);
    regbyte++;
  }
}

/*
 * Write 'len' bytes from buffer pointed to by 'myaddr' to the target's
 * register area starting with byte offset 'regbyte'.
 */
void remote_write_register_bytes(regbyte, myaddr, len)
    int regbyte;
    char *myaddr;
    int len;
{
  get_monitor_addresses();
  dwrite_remote(myaddr, mon_register_area_addr + regbyte, len, M_SUPERVISOR);
  for (; len > 0 ; len--) {
    int offset = regmap[regbyte/4]*4 + regbyte%4;
    write_remote_b(mon_register_area_addr + offset, *myaddr++, M_SUPERVISOR);
    regbyte++;
  }

}

/*
d3249 1
a3249 1
    real_ip = remote_read_register(SNIP_REGNUM) & ~3;
d3274 2
a3275 1
            remote_write_register(SFIP_REGNUM, mon_single_step_trap_addr | 2);
d3308 3
a3310 3
                remote_write_register(SXIP_REGNUM, real_ip | 2);
                remote_write_register(SNIP_REGNUM, new_ip | 2);
                remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3327 3
a3329 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3344 2
a3345 2
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
d3348 1
a3348 1
            remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3374 3
a3376 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3391 2
a3392 2
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
d3403 1
a3403 1
              remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3406 1
a3406 1
              remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3433 3
a3435 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3450 2
a3451 2
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
d3460 1
a3460 1
                remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3463 1
a3463 1
                remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3481 3
a3483 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3501 3
a3503 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3518 3
a3520 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3538 3
a3540 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3556 3
a3558 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, (new_ip + 4) | 2);
d3577 3
a3579 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3590 3
a3592 3
            remote_write_register(SXIP_REGNUM, real_ip | 2);
            remote_write_register(SNIP_REGNUM, new_ip | 2);
            remote_write_register(SFIP_REGNUM, delayed_ip + 4 | 2);
d3619 1
a3619 1
    if ((sxip & 3) != 2) {
d3622 1
a3622 1
    sxip &= ~3;
d3627 2
a3628 2
    if ((snip & 3) == 2) {
        snip &= ~3;
d3653 4
a3656 3
    if ((snip & 3) == 2 && (sfip & 3) == 2) {
        snip &= ~3;
        sfip &= ~3;
d3688 1
a3688 1
        remote_write_register(SFIP_REGNUM, delayed_ip | 2);
d3912 1
a3912 1
 "$ip",    "$pid",   "$psr",   "$tpsr",  "$ssbr",  "$sxip",  "$snip",  "$sfip", 
d3914 2
a3915 2
 "$vbr",   "$dmt2",  "$dmd2",  "$dma2",  "$dmt1",  "$dmd1",  "$dma1", "$dmt0",
 "$dmd0",  "$dma0",  "$sr0",   "$sr1",   "$sr2",   "$sr3",   
d3917 2
a3918 2
 "$fpit",  "$fpsr",  "$fpcr",  "$ceimr",
 "$comefrom", "$membrk", "$stackbase", "$ramsize"};
@


1.16
log
@Many changes, control-C handling now compatible with what the
rest of gdb expects.  Symbolic printing of exception codes for
low 12 exceptions.  Made init command available after unsuccessful
attach commands.  Improved printing of information when $tracremote
is on.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.15 89/12/31 00:39:17 robertb Exp $
   $Locker:  $
a425 1
  extern kernel_support_for_watch;
a466 1
  kernel_support_for_watch = 0;
@


1.15
log
@Numerous fixes, now cross-debugging specific command work, but
problems still exist with interaction with rest of gdb.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.14 89/12/22 16:25:18 root Exp $
   $Locker: robertb $
d210 1
a431 9
  initglobals();
  strcpy(remote_tty_name, name);
  start_establish_remote_link(varvalue("resetonattach"));
  finish_establish_remote_link(varvalue("resetonattach"));
  initializing = true;
  remote_debugging = 1;
  stop_after_attach = 1;
  stop_cause = SIGTRAP;   /* What ptrace reports after attaching a process */

d459 9
d469 1
d549 5
d555 1
a555 1
    int code;
d557 5
a561 1
    ui_fprintf(stream, "%d", code);
d639 1
a853 1
        target_running = true; /* We assume that the target was left running */
d1209 1
a1209 1
        if (wait_for_exception(TR_INT, ta_longjmp, 2 /* seconds */)) {
d1211 1
a1211 1
        if (wait_for_exception(TR_NMI, ta_longjmp, 2 /* seconds */)) {
d2260 9
a2268 15
  if (remote_debugging) {
    if (resetting_remote || nmiing_remote) {
      resetting_remote = false;
      nmiing_remote = false;
      return_to_top_level();
    }
    /*
     * Attempt to interrupt the target.  If we are unable to do so,
     * do not unset the breakpoints as this will probably cause
     * more errors.  
     */
    if (interrupt_remote() == true) {
      remove_breakpoints();
      putc('\n', stdout);
    }
d2271 11
d2338 1
a2338 1
            ui_fprintf(stdout, "r%-2d=0x%-8x                  ", 
d2343 1
a2343 1
            ui_fprintf(stdout, "r%-2d=0x%-8x ld fr 0x%-8x ", 
d2348 1
a2348 1
            ui_fprintf(stdout, "r%-2d=0x%-8x st to 0x%-8x ", 
d2353 1
a2353 1
            ui_fprintf(stdout, "                                ");
d3364 6
d3692 3
d3777 2
d3793 1
d3795 5
a3799 1

d3815 4
d3822 1
a3822 1
                          "After breakpoint, sxip=0x%X snip=0x%X sfip=0x%X\n",
@


1.14
log
@Removed stub for instruction_lookup.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.13 89/12/22 16:08:17 root Exp $
   $Locker: root $
d262 1
d272 1
d281 1
a281 1
static void search_command();
d324 3
a326 1
void remote_zeromem(/* addr, length */);
d428 3
d442 2
d445 1
a445 1
     "Zero a block of target memory.");
d447 1
a447 1
     "Copy a block of target memory.");
d450 2
a451 4
  add_com("init", class_run, init_command,
     "Reset the target.");
  add_com("regs", class_run, regs_command,
     "Print the registers.");
d458 2
a459 2
  add_com("search", class_run, search_command,
     "Search target memory for a pattern under mask.");
d648 9
a656 2
static void bzero_command()
{}
d658 3
a660 2
static void bcopy_command()
{}
d662 7
a668 2
static void search_command()
{}
d670 11
d682 80
d1455 1
a1455 1
void check_remote(object_fd, t_start, t_length)
d1612 1
a1612 1
void remote_zeromem(addr, length)
d1622 2
a1623 2
    if (varvalue("tracedownload")) {
        ui_fprintf(stderr, "Zeroing memory from 0x%X to 0x%X\n", 
d1628 2
a1629 1
    if (wait_for_token(C_ACK, C_NONE, ta_warning, (int)(2+length/500000)) !=C_ACK) {
d1638 1
a1638 1
void remote_copymem(src_addr, dst_addr, length)
d1649 2
a1650 2
    if (varvalue("tracedownload")) {
        ui_fprintf(stderr, "Copying memory 0x%X - 0x%X to 0x%X\n", 
d1663 1
a1663 1
u_long remote_search(addr, length, pattern1, pattern2, mask1, mask2, stride)
d1671 1
a1671 1
        error("Mask of 0x%X, pattern of 0x%X can not match any word",
d1675 1
a1675 1
        error("Mask of 0x%X, pattern of 0x%X can not match any word", 
d1689 1
a1689 1
        ui_fprintf(stderr, "Searching memory at 0x%X\n", addr);
d1717 3
a1719 3
    ui_fprintf(stdout, "Match at 0x%08X:", search_addr);
    ui_fprintf(stdout, " 0x%08X", read_remote_w(search_addr, M_SUPERVISOR));
    ui_fprintf(stdout, " 0x%08X\n", read_remote_w(search_addr + 4, M_SUPERVISOR));
d1918 1
d1974 2
d1987 26
a2017 2
  struct expression *expr;
 
d2020 1
a2020 1
      expr = parse_c_expression(exp);
a2029 1
    next_address = (CORE_ADDR)value_as_long(evaluate_expression(expr));
a2040 2
  struct expression *expr;
 
d2043 1
a2043 1
      expr = parse_c_expression(exp);
a2052 1
    next_address = (CORE_ADDR)value_as_long(evaluate_expression(expr));
a2063 2
  struct expression *expr;
 
d2066 1
a2066 1
      expr = parse_c_expression(exp);
d2076 1
a2076 2
    next_address = (CORE_ADDR)value_as_long(evaluate_expression(expr));
    ui_fprintf("0x%08x: 0x%02x\n", next_address, 
a2086 3
  struct expression *expr;
  u_long w;
 
d2088 2
a2089 2
    if (*exp != '\0') {
      expr = parse_c_expression(exp);
d2091 3
a2093 3
     /* Cause expression not to be there any more
         if this command is repeated with Newline.
         But don't clobber a user-defined command's definition.  */
d2095 3
a2097 3
      if (from_tty) {
        *exp = '\0';
      }
d2099 12
a2110 4
    next_address = (CORE_ADDR)value_as_long(evaluate_expression(expr));
    ui_fprintf(stdout, "0x%08x: ", next_address);
    scanf("%x", &w);
    write_remote_b(next_address, w, M_SUPERVISOR);
a2119 3
  struct expression *expr;
  u_long w;
 
d2121 2
a2122 2
    if (*exp != '\0') {
      expr = parse_c_expression(exp);
d2124 3
a2126 3
     /* Cause expression not to be there any more
         if this command is repeated with Newline.
         But don't clobber a user-defined command's definition.  */
d2128 3
a2130 3
      if (from_tty) {
        *exp = '\0';
      }
d2132 12
a2143 4
    next_address = (CORE_ADDR)value_as_long(evaluate_expression(expr));
    ui_fprintf(stdout, "0x%08x: ", next_address);
    scanf("%x", &w);
    write_remote_h(next_address, w, M_SUPERVISOR);
a2152 3
  struct expression *expr;
  u_long w;
 
d2154 2
a2155 2
    if (*exp != '\0') {
      expr = parse_c_expression(exp);
d2157 3
a2159 3
     /* Cause expression not to be there any more
         if this command is repeated with Newline.
         But don't clobber a user-defined command's definition.  */
d2161 3
a2163 3
      if (from_tty) {
        *exp = '\0';
      }
d2165 12
a2176 4
    next_address = (CORE_ADDR)value_as_long(evaluate_expression(expr));
    ui_fprintf(stdout, "0x%08x: ", next_address);
    scanf("%x", &w);
    write_remote_w(next_address, w, M_SUPERVISOR);
d2229 12
@


1.13
log
@Fixed bug in stub for instruction_lookup.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.12 89/12/22 16:05:37 root Exp $
a3841 4
}
static struct instr_info *
instruction_lookup(iword)
{
@


1.12
log
@Added stub for instruction_lookup.
@
text
@d5 1
a5 1
   $Header: remote.c,v 1.11 89/12/20 19:05:43 robertb Exp $
d3844 1
a3844 1
instruction_lookup(iword);
@


1.11
log
@Many improvements, now cross-debugging is limping along.
@
text
@d5 2
a6 2
   $Header: remote.c,v 1.10 89/12/18 17:02:13 robertb Exp $
   $Locker: robertb $
d3842 4
@


1.10
log
@Added TE
Added Tek/GDB header, RCS id, changed fprintf's to ui_fprintfs, etc.
@
text
@d5 2
a6 2
   $Header: infrun.c,v 1.30 89/12/12 17:22:11 andrew Exp $
   $Locker:  $
a204 2
static int direction = 0;

d234 2
d237 1
a238 1
static u_long remote_read_register();
a248 1
static void remote_write_register();
d258 1
a258 1
static boolean interrupt_remote();
d271 3
d279 1
d318 1
a318 2
extern boolean target_running;

a319 1

a329 1
extern u_long reg_remote();
d340 39
d381 24
a404 27
#define PROGCTR_REGNUM	132
#define TPSR_REGNUM	135
#define SSBR_REGNUM	136
#define VBR_REGNUM	140
#define DMT0_REGNUM	141
#define DMD0_REGNUM	142
#define DMA0_REGNUM	143
#define DMT1_REGNUM	144
#define DMD1_REGNUM	145
#define DMA1_REGNUM	146
#define DMT2_REGNUM	147
#define DMD2_REGNUM	148
#define DMA2_REGNUM	149
#define SR0_REGNUM	150
#define SR1_REGNUM	151
#define SR2_REGNUM	152
#define SR3_REGNUM	153
#define FPECR_REGNUM	154
#define FPHS1_REGNUM	155
#define FPLS1_REGNUM	156
#define FPHS2_REGNUM	157
#define FPLS2_REGNUM	158
#define FPPT_REGNUM	159
#define FPRH_REGNUM	160
#define FPRL_REGNUM	161
#define FPIT_REGNUM	162
#define CEIMR_REGNUM	165
d421 3
d430 2
d435 6
d451 2
d459 2
a487 1
  stop_cause = SIGTRAP;
d501 1
a501 1
    regs[i] = read_remote_b(mon_register_area_addr + i);
d515 1
a515 1
        write_remote_b(mon_register_area_addr + i, regs[i]);
d526 1
a526 1
    return read_remote_w(addr);
d537 1
a537 1
    write_remote_w (addr, word);
d620 1
a620 2
    char *getenv(), *p;

d641 9
d651 9
d662 1
a662 1
void flush_tty_line()
a666 1
    int  mask = FREAD | FWRITE;
d1035 1
d1091 1
d1098 1
a1098 1
            if ((reg_remote(DMT0_REGNUM) & 1)) {
d1101 2
a1102 2
                      reg_remote(DMT0_REGNUM), 
		      reg_remote(DMD0_REGNUM), reg_remote(DMA0_REGNUM));
a1232 1
    char *baud_rate_string;
a1821 1
    ui_fprintf(stdout, "ip   0x%08x    ", remote_read_register(PROGCTR_REGNUM));
d1826 4
d1863 1
a1863 1
    remote_write_register(PROGCTR_REGNUM, entry_point);
d1893 1
a1893 1
                               forced_read_remote(next_address, sizeof(char)));
d1919 1
a1919 1
                               forced_read_remote(next_address, sizeof(short)));
d1945 1
a1945 1
                               forced_read_remote(next_address, sizeof(long)));
d1973 1
a1973 1
    write_remote_b(next_address, w);
d2001 1
a2001 1
    write_remote_h(next_address, w);
d2029 1
a2029 1
    write_remote_w(next_address, w);
a2033 47
 * Returns a register from the target.
 */
u_long remote_read_register(n)
    int n;
{
  u_long w;

  get_monitor_addresses();
  /*
   * Kludge, the PSR_REGNUM slot in the target is meaningless, so change all requests
   * for the PSR_REGNUM to requests for the TPSR_REGNUM.
   */
  if (n == PSR_REGNUM) {
    n = TPSR_REGNUM;
  }
  return read_remote_w(mon_register_area_addr + 4 * n);
}

/*
 * Puts a new value into a register in the target.
 */
void remote_write_register(n, w)
    int n;
    u_long w;
{
  get_monitor_addresses();
  /*
   * Kludge, the PSR_REGNUM slot in the target is meaningless, so change all requests
   * for the PSR_REGNUM to requests for the TPSR_REGNUM.
   */
  if (n == PSR_REGNUM) {
    n = TPSR_REGNUM;
  }
  write_remote_w(mon_register_area_addr + 4 * n, w);

  /*
   * Kludge #2, if the user updates the artificial IP, also update the
   * processor instruction pointers that matter.  The SXIP_REGNUM doesn't affect
   * future execution, so we don't change it.
   */
  if (n == PROGCTR_REGNUM) {
    remote_write_register(SNIP_REGNUM, w | 2);
    remote_write_register(SFIP_REGNUM, 0);
  }
}

/*
d2043 4
a2046 6
  /*
   * Kludge, the PSR_REGNUM slot in the target is meaningless, so change all requests
   * for the PSR_REGNUM to requests for the TPSR_REGNUM.
   */
  if (regbyte / 4 == PSR_REGNUM && len == 4) {
    regbyte = TPSR_REGNUM * 4;
a2047 5
  if (dread_remote(myaddr, 
               mon_register_area_addr + regbyte, len, M_SUPERVISOR)) {
      error("Error reading registers at register byte offset=%d len=%d\n",
                                             regbyte,len);
  }
d2060 5
a2064 6
  /*
   * Kludge, the PSR_REGNUM slot in the target is meaningless, so change all requests
   * for the PSR_REGNUM to requests for the TPSR_REGNUM.
   */
  if (regbyte / 4 == PSR_REGNUM && len == 4) {
    regbyte = TPSR_REGNUM * 4;
a2065 1
  dwrite_remote(myaddr, mon_register_area_addr + regbyte, len, M_SUPERVISOR);
a2066 11
  /*
   * Another kludge, if the user writes to the IP, also update the SNIP_REGNUM
   * and SFIP_REGNUM.
   */
  if (regbyte / 4 == PROGCTR_REGNUM && len == 4) {
    u_long buf;
    buf = *(u_long *)myaddr;
    buf |= 2;
    remote_write_register(SXIP_REGNUM, buf);
    remote_write_register(SNIP_REGNUM, 0);
  }
a2068 1

a2471 1

d2475 1
a2475 1
static u_long reg_remote(n)
a2483 9
    /*
     * Extra special kludge here.  In remote mode the psr slot in
     * the monitor register area is meaningless.  The tpsr has the
     * "user's" psr value, so we silently turn references to the
     * psr into a reference to the tpsr.  -rcb
     */
    if (n == PSR_REGNUM) {
        n = TPSR_REGNUM;
    }
d2488 1
a2488 11
     * debug ROMs.  There is an extra register, a psuedo-register
     * really, in the ROMs.  This is the artificial program counter.
     * All the registers which are only accessible in cross-debugging
     * mode, and thus are not defined in m-88k.h, have numbers
     * over 100.  Their word number in the target's register area is 
     * their register number minus 100.  The general register's
     * register numbers are the same as the word number in the target's
     * register area.  Several of the other registers, which are
     * defined in m-88k.h, have register numbers that don't map
     * so neatly to word numbers in the target's register area.  So
     * we do these by hand.
d2490 1
a2490 13
    if (n > 100) {
        n -= 100;
    } else {
        switch (n) {
            case SXIP_REGNUM: n = 36; break;
            case SNIP_REGNUM: n = 38; break;
	    case SFIP_REGNUM: n = 39; break;
            case PSR_REGNUM:  n = 34; break;
	    case FPSR_REGNUM: n = 63; break;
            case FPCR_REGNUM: n = 64; break;
        }
    }
    return read_remote_w(mon_register_area_addr + 4 * n, M_SUPERVISOR);
d2496 1
a2496 1
static void setreg_remote(n, w)
d2500 1
d2503 1
a2503 14
    /* See comment in reg_remote() */
    if (n > 100) {
        n -= 100;
    } else {
        switch (n) {
            case SXIP_REGNUM: n = 36; break;
            case SNIP_REGNUM: n = 38; break;
	    case SFIP_REGNUM: n = 39; break;
            case PSR_REGNUM:  n = 34; break;
	    case FPSR_REGNUM: n = 63; break;
            case FPCR_REGNUM: n = 64; break;
        }
    }
    write_remote_w(mon_register_area_addr + 4 * n, w, M_SUPERVISOR);
d2518 2
a2519 1
        usmode = (((reg_remote(PSR_REGNUM) >> 31) & 1) == 0) ? M_USER : M_SUPERVISOR;
d2575 1
a2575 1
        usmode = (((reg_remote(PSR_REGNUM) >> 31) & 1) == 0) ? M_USER : M_SUPERVISOR;
d2869 1
a2869 1
        usmode = (((reg_remote(PSR_REGNUM) >> 31) & 1) == 0) ? M_USER : M_SUPERVISOR;
d3177 1
a3177 1
    real_ip = reg_remote(PROGCTR_REGNUM);
d3184 1
a3184 1
            if ((reg_remote(PSR_REGNUM) & 0x80000000) == 0) {
d3196 1
a3196 2
            setreg_remote(SNIP_REGNUM, reg_remote(PROGCTR_REGNUM) | 2);
            setreg_remote(SFIP_REGNUM, mon_single_step_trap_addr | 2);
a3223 1
                setreg_remote(PROGCTR_REGNUM, new_ip);
d3229 3
a3231 3
                setreg_remote(SXIP_REGNUM, real_ip | 2);
                setreg_remote(SNIP_REGNUM, new_ip | 2);
                setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
a3243 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3248 3
a3250 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
a3260 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3265 2
a3266 2
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
d3269 1
a3269 1
            setreg_remote(SFIP_REGNUM, delayed_ip | 2);
d3285 1
a3285 1
                  ((reg_remote(S1(instr)) >> B5(instr)) & 1)) {
a3289 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3295 3
a3297 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
a3307 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3312 2
a3313 2
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
d3321 1
a3321 1
                  ((reg_remote(S1(instr)) >> B5(instr)) & 1)) {
d3324 1
a3324 1
              setreg_remote(SFIP_REGNUM, delayed_ip | 2);
d3327 1
a3327 1
              setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
d3340 1
a3340 1
              int r = reg_remote(S1(instr));
a3348 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3354 3
a3356 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
a3366 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3371 2
a3372 2
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
d3375 1
a3375 1
              int r = reg_remote(S1(instr));
d3381 1
a3381 1
                setreg_remote(SFIP_REGNUM, delayed_ip | 2);
d3384 1
a3384 1
                setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
d3396 1
a3396 2
            real_ip = reg_remote(PROGCTR_REGNUM);
            setreg_remote(R1_REGNUM, real_ip + 4);
a3397 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3402 3
a3404 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
d3416 1
a3416 1
            setreg_remote(R1_REGNUM, real_ip + 8);
a3417 1
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3422 3
a3424 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, delayed_ip | 2);
d3434 1
a3434 2
            new_ip = reg_remote(S2(instr));
            setreg_remote(PROGCTR_REGNUM, new_ip);
d3439 3
a3441 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
d3453 1
a3453 2
            setreg_remote(PROGCTR_REGNUM, new_ip);
            delayed_ip = reg_remote(S2(instr));
d3459 3
a3461 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, delayed_ip | 2);
d3471 2
a3472 3
            new_ip = reg_remote(S2(instr));
            setreg_remote(PROGCTR_REGNUM, new_ip);
            setreg_remote(R1_REGNUM, real_ip + 4);
d3477 3
a3479 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, (new_ip + 4) | 2);
d3491 2
a3492 3
            setreg_remote(PROGCTR_REGNUM, new_ip);
            setreg_remote(R1_REGNUM, real_ip + 8);
            delayed_ip = reg_remote(S2(instr));
d3498 3
a3500 3
            setreg_remote(SXIP_REGNUM, real_ip | 2);
            setreg_remote(SNIP_REGNUM, new_ip | 2);
            setreg_remote(SFIP_REGNUM, delayed_ip | 2);
a3510 1
	    setreg_remote(PROGCTR_REGNUM,new_ip);
d3517 1
d3530 2
a3531 2
    u_long sxip = reg_remote(SXIP_REGNUM);
    u_long snip = reg_remote(SNIP_REGNUM);
a3540 1
    setreg_remote(PROGCTR_REGNUM, sxip);
d3563 2
a3564 2
    u_long snip = reg_remote(SNIP_REGNUM);
    u_long sfip = reg_remote(SFIP_REGNUM);
d3581 6
d3603 1
a3603 2
        setreg_remote(SNIP_REGNUM, reg_remote(PROGCTR_REGNUM) | 2);
        setreg_remote(SFIP_REGNUM, delayed_ip | 2);
d3605 1
a3605 2
        setreg_remote(SNIP_REGNUM, 0);
        setreg_remote(SFIP_REGNUM, reg_remote(PROGCTR_REGNUM) | 2);
d3628 2
a3629 2
                       reg_remote(SXIP_REGNUM), 
                       reg_remote(SNIP_REGNUM), reg_remote(SFIP_REGNUM));
d3637 1
d3639 1
@


1.9
log
@Delete references to PID_REGNUM.
@
text
@d3 1
a3 1
   Copyright (C)  1988 Free Software Foundation, Inc.
d5 2
a6 5
GDB is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY.  No author or distributor accepts responsibility to anyone
for the consequences of using it or for whether it serves any
particular purpose or works at all, unless he says so in writing.
Refer to the GDB General Public License for full details.
d8 1
a8 6
Everyone is granted permission to copy, modify and redistribute GDB,
but only under the conditions described in the GDB General Public
License.  A copy of this license is supposed to have been given to you
along with GDB so you can know your rights and responsibilities.  It
should be in a file named COPYING.  Among other things, the copyright
notice and this notice must be preserved on all copies.
d10 4
a13 3
In other words, go ahead and share GDB, but don't try to stop
anyone else from sharing it farther.  Help stamp out software hoarding!
*/
d15 51
d73 1
d96 1
a96 1
#define badcaseval(v)  {fprintf(stderr, "In %s, line %s, bad case value %d\n",\
d493 1
a493 1
    fprintf(stream, "%d", code);
d505 1
a505 1
            fprintf(stderr, "close_remote_tty: error closing %s.\n",
d520 1
a520 1
            fprintf(stderr, 
d526 1
a526 1
            fprintf(stderr, "Target got bad command: %s\n", 
d531 1
a531 1
            fprintf(stderr, 
d537 1
a537 1
            fprintf(stderr,
d542 1
a542 1
            fprintf(stderr, "Target expected %s, but got %s\n", 
d610 1
a610 1
        fprintf(stderr, "flushed: ");
d612 1
a612 1
            fprintf(stderr, "%s ", commname(buf[i], prev_char));
d615 1
a615 1
        fprintf(stderr, "\n");
d618 1
a618 1
            fprintf(stderr, "Target is going wild, reset it? (y/n)");
d691 1
a691 1
            fprintf(stderr, "Target received reset signal.\n");
d727 1
a727 1
                fprintf(stderr, "\nTarget took ");
d731 1
a731 1
                    fprintf(stderr, 
d734 1
a734 1
                fprintf(stderr, 
d786 1
a786 1
                        fprintf(stderr,
d790 1
a790 1
                    fprintf(stderr, 
d794 1
a794 1
                fprintf(stderr, "%s\n", commname(c, 0));
d808 1
a808 1
                        fprintf(stderr,
d811 1
a811 1
                        fprintf(stderr, "\n");
d817 1
a817 1
                        fprintf(stderr, "\nTarget got ");
d822 1
a822 1
                        fprintf(stderr, "\nTarget got ");
d828 1
a828 1
                        fprintf(stderr, "\nWhile waiting for ");
d831 1
a831 1
                            fprintf(stderr, ", target got ");
d834 1
a834 1
                            fprintf(stderr, 
d850 1
a850 1
                    fprintf(stderr, 
d879 1
a879 1
                    fprintf(stderr, 
d888 1
a888 1
                            fprintf(stderr, 
d896 1
a896 1
                        fprintf(stderr,
d953 1
a953 1
        fprintf(stderr, "Timeout trying to reset target.\n");
d967 1
a967 1
                    fprintf(stderr, "Target received reset signal.\n");
d970 1
a970 1
                fprintf(stdout, "Unable to reset remote\n");
d993 1
a993 1
                fprintf(stderr, "sending C_SYNC to target...\n");
d1011 1
a1011 1
            fprintf(stderr, "Interrupting target ...\n");
d1025 1
a1025 1
                fprintf(stderr, "Target received debug interrupt.\n");
d1031 1
a1031 1
                    fprintf(stdout, 
d1038 1
a1038 1
            fprintf(stdout, "Unable to interrupt target\n");
d1083 1
a1083 1
        fprintf(stderr, "mon_compress_table_addr=0x%X\n", 
d1090 1
a1090 1
        fprintf(stderr, "mon_register_area_addr=0x%X\n", 
d1097 1
a1097 1
        fprintf(stderr, "mon_single_step_trap_addr=0x%X\n", 
d1104 1
a1104 1
        fprintf(stderr, "mon_version_addr=0x%X\n", mon_version_addr);
d1118 1
a1118 1
        fprintf(stderr, "mon_panic_code_addr=0x%X\n", mon_panic_code_addr);
d1127 1
a1127 1
        fprintf(stderr, "WARNING: monitor's register area is misaligned.\n");
d1136 1
a1136 1
    printf(buf);
d1197 1
a1197 1
            fprintf(stderr, "\nUnable to close tty line\n");
d1214 1
a1214 1
        fprintf(stderr, 
d1218 1
a1218 1
        fprintf(stderr, 
d1221 1
a1221 1
        fprintf(stderr,
d1234 1
a1234 1
            fprintf(stderr, "\nCannot open %s\n", remote_tty_name);
d1236 2
a1237 2
                fprintf(stderr, "Perhaps pin 4 of the RS-232 line (RTS)\n");
                fprintf(stderr, "is not asserted (try tying it to pin 6)\n");
d1258 1
a1258 1
        fprintf(stderr, 
d1267 1
a1267 1
        fprintf(stderr, 
d1308 1
a1308 1
        fprintf(stderr, 
d1314 1
a1314 1
        fprintf(stderr, "Checksumming 0x%X bytes starting at 0x%X\n",
d1361 1
a1361 1
                fprintf(stderr, 
d1370 1
a1370 1
                    fprintf(stdout, "%08x : expected: %08x  target: %08x\n",
d1445 1
a1445 1
        fprintf(stderr, "Zeroing memory from 0x%X to 0x%X\n", 
d1471 1
a1471 1
        fprintf(stderr, "Copying memory 0x%X - 0x%X to 0x%X\n", 
d1510 1
a1510 1
        fprintf(stderr, "Searching memory at 0x%X\n", addr);
d1535 1
a1535 1
        printf("No match\n");
d1538 3
a1540 3
    printf("Match at 0x%08X:", search_addr);
    printf(" 0x%08X", read_remote_w(search_addr, M_SUPERVISOR));
    printf(" 0x%08X\n", read_remote_w(search_addr + 4, M_SUPERVISOR));
d1555 1
a1555 1
        fprintf(stderr, "Total of %d bytes received\n", 
d1558 1
a1558 1
        fprintf(stderr, "Total of %d bytes transmitted\n", 
d1567 2
a1568 2
            fprintf(stderr, "\n");
            fprintf(stderr, 
d1571 1
a1571 1
            fprintf(stderr, 
d1574 1
a1574 1
            fprintf(stderr, 
d1616 1
a1616 1
        fprintf(stderr, 
d1622 1
a1622 1
        fprintf(stderr, "Checksumming 0x%X bytes starting at 0x%X\n",
d1676 1
a1676 1
                fprintf(stderr, "Downloading %d bytes to 0x%X\n",
d1679 1
a1679 1
                fprintf(stderr, "*");
d1701 1
a1701 1
            fprintf(stderr, ".");
d1707 2
a1708 2
        fprintf(stderr, "%d bytes sent to target.\n", bytes_transmitted);
        fprintf(stderr, "%d bytes received from target.\n", bytes_received);
d1710 1
a1710 1
        fprintf(stderr, "\n");
d1748 1
a1748 1
                printf("                   ");
d1750 1
a1750 1
                printf("r%-3d 0x%08x    ", j, remote_read_register(j));
d1753 1
a1753 1
        printf("\n");
d1755 5
a1759 5
    printf("ip   0x%08x    ", remote_read_register(PROGCTR_REGNUM));
    printf("vbr  0x%08x    ", remote_read_register(VBR_REGNUM));
    printf("psr  0x%08x    ", remote_read_register(PSR_REGNUM));
    printf("ceimr 0x%08x    ", remote_read_register(CEIMR_REGNUM));
    putchar('\n');
d1822 1
a1822 1
    printf("0x%08x: 0x%02x\n", next_address, 
d1848 1
a1848 1
    printf("0x%08x: 0x%02x\n", next_address, 
d1874 1
a1874 1
    printf("0x%08x: 0x%02x\n", next_address, 
d1901 1
a1901 1
    printf("0x%08x: ", next_address);
d1929 1
a1929 1
    printf("0x%08x: ", next_address);
d1957 1
a1957 1
    printf("0x%08x: ", next_address);
d2161 1
a2161 1
            fprintf(stdout, "r%-2d=0x%-8x                  ", 
d2166 1
a2166 1
            fprintf(stdout, "r%-2d=0x%-8x ld fr 0x%-8x ", 
d2171 1
a2171 1
            fprintf(stdout, "r%-2d=0x%-8x st to 0x%-8x ", 
d2176 1
a2176 1
            fprintf(stdout, "                                ");
d2480 1
a2480 1
        fprintf(stderr, 
a2536 1
            case PID_REGNUM:  n = 33; break;
d2680 1
a2680 1
        fprintf(stderr, "forced_read_remote: at 0x%X, size=%d", addr, size);
d2700 1
a2700 1
                fprintf(stderr, ", target returns 0x%X\n", w);
d2713 1
a2713 1
                fprintf(stderr, ", target gets DACC\n");
d2718 1
a2718 1
            fprintf(stderr, 
d2772 1
a2772 1
            fprintf(stderr, "read_remote: filling cache line, addr=0x%X\n",
d2805 1
a2805 1
                    fprintf(stderr, "read_remote: dacc at 0x%X\n", addr);
d2918 1
a2918 1
        fprintf(stderr, "writing 0x%x to target at 0x%X ", w, addr);
d2926 1
a2926 1
            fprintf(stderr, " (%s)\n", regname(a/4));
d2928 1
a2928 1
            fprintf(stderr, "\n");
d3014 1
a3014 1
            fprintf(stderr, "\ntransmitting:\n");
d3017 1
a3017 1
        fprintf(stderr, "%s ", commname(c, prev_char));
d3065 1
a3065 1
                        fprintf(stderr, "\nWaiting for target");
d3068 1
a3068 1
                        fprintf(stderr, ".");
d3080 1
a3080 1
        fprintf(stderr, "\n");
d3095 1
a3095 1
            fprintf(stderr, "\nreceiving:\n");
d3098 1
a3098 1
        fprintf(stderr, "%s ", commname(buf[0], prev_char));
d3246 1
a3246 1
                fprintf(stderr, "Didn't find C_ACK in ss_remote\n");
d3250 1
a3250 1
                    fprintf(stdout, "the ip may be incorrect.\n");
d3284 1
a3284 1
                fprintf(stderr, "ss_remote: simulating br instr.\n");
d3302 1
a3302 1
                fprintf(stderr, "ss_remote simulating br.n instr.\n");
d3322 1
a3322 1
                fprintf(stderr, "ss_remote: simulating bb? instr.\n");
d3351 1
a3351 1
                fprintf(stderr, "ss_remote simulating bb?.n instr.\n");
d3383 1
a3383 1
                fprintf(stderr, "ss_remote: simulating bcnd instruction\n");
d3412 1
a3412 1
                fprintf(stderr, "ss_remote simulating bcnd.n instruction\n");
d3443 1
a3443 1
                fprintf(stderr, "ss_remote: simulating bsr instr.\n");
d3463 1
a3463 1
                fprintf(stderr, "ss_remote simulating bsr.n instr.\n");
d3484 1
a3484 1
                fprintf(stderr, "ss_remote simulating normal jmp instr.\n");
d3502 1
a3502 1
                fprintf(stderr, "ss_remote simulating jmp.n instr.\n");
d3523 1
a3523 1
                fprintf(stderr, "ss_remote simulating normal jsr instr.\n");
d3542 1
a3542 1
                fprintf(stderr, "ss_remote simulating jsr.n instr.\n");
d3564 1
a3564 1
                fprintf(stderr, "ss_remote: treating TRAP as a NOP\n");
d3571 1
a3571 1
            fprintf(stderr, "ss_remote: case error at 0x%X\n", real_ip);
d3594 1
a3594 1
        fprintf(stderr, "Warning: sxip=0x%X\n", sxip);
d3669 1
a3669 1
        fprintf(stderr, "Didn't find C_ACK in go_remote\n");
d3673 1
a3673 1
            fprintf(stderr, "Target left running ..\n");
d3679 1
a3679 1
                fprintf(stderr,
d3796 1
a3796 1
    fprintf(stderr, "ssr: 0x%08X ", system_status_register);
d3799 1
a3799 1
            fprintf(stderr, "<%s>", ssr_fieldlist[i]);
d3802 1
a3802 1
    fprintf(stderr, "\n");
d3824 1
a3824 1
    fprintf(stderr, "supervisor area pointer: 0x%08X ", 
d3828 1
a3828 1
            fprintf(stderr, "<%s>", apr_fieldlist[i]);
d3831 1
a3831 1
    fprintf(stderr, "\n");
d3833 1
a3833 1
    fprintf(stderr, "user area pointer: 0x%08X ", 
d3837 1
a3837 1
            fprintf(stderr, "<%s>", apr_fieldlist[i]);
d3840 1
a3840 1
    fprintf(stderr, "\n");
d3850 1
a3850 1
    fprintf(stderr, "Physical address of last pde or sde fetched: 0x%X\n", 
@


1.8
log
@First cut at putting cross-debugging support into 3.2 that
interacts with Tektronix debug monitors.
 Compiles, links, don't think it screws up anything outside of
cross-debugging
@
text
@a2466 1
            case PID_REGNUM:  n = 33; break;
@


1.7
log
@Added Tek header information.
@
text
@d1 1
a1 2
/* Memory-access and commands for inferior process, for GDB.
   Copyright (C)  1988, 1989 Free Software Foundation, Inc.
d3 1
a3 2
   $Header: remote.c,v 1.6 89/10/16 16:56:28 davidl Exp $
   $Locker: davidl $
d5 5
a9 1
This file is part of GDB.
d11 6
a16 4
GDB is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.
d18 3
a20 4
GDB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
d22 8
a29 3
You should have received a copy of the GNU General Public License
along with GDB; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
d31 11
d43 5
d49 45
a93 38
/* 
 * Changes made by Tektronix are marked by TEK_HACK, TEK_PROG_HACK, 
 * and GHSFORTRAN.
 * Changes made by Data General are marked by DG_HACK.  Compiling without these
 * #defines should be equivalent to compiling vanilla 3.2, more or less.
 *
 * The changes done by Tektronix fit into three catagories:
 *	TEK_HACK -- these were done just to get GDB to work in our environment,
 *		    including work done to support the Green Hills C compiler.
 *	TEK_PROG_HACK -- These were done to extend GDB by adding programming
 *			 support: things like if-elif-else-endif, while, and
 *			 arguments to user defined commands.
 *	GHSFORTRAN -- These changes make (will make) GDB work with the Green
 *		      Hills Fortran compiler.
 *
 *
 * In addition, I/O routines were renamed so that I/O could be directed
 * to/from the X interface if used.  See the files ui.c and ui.h for
 * more information.  Here are the routines renamed:
 *    Old name:			Renamed to:
 *	fprintf			ui_fprintf
 *	printf			ui_fprintf(stdout
 *	putchar			ui_putchar
 *	putc			ui_putc
 *	fputc			ui_putc
 *	fputs			ui_fputs
 *	puts			ui_puts
 *	gets			ui_gets
 *	fgets			ui_fgets
 *	fflush			ui_fflush
 *	system			ui_system
 *	wait			ui_wait
 *	error			ui_badnews(-1
 *	fatal			ui_badnews(1
 *	getc, fgetc		replaced with ui_gets, ui_fgets
 * These changes are not demarcated by ifdef.   
 *
 *					November 16, 1989
d95 6
d102 22
a123 2
/* Remote communication protocol.
   All values are encoded in ascii hex digits.
d125 5
a129 1
	Request		Packet
d131 4
a134 7
	read registers  g
	reply		XX....X		Each byte of register data
					is described by two hex digits.
					Registers are in the internal order
					for GDB, and the bytes in a register
					are in the same order the machine uses.
			or ENN		for an error.
d136 1
a136 4
	write regs	GXX..XX		Each byte of register data
					is described by two hex digits.
	reply		OK		for success
			ENN		for an error
d138 3
a140 3
	read mem	mAA..AA,LLLL	AA..AA is address, LLLL is length.
	reply		XX..XX		XX..XX is mem contents
			or ENN		NN is errno
d142 3
a144 6
	write mem	MAA..AA,LLLL:XX..XX
					AA..AA is address,
					LLLL is number of bytes,
					XX..XX is data
	reply		OK		for success
			ENN		for an error
d146 4
a149 3
	cont		cAA..AA		AA..AA is address to resume
					If AA..AA is omitted,
					resume at same address.
d151 5
a155 3
	step		sAA..AA		AA..AA is address to resume
					If AA..AA is omitted,
					resume at same address.
d157 2
a158 4
	last signal     ?               Reply the current reason for stopping.
                                        This is the same reply as is generated
					for step or cont : SAA where AA is the
					signal number.
d160 1
a160 3
	There is no immediate reply to step or cont.
	The reply comes when the machine stops.
	It is		SAA		AA is the "signal number"
d162 12
a173 2
	kill req	k
*/
d175 1
a175 5
#include "defs.h"
#include "param.h"
#include "frame.h"
#include "inferior.h"
#include "ui.h"
d177 4
a180 1
#include "wait.h"
d182 1
a182 4
#ifdef USG
#include <sys/types.h>
#include <fcntl.h>
#endif
d184 2
a185 4
#include <stdio.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sys/file.h>
a186 13
#ifdef HAVE_TERMIO
#include <termio.h>
#undef TIOCGETP
#define TIOCGETP TCGETA
#undef TIOCSETN
#define TIOCSETN TCSETA
#undef TIOCSETP
#define TIOCSETP TCSETAF
#define TERMINAL struct termio
#else
#include <sgtty.h>
#define TERMINAL struct sgttyb
#endif
d188 34
a221 2
static int kiodebug;
static int timeout = 5;
d223 17
a239 1
int icache;
d241 6
a246 2
/* Descriptor for I/O to remote machine.  */
int remote_desc;
d248 11
a258 1
#define	PBUFSIZ	400
d260 1
a260 4
static void remote_send ();
static void putpkt ();
static void getpkt ();
static void dcache_flush ();
d262 1
a262 8

/* Called when SIGALRM signal sent due to alarm() timeout.  */
#ifndef HAVE_TERMIO
void
remote_timer ()
{
  if (kiodebug)
    ui_fprintf(stdout, "remote_timer called\n");
d264 1
a264 3
  alarm (timeout);
}
#endif
d266 3
a268 2
/* Open a connection to a remote debugger.
   NAME is the filename used for communication.  */
d270 1
a270 6
void
remote_open (name, from_tty)
     char *name;
     int from_tty;
{
  TERMINAL sg;
d272 1
a272 2
  if (remote_desc >= 0)
    close (remote_desc);
d274 1
a274 2
  remote_debugging = 0;
  dcache_init ();
d276 1
a276 3
  remote_desc = open (name, O_RDWR);
  if (remote_desc < 0)
    perror_with_name (name);
d278 5
a282 9
  ioctl (remote_desc, TIOCGETP, &sg);
#ifdef HAVE_TERMIO
  sg.c_cc[VMIN] = 0;		/* read with timeout.  */
  sg.c_cc[VTIME] = timeout * 10;
  sg.c_lflag &= ~(ICANON | ECHO);
#else
  sg.sg_flags = RAW;
#endif
  ioctl (remote_desc, TIOCSETP, &sg);
d284 2
a285 3
  if (from_tty)
    ui_fprintf(stdout, "Remote debugging using %s\n", name);
  remote_debugging = 1;
d287 5
a291 6
#ifndef HAVE_TERMIO
#ifndef NO_SIGINTERRUPT
  /* Cause SIGALRM's to make reads fail.  */
  if (siginterrupt (SIGALRM, 1) != 0)
    perror ("remote_open: error in siginterrupt");
#endif
d293 1
a293 4
  /* Set up read timeout timer.  */
  if ((void (*)) signal (SIGALRM, remote_timer) == (void (*)) -1)
    perror ("remote_open: error in signal");
#endif
a294 2
  putpkt ("?");			/* initiate a query from remote machine */
}
d296 28
a323 13
/* Close the open connection to the remote debugger.
   Use this when you want to detach and do something else
   with your gdb.  */
void
remote_close (from_tty)
     int from_tty;
{
  if (!remote_debugging)
    ui_badnews(-1,"Can't close remote connection: not debugging remotely.");
  
  close (remote_desc);		/* This should never be called if
				   there isn't something valid in
				   remote_desc.  */
d325 7
a331 2
  if (from_tty)
    ui_fprintf(stdout, "Ending remote debugging\n");
d333 2
a334 4
  remote_debugging = 0;
}
 
/* Convert hex digit A to a number.  */
d336 3
a338 3
static int
fromhex (a)
     int a;
d340 6
a345 7
  if (a >= '0' && a <= '9')
    return a - '0';
  else if (a >= 'a' && a <= 'f')
    return a - 'a' + 10;
  else
    ui_badnews(-1,"Reply contains invalid hex digit");
}
d347 18
a364 10
/* Convert number NIB to a hex digit.  */

static int
tohex (nib)
     int nib;
{
  if (nib < 10)
    return '0'+nib;
  else
    return 'a'+nib-10;
a365 2

/* Tell the remote machine to resume.  */
d371 10
a380 7
  char buf[PBUFSIZ];

  dcache_flush ();

  strcpy (buf, step ? "s": "c");

  putpkt (buf);
a389 2
  unsigned char buf[PBUFSIZ];

d391 3
a393 6
  getpkt (buf);
  if (buf[0] == 'E')
    ui_badnews(-1,"Remote failure reply: %s", buf);
  if (buf[0] != 'S')
    ui_badnews(-1,"Invalid remote reply: %s", buf);
  WSETSTOP ((*status), (((fromhex (buf[1])) << 4) + (fromhex (buf[2]))));
a401 1
  char buf[PBUFSIZ];
d403 1
a403 1
  char *p;
d405 3
a407 14
  sprintf (buf, "g");
  remote_send (buf);

  /* Reply describes registers byte by byte,
     each byte encoded as two hex characters.  */

  p = buf;
  for (i = 0; i < REGISTER_BYTES; i++)
    {
      if (p[0] == 0 || p[1] == 0)
	ui_badnews(-1,"Remote reply is too short: %s", buf);
      regs[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
      p += 2;
    }
d416 2
a417 3
  char buf[PBUFSIZ];
  int i;
  char *p;
d419 2
a420 10
  buf[0] = 'G';
  
  /* Command describes registers byte by byte,
     each byte encoded as two hex characters.  */

  p = buf + 1;
  for (i = 0; i < REGISTER_BYTES; i++)
    {
      *p++ = tohex ((regs[i] >> 4) & 0xf);
      *p++ = tohex (regs[i] & 0xf);
a421 3
  *p = '\0';

  remote_send (buf);
d431 1
a431 12
  if (icache)
    {
      extern CORE_ADDR text_start, text_end;

      if (addr >= text_start && addr < text_end)
	{
	  int buffer;
	  xfer_core_file (addr, &buffer, sizeof (int));
	  return buffer;
	}
    }
  return dcache_fetch (addr);
d442 1
a442 1
  dcache_poke (addr, word);
a443 6

/* Write memory data directly to the remote machine.
   This does not inform the data cache; the data cache uses this.
   MEMADDR is the address in the remote memory space.
   MYADDR is the address of the buffer in our space.
   LEN is the number of bytes.  */
d445 2
a446 5
void
remote_write_bytes (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d448 2
a449 3
  char buf[PBUFSIZ];
  int i;
  char *p;
d451 15
a465 2
  if (len > PBUFSIZ / 2 - 20)
    abort ();
d467 12
a478 1
  sprintf (buf, "M%x,%x:", memaddr, len);
d480 4
a483 2
  /* Command describes registers byte by byte,
     each byte encoded as two hex characters.  */
d485 19
a503 5
  p = buf + strlen (buf);
  for (i = 0; i < len; i++)
    {
      *p++ = tohex ((myaddr[i] >> 4) & 0xf);
      *p++ = tohex (myaddr[i] & 0xf);
a504 1
  *p = '\0';
d506 11
a516 1
  remote_send (buf);
a518 5
/* Read memory data directly from the remote machine.
   This does not use the data cache; the data cache uses this.
   MEMADDR is the address in the remote memory space.
   MYADDR is the address of the buffer in our space.
   LEN is the number of bytes.  */
d520 4
a523 5
void
remote_read_bytes (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d525 1
a525 3
  char buf[PBUFSIZ];
  int i;
  char *p;
d527 19
a545 2
  if (len > PBUFSIZ / 2 - 1)
    abort ();
d547 6
a552 2
  sprintf (buf, "m%x,%x", memaddr, len);
  remote_send (buf);
d554 4
a557 2
  /* Reply describes registers byte by byte,
     each byte encoded as two hex characters.  */
d559 3
a561 7
  p = buf;
  for (i = 0; i < len; i++)
    {
      if (p[0] == 0 || p[1] == 0)
	ui_badnews(-1,"Remote reply is too short: %s", buf);
      myaddr[i] = fromhex (p[0]) * 16 + fromhex (p[1]);
      p += 2;
d563 23
d587 1
a587 1

d589 37
d627 8
a634 2
A debug packet whose contents are <data>
is encapsulated for transmission in the form:
d636 15
a650 1
	$ <data> # CSUM1 CSUM2
d652 11
a662 2
	<data> must be ASCII alphanumeric and cannot include characters
	'$' or '#'
d664 1
a664 3
	CSUM1 and CSUM2 are ascii hex representation of an 8-bit 
	checksum of <data>, the most significant nibble is sent first.
	the hex digits 0-9,a-f are used.
d666 6
a671 1
Receiver responds with:
d673 1
a673 2
	+	- if CSUM is correct and ready for next packet
	-	- if CSUM is incorrect
d675 2
a676 1
*/
d678 46
a723 2
static int
readchar ()
d725 7
a731 1
  char buf;
d733 243
a975 4
  buf = '\0';
#ifdef HAVE_TERMIO
  /* termio does the timeout for us.  */
  read (remote_desc, &buf, 1);
d977 1
a977 3
  alarm (timeout);
  read (remote_desc, &buf, 1);
  alarm (0);
d979 5
d985 16
a1000 1
  return buf & 0x7f;
a1002 3
/* Send the command in BUF to the remote machine,
   and read the reply into BUF.
   Report an error if we get an error reply.  */
d1004 5
a1008 3
static void
remote_send (buf)
     char *buf;
d1010 4
a1013 2
  putpkt (buf);
  getpkt (buf);
d1015 82
a1096 2
  if (buf[0] == 'E')
    ui_badnews(-1,"Remote failure reply: %s", buf);
a1098 2
/* Send a packet to the remote machine, with error checking.
   The data of the packet is in BUF.  */
d1100 4
a1103 3
static void
putpkt (buf)
     char *buf;
d1105 1
a1105 6
  int i;
  unsigned char csum = 0;
  char buf2[500];
  int cnt = strlen (buf);
  char ch;
  char *p;
d1107 3
a1109 2
  /* Copy the packet into buffer BUF2, encapsulating it
     and giving it a checksum.  */
a1110 2
  p = buf2;
  *p++ = '$';
d1112 32
a1143 4
  for (i = 0; i < cnt; i++)
    {
      csum += buf[i];
      *p++ = buf[i];
a1144 3
  *p++ = '#';
  *p++ = tohex ((csum >> 4) & 0xf);
  *p++ = tohex (csum & 0xf);
d1146 9
a1154 1
  /* Send it over and over until we get a positive ack.  */
d1156 618
a1773 5
  do {
    if (kiodebug)
      {
	*p = '\0';
	ui_fprintf(stdout, "Sending packet: %s (%s)\n", buf2, buf);
d1775 6
a1780 1
    write (remote_desc, buf2, p - buf2);
d1782 24
a1805 5
    /* read until either a timeout occurs (\0) or '+' is read */
    do {
      ch = readchar ();
    } while ((ch != '+') && (ch != '\0'));
  } while (ch != '+');
d1808 11
a1818 2
/* Read a packet from the remote machine, with error checking,
   and store it in BUF.  */
d1820 19
a1838 3
static void
getpkt (buf)
     char *buf;
d1840 6
a1845 5
  char *bp;
  unsigned char csum;
  int c;
  unsigned char c1, c2;
  extern kiodebug;
d1847 3
a1849 2
  /* allow immediate quit while reading from device, it could be hung */
  immediate_quit++;
d1851 10
a1860 6
  while (1)
    {
      /* Force csum to be zero here because of possible error retry.  */
      csum = 0;
      
      while ((c = readchar()) != '$');
d1862 389
a2250 8
      bp = buf;
      while (1)
	{
	  c = readchar ();
	  if (c == '#')
	    break;
	  *bp++ = c;
	  csum += c;
d2252 3
a2254 1
      *bp = 0;
d2256 165
a2420 7
      c1 = fromhex (readchar ());
      c2 = fromhex (readchar ());
      if ((csum & 0xff) == (c1 << 4) + c2)
	break;
      ui_fprintf(stdout, "Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s\n",
	      (c1 << 4) + c2, csum & 0xff, buf);
      write (remote_desc, "-", 1);
d2422 2
a2424 1
  immediate_quit--;
d2426 7
a2432 1
  write (remote_desc, "+", 1);
d2434 43
a2476 2
  if (kiodebug)
    ui_fprintf (stderr,"Packet received :%s\n", buf);
a2477 3

/* The data cache records all the data read from the remote machine
   since the last time it stopped.
d2479 8
a2486 2
   Each cache block holds 16 bytes of data
   starting at a multiple-of-16 address.  */
d2488 16
a2503 1
#define DCACHE_SIZE 64		/* Number of cache blocks */
d2505 10
a2514 5
struct dcache_block {
	struct dcache_block *next, *last;
	unsigned int addr;	/* Address for which data is recorded.  */
	int data[4];
};
d2516 9
a2524 1
struct dcache_block dcache_free, dcache_valid;
d2526 8
a2533 1
/* Free all the data cache blocks, thus discarding all cached data.  */ 
d2535 34
a2568 2
static void
dcache_flush ()
d2570 1
a2570 1
  register struct dcache_block *db;
d2572 2
a2573 9
  while ((db = dcache_valid.next) != &dcache_valid)
    {
#if	defined (TEK_HACK) && defined (USG)
      remqueue (db);
      insqueue (db, &dcache_free);
#else /* not TEK_HACK or not USG */
      remque (db);
      insque (db, &dcache_free);
#endif	/* not TEK_HACK or not USG */
d2575 36
d2614 1
a2614 2
 * If addr is present in the dcache, return the address of the block 
 * containing it.
d2616 7
d2624 65
a2688 2
struct dcache_block *
dcache_hit (addr)
d2690 3
a2692 1
  register struct dcache_block *db;
d2694 2
a2695 2
  if (addr & 3)
    abort ();
d2697 7
a2703 7
  /* Search all cache blocks for one that is at this address.  */
  db = dcache_valid.next;
  while (db != &dcache_valid)
    {
      if ((addr & 0xfffffff0) == db->addr)
	return db;
      db = db->next;
d2705 53
a2757 2
  return NULL;
}
d2759 8
a2766 1
/*  Return the int data at address ADDR in dcache block DC.  */
d2768 36
a2803 4
int
dcache_value (db, addr)
     struct dcache_block *db;
     unsigned int addr;
d2805 1
a2805 3
  if (addr & 3)
    abort ();
  return (db->data[(addr>>2)&3]);
d2808 8
a2815 3
/* Get a free cache block, put it on the valid list,
   and return its address.  The caller should store into the block
   the address and data that it describes.  */
d2817 5
a2821 2
struct dcache_block *
dcache_alloc ()
d2823 2
a2824 1
  register struct dcache_block *db;
d2826 10
a2835 3
  if ((db = dcache_free.next) == &dcache_free)
    /* If we can't get one from the free list, take last valid */
    db = dcache_valid.last;
d2837 13
a2849 8
#if	defined (TEK_HACK) && defined (USG)
  remqueue (db);
  insqueue (db, &dcache_valid);
#else /* not TEK_HACK or not USG */
  remque (db);
  insque (db, &dcache_valid);
#endif /* not TEK_HACK or not USG */
  return (db);
d2852 9
a2860 2
/* Return the contents of the word at address ADDR in the remote machine,
   using the data cache.  */
d2862 62
a2923 3
int
dcache_fetch (addr)
     CORE_ADDR addr;
d2925 2
a2926 1
  register struct dcache_block *db;
d2928 31
a2958 6
  db = dcache_hit (addr);
  if (db == 0)
    {
      db = dcache_alloc ();
      remote_read_bytes (addr & ~0xf, db->data, 16);
      db->addr = addr & ~0xf;
d2960 17
a2976 1
  return (dcache_value (db, addr));
d2979 8
a2986 1
/* Write the word at ADDR both in the data cache and in the remote machine.  */
d2988 15
a3002 3
dcache_poke (addr, data)
     CORE_ADDR addr;
     int data;
d3004 5
a3008 1
  register struct dcache_block *db;
d3010 18
a3027 8
  /* First make sure the word is IN the cache.  DB is its cache block.  */
  db = dcache_hit (addr);
  if (db == 0)
    {
      db = dcache_alloc ();
      remote_read_bytes (addr & ~0xf, db->data, 16);
      db->addr = addr & ~0xf;
    }
d3029 1
a3029 2
  /* Modify the word in the cache.  */
  db->data[(addr>>2)&3] = data;
d3031 28
a3058 2
  /* Send the changed word.  */
  remote_write_bytes (addr, &data, 4);
d3061 7
a3067 1
/* Initialize the data cache.  */
d3069 12
a3080 1
dcache_init ()
d3082 2
a3083 2
  register i;
  register struct dcache_block *db;
d3085 6
a3090 10
  db = (struct dcache_block *) xmalloc (sizeof (struct dcache_block) * 
					DCACHE_SIZE);
  dcache_free.next = dcache_free.last = &dcache_free;
  dcache_valid.next = dcache_valid.last = &dcache_valid;
  for (i=0;i<DCACHE_SIZE;i++,db++)
#if	defined (TEK_HACK) && defined (USG)
    insqueue (db, &dcache_free);
#else /* not TEK_HACK or not USG */
    insque (db, &dcache_free);
#endif /* not TEK_HACK or not USG */
d3093 758
@


1.6
log
@Cleaned up junk found by Saber-C.  Mostly this consisted of removing unused
automatic variables.
@
text
@d4 2
a5 2
   $Header: remote.c,v 1.5 89/09/22 15:59:43 paulg Exp $
   $Locker:  $
d22 42
@


1.5
log
@use libc version of queue stuff in  not USG
@
text
@d4 1
a4 1
   $Header:  $
a460 1
  int i;
a477 1
  char buf3[1];
@


1.4
log
@change ui_badnews(0 to ui_badnews(-1
@
text
@d4 3
d592 1
a592 1
#ifdef	TEK_HACK
d595 1
a595 1
#else
d598 1
a598 1
#endif	/* TEK_HACK */
d651 1
a651 1
#ifdef	TEK_HACK
d654 1
a654 1
#else
d657 1
a657 1
#endif	/* TEK_HACK */
d716 1
a716 1
#ifdef	TEK_HACK
d718 1
a718 1
#else
d720 1
a720 1
#endif	/* TEK_HACK */
@


1.3
log
@merge in Data General stuff: get clean compile.
@
text
@d186 1
a186 1
    ui_badnews(0,"Can't close remote connection: not debugging remotely.");
d209 1
a209 1
    ui_badnews(0,"Reply contains invalid hex digit");
d251 1
a251 1
    ui_badnews(0,"Remote failure reply: %s", buf);
d253 1
a253 1
    ui_badnews(0,"Invalid remote reply: %s", buf);
d277 1
a277 1
	ui_badnews(0,"Remote reply is too short: %s", buf);
d405 1
a405 1
	ui_badnews(0,"Remote reply is too short: %s", buf);
d463 1
a463 1
    ui_badnews(0,"Remote failure reply: %s", buf);
@


1.2
log
@Changes for initial runnable xgdb version.
@
text
@d589 4
d595 1
d648 4
d654 1
d713 3
d717 1
@


1.1
log
@Initial revision
@
text
@d73 1
d123 1
a123 1
    printf ("remote_timer called\n");
d160 1
a160 1
    printf ("Remote debugging using %s\n", name);
d186 1
a186 1
    error ("Can't close remote connection: not debugging remotely.");
d193 1
a193 1
    printf ("Ending remote debugging\n");
d209 1
a209 1
    error ("Reply contains invalid hex digit");
d251 1
a251 1
    error ("Remote failure reply: %s", buf);
d253 1
a253 1
    error ("Invalid remote reply: %s", buf);
d277 1
a277 1
	error ("Remote reply is too short: %s", buf);
d405 1
a405 1
	error ("Remote reply is too short: %s", buf);
d463 1
a463 1
    error ("Remote failure reply: %s", buf);
d502 1
a502 1
	printf ("Sending packet: %s (%s)\n", buf2, buf);
d551 1
a551 1
      printf ("Bad checksum, sentsum=0x%x, csum=0x%x, buf=%s\n",
d561 1
a561 1
    fprintf (stderr,"Packet received :%s\n", buf);
@
