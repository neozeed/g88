head     1.24;
branch   ;
access   ;
symbols  ;
locks    ; strict;
comment  @ * @;


1.24
date     91.01.14.01.20.44;  author robertb;  state Exp;
branches ;
next     1.23;

1.23
date     90.11.15.19.29.20;  author robertb;  state Exp;
branches ;
next     1.22;

1.22
date     90.11.01.12.55.13;  author robertb;  state Exp;
branches ;
next     1.21;

1.21
date     90.10.30.23.55.21;  author robertb;  state Exp;
branches ;
next     1.20;

1.20
date     90.08.19.21.22.28;  author robertb;  state Exp;
branches ;
next     1.19;

1.19
date     90.08.06.09.51.53;  author robertb;  state Exp;
branches ;
next     1.18;

1.18
date     90.06.30.17.37.40;  author robertb;  state Exp;
branches ;
next     1.17;

1.17
date     90.03.28.14.29.50;  author robertb;  state Exp;
branches ;
next     1.16;

1.16
date     90.03.16.08.03.32;  author andrew;  state Exp;
branches ;
next     1.15;

1.15
date     90.03.15.09.10.21;  author andrew;  state Exp;
branches ;
next     1.14;

1.14
date     90.02.02.16.05.54;  author marvinw;  state Exp;
branches ;
next     1.13;

1.13
date     90.02.02.14.24.35;  author andrew;  state Exp;
branches ;
next     1.12;

1.12
date     90.01.02.16.58.39;  author robertb;  state Exp;
branches ;
next     1.11;

1.11
date     89.12.18.17.19.56;  author andrew;  state Exp;
branches ;
next     1.10;

1.10
date     89.11.30.14.35.13;  author marvinw;  state Exp;
branches ;
next     1.9;

1.9
date     89.11.17.08.10.11;  author davidl;  state Exp;
branches ;
next     1.8;

1.8
date     89.11.16.13.28.17;  author davidl;  state Exp;
branches ;
next     1.7;

1.7
date     89.10.03.12.19.05;  author marvinw;  state Exp;
branches ;
next     1.6;

1.6
date     89.09.21.10.18.43;  author paulg;  state Exp;
branches ;
next     1.5;

1.5
date     89.09.19.12.10.22;  author paulg;  state Exp;
branches ;
next     1.4;

1.4
date     89.09.08.16.11.02;  author paulg;  state Exp;
branches ;
next     1.3;

1.3
date     89.09.02.09.36.28;  author paulg;  state Exp;
branches ;
next     1.2;

1.2
date     89.08.19.12.33.25;  author paulg;  state Exp;
branches ;
next     1.1;

1.1
date     89.08.15.11.38.05;  author root;  state Exp;
branches ;
next     ;


desc
@taken from parm.h in gdb_release from Data General.
@


1.24
log
@Made default be dbx format unless USEDGCOFF is given on command line.
@
text
@/*
 * Changes for m88k by David Biesack (biesack@@dg-rtp.dg.com)
 * 		   and Paul Reilly   (reilly@@dg-rtp.dg.com)
 * February 1989
 *
 * Changes for Green Hills compilers by Paul J. Gilliam (paulg@@orca.wv.tek.com)
 * August 1989
 */

/*
   Copyright (C) 1986, 1987 Free Software Foundation, Inc.

   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/tar/g88/RCS/m-m88k.h,v 1.23 90/11/15 19:29:20 robertb Exp Locker: robertb $
   $Locker: robertb $
 */

/* Tektronix programming extensions to GDB, the GNU debugger.
   Copyright (C) 1989 Free Software Foundation, Inc.


This file is part of GDB. */

#ifndef m88k
#define m88k
#endif

/* define USG if you are using sys5 /usr/include's */
#define USG

/* USG systems need these */
#define vfork() fork()
#ifndef MAXPATHLEN
#define MAXPATHLEN 500
#endif

/* define this if you don't have the extension to coff that allows
 * file names to appear in the string table
 * (aux.x_file.x_foff)
 */
#ifndef TEK_HACK
#define COFF_NO_LONG_FILE_NAMES
#endif

/* turn this on when rest of gdb is ready */
/* #define IEEE_FLOAT */
#define NBPG NBPC		/* number of bytes per page */
#define UPAGES USIZE		/* number of pages in kernel per-user area */

#define HAVE_TERMIO

#ifdef __GNUC__
#define alloca __builtin_alloca
#endif

/* Get rid of any system-imposed stack limit if possible.  */

#define SET_STACK_LIMIT_HUGE

/* Define this if the C compiler puts an underscore at the front
   of external names before giving them to the linker.  */

#define NAMES_HAVE_UNDERSCORE

/* Specify debugger information format.  */

/* We assume that if we are not building w/ DG COFF header files
   that we are building for DBX format. */

#ifdef	USEDGCOFF
#define COFF_FORMAT
#else
#define READ_DBX_FORMAT
#endif

/* number of traps that happen between exec'ing the shell
 * to run an inferior, and when we finally get to
 * the inferior code.  This is 2 on most implementations.
 */
#define START_INFERIOR_TRAPS_EXPECTED 2

/* Offset from address of function to start of its code.
   Zero on most machines.  */

#define FUNCTION_START_OFFSET 0

/* Code to advance PC across any function entry prologue instructions
   to reach some "real" code.  Never seems to be used. */

#define SKIP_PROLOGUE(frompc)   {}

/* Immediately after a function call, return the saved pc.
   Can't always go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.  */

#define SAVED_PC_AFTER_CALL(frame)  (read_register (SRP_REGNUM))

/* This is the amount to subtract from u.u_ar0
   to get the offset in the core file of the register values.
   Not used here; we use (struct ptrace_user) instead. */

/* #define KERNEL_U_ADDR 0 */

/* Address of end of stack space.  */

#define STACK_END_ADDR ((CORE_ADDR)0xfff00000)	/* Guess -rcb 6/90 */

/* Stack grows downward.  */

#define INNER_THAN <

#ifdef TEK_HACK
#define BAD_STACK_ADDR(addr) ((CORE_ADDR)(addr) >= STACK_END_ADDR || \
			      (CORE_ADDR)(addr) < read_register (SP_REGNUM))
#endif /* TEK_HACK */

/* Sequence of bytes for breakpoint instruction.
   Instruction 0xF000D081 is 'tb0 0,r0,129'.  This always traps. */
#define BREAKPOINT {0xF0, 0x00, 0xD0, 0x81}
#define REMOTE_BREAKPOINT {0xf0, 0, 0xd0, 0xfe }; /* rcb */

/* Amount PC must be decremented by after a breakpoint.
   This is often the number of bytes in BREAKPOINT
   but not always.
   Under the Tektronix kernel, when a process executes the BREAKPOINT
   instruction above (trap 129), the kernel backs off the instruction pointers,
   so that $SNIP = trap-time $SXIP and $SFIP = trap-time $SNIP.  This sets
   things up so that a return will execute the instruction where the breakpoint
   was.  However, the "standard" (BCS defined) traps 504 through 511 do not
   cause this backup.  If gdb is ever changed to use the standard traps, it
   must be taught to back up the instruction pointers itself.  To do this,
   IT IS NOT SUFFICIENT to define DECR_PC_AFTER_BREAK! */

#define DECR_PC_AFTER_BREAK 0

/* Nonzero if instruction at PC is a return instruction.
   'jmp r1' or 'jmp.n r1' is used to return from a subroutine.
   This does not seem to be used. */

#define ABOUT_TO_RETURN(pc) \
	((read_memory_integer ((pc), 4) & ~0x400) == (0xf400c000 + SRP_REGNUM))

/* Return 1 if P points to an invalid floating point value.
   LEN is the length in bytes -- not relevant on the 386.  */

#define INVALID_FLOAT(p, len) IEEE_isNAN((p),(len))

/* Largest integer type */
#define LONGEST long

/* Name of the builtin type for the LONGEST type above. */
#define BUILTIN_TYPE_LONGEST builtin_type_long

/* Say how long (ordinary) registers are.  */

/* We run the 88k in big-endian mode */
#define BITS_BIG_ENDIAN	

#define REGISTER_TYPE long

/* Register numbers of various important registers.
   Note that some of these values are "real" register numbers,
   and correspond to the general registers of the machine,
   and some are "phony" register numbers which are too large
   to be actual register numbers as far as the user is concerned
   but do serve to get the desired values when passed to read_register.  */

/* General registers r0 through r31 have register numbers 0 through 31. */
#define R0_REGNUM	0	/* r0 */
#define R1_REGNUM	1	/* r1:    subroutine return pointer */
#define R2_REGNUM	2	/* r2 */
#define R3_REGNUM	3	/* r3 */
#define SRP_REGNUM	1	/* r1:    subroutine return pointer */
#define FP_REGNUM	30	/* r30:   frame pointer */
#define SP_REGNUM	31	/* r31:   stack pointer */

/* Number of general-purpose (integer) registers. */
#define NUM_GENERAL_REGS 32

/* Phony register: synthesized program counter.
   When debugging a Unix process, this has special semantics when read
   from (gets the $SNIP) and when written to (sets the $SNIP and $SFIP).
   On the simulator, this is the actual program counter because the simulator
   implements only a non-pipelined machine. */
#define SYNTH_PC_REGNUM 32	/* synthesized program counter */

/* Integer unit control registers.
   Some of these are unavailable when debugging a Unix process.
   Access to PSR_REGNUM is changed to EPSR_REGNUM so that they make sense. */
#define PID_REGNUM	33	/* cr0:   precessor identification register */
#define PSR_REGNUM	34	/* cr1:   process status reg (actually EPSR) */
#define EPSR_REGNUM	35	/* cr2:   exception-time process status reg */
#define SSBR_REGNUM	36	/* cr3:   shadow scoreboard register */
#define SXIP_REGNUM	37	/* cr4:   shadow execute instruction pointer */
#define SNIP_REGNUM	38	/* cr5:   shadow next instruction pointer */
#define SFIP_REGNUM	39	/* cr6:   shadow fetched intruction pointer */
#define VBR_REGNUM	40	/* cr7:   vector base register */
#define DMT0_REGNUM	41	/* cr8:   transaction register 0 */
#define DMD0_REGNUM	42	/* cr9:   data register 0 */
#define DMA0_REGNUM	43	/* cr10:  address register 0 */
#define DMT1_REGNUM	44	/* cr11:  transaction register 0 */
#define DMD1_REGNUM	45	/* cr12:  data register 0 */
#define DMA1_REGNUM	46	/* cr13:  address register 0 */
#define DMT2_REGNUM	47	/* cr14:  transaction register 0 */
#define DMD2_REGNUM	48	/* cr15:  data register 0 */
#define DMA2_REGNUM	49	/* cr16:  address register 0 */
#define SR0_REGNUM	50	/* cr17:  supervisor storage register 0 */
#define SR1_REGNUM	51	/* cr18:  supervisor storage register 1 */
#define SR2_REGNUM	52	/* cr19:  supervisor storage register 2 */
#define SR3_REGNUM	53	/* cr20:  supervisor storage register 3 */

/* Floating point unit control registers.
   Some of these are unavailable when debugging a Unix process. */
#define FPECR_REGNUM	54	/* fcr0:  FPU exception cause register */
#define FPHS1_REGNUM	55	/* fcr1:  FPU source 1 operand high register */
#define FPLS1_REGNUM	56	/* fcr2:  FPU source 1 operand low register */
#define FPHS2_REGNUM	57	/* fcr3:  FPU source 2 operand high register */
#define FPLS2_REGNUM	58	/* fcr4:  FPU source 2 operand low register */
#define FPPT_REGNUM	59	/* fcr5:  FPU precise operation type register */
#define FPRH_REGNUM	60	/* fcr6:  FPU result high register */
#define FPRL_REGNUM	61	/* fcr7:  FPU result low register */
#define FPIT_REGNUM	62	/* fcr8:  FPU imprecise operation type reg */
#define FPSR_REGNUM	63	/* fcr62: FPU status register */
#define FPCR_REGNUM	64	/* fcr63: FPU control register */

/* Registers external to the CPU. */
#define CEIMR_REGNUM	65	/* Blackbird CE interrupt mask register */

/* Simulator-only registers. */
#define COMEFROM_REGNUM	66	/* address of last jmp/jmp.n/jsr/jsr.n */
#define MEMBRK_REGNUM	67	/* stop on write to this location */
#define STACKBASE_REGNUM 68	/* stop if r31 < this value */
#define RAMSIZE_REGNUM	69	/* amount of RAM in simulated machine */

/* Phony register: synthesized frame pointer.
   If the function manipulates a real frame pointer in r30, this register
   mirrors that.  If the function does not maintain a frame pointer in r30,
   this register contains the value that the function would have maintained
   (computed by examining the stack pointer and the first few instructions
   of the function).  Can be read but not written. */
#define SYNTH_FP_REGNUM 70	/* synthesized frame pointer */

/* Number of machine registers */
#define NUM_REGS	71

/* True if regno is a register that parameters are passed in.  -rcb */
#define	IS_PARAM_REG(regno) (2<=(regno)&&(regno)<=9)

/* In the instruction pointer registers (SXIP, SNIP, SFIP), the low two bits
   are status bits: */
#define IP_VALID 2
#define IP_EXCEPTION 1

extern char reg_access[NUM_REGS];

/* Values in reg_access[] */
#define USER_REGACC 1
#define REMOTE_REGACC 2
#define SIM_REGACC 4

/* Register access macros */
#define CAN_REGACC_USER(regnum)   (reg_access[regnum]&USER_REGACC)
#define CAN_REGACC_REMOTE(regnum) (reg_access[regnum]&REMOTE_REGACC)
#define CAN_REGACC_SIM(regnum)    (reg_access[regnum]&SIM_REGACC)

/* Total amount of space needed to store our copies of the machine's
   register state, the array `registers' (and then some).  */
#define REGISTER_BYTES (NUM_REGS * sizeof(REGISTER_TYPE))

/* Total amount of space needed to store the general registers. */
#define GENERAL_REGISTER_BYTES (NUM_GENERAL_REGS * sizeof(REGISTER_TYPE))

/* Index within `registers' of the first byte of the space for
   register n.  */

#define REGISTER_BYTE(n) ((n)*sizeof(REGISTER_TYPE))

/* Number of bytes of storage in the actual machine representation
   for register n.  */

#define REGISTER_RAW_SIZE(n) (sizeof(REGISTER_TYPE))

/* Number of bytes of storage in the program's representation
   for register n. */

#define REGISTER_VIRTUAL_SIZE(n) (sizeof(REGISTER_TYPE))

/* Largest value REGISTER_RAW_SIZE can have.  */

#define MAX_REGISTER_RAW_SIZE (sizeof(REGISTER_TYPE))

/* Largest value REGISTER_VIRTUAL_SIZE can have. */

#define MAX_REGISTER_VIRTUAL_SIZE (sizeof(REGISTER_TYPE))

/* Nonzero if register N requires conversion
   from raw format to virtual format.  */

#define REGISTER_CONVERTIBLE(n) 0

/* Convert data from raw format for register regnum
   to virtual format for register regnum.  */

#define REGISTER_CONVERT_TO_VIRTUAL(regnum,from,to) \
	{bcopy ((from), (to), sizeof(REGISTER_TYPE));}

/* Convert data from virtual format for register regnum
   to raw format for register regnum.  */

#define REGISTER_CONVERT_TO_RAW(regnum,from,to) \
	{bcopy ((from), (to), sizeof(REGISTER_TYPE));}

/* Return the GDB type object for the "standard" data type
   of data in register N.  */

#define REGISTER_VIRTUAL_TYPE(n) (builtin_type_int)

/* Store the address of the place in which to copy the structure that the
   subroutine will return.  This is called from call_function. */

#define STORE_STRUCT_RETURN(addr, sp) \
  { (sp) -= sizeof (addr);		\
    write_memory ((sp), &(addr), sizeof (addr)); }

/* Extract from an array regbuf containing the (raw) register state
   a function return value of type type, and copy that, in virtual format,
   into valbuf.  */

#define EXTRACT_RETURN_VALUE(type,regbuf,valbuf) \
  {bcopy ((regbuf) + 8, (valbuf), TYPE_LENGTH (type));}

/* Extract from an array regbuf containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */

/*** @@@@@@ This is WRONG -- it's pointing to r0!  -=- andrew@@frip.wv.tek.com */

#define EXTRACT_STRUCT_VALUE_ADDRESS(regbuf) (*(int *)(regbuf))


/* Describe the pointer in each stack frame to the previous stack frame
   (its caller).  */

/* GreenHillsStyle: The Green Hills compiler need not produce a frame pointer.
   The VAL field in the stabs for variables allocated on the stack are
   offsets relative to the frame pointer, even if one is not used.  This is
   a 68k style frame pointer, so these offsets are negative.  A GreenHillsStyle
   frame looks like this:

                       +----------------------------+
                       |    return address (R1)     |
                       +----------------------------+
   pseudo FP ---->     |          not used          | (1)
                       +----------------------------+
                       |       local variables      |
                       |            . . .           |
                       +----------------------------+
                       |      register save area    | (2)
                       |            . . .           |
                       +----------------------------+
                       | arguments for next routine | (3)
                       |            . . .           |
                       +----------------------------+

   (1) Sometimes the Green Hills compiler generates a real frame pointer.
       This can happen when the user requests it (via flag -ga) or when the
       compiler feels it must.  If this subroutine generates a real frame
       pointer (R30), then the previous value of R30 will be saved in this
       field.

   (2) This area of the frame is used to "home" the argument registers and to
       save other registers, if needed.  The first eight words of
       arguments to a subroutine are passed in registers R2-R9.  When the
       compiler must use these registers, either for arguments to the next
       subroutine or for some other purpose, it will save these registers in
       this area of the frame.  This is called "homing."  If the compiler
       needs to save any other registers, this area may be used for that
       purpose.
       If the compiler never needs to home the argument registers, or save any
       other register, this portion of the frame is omitted, otherwise it is
       always at least 32 bytes.

   (3) Storage is allocated for all the arguments
       on the stack.  Only those arguments that could not be passed in
       registers will actually be stored here.  This portion of the frame is
       created just before the next subroutine is called.

   NOTE: Under some conditions, the compiler produces no frame at all.  Even
         so, the VAL fields of the stab entries for arguments allocated on
         the stack will be relative to the pseudo frame pointer.

   GnuStyle: The GNU compiler(s) always produce frame pointers.  The
   VAL field of the stabs for variables allocated on the stack are
   offsets relative to the frame pointer (R30) and are positive.  A
   GnuStyle frame looks like this:

                       +----------------------------+
                       |      local variables       |
                       |           . . .            |
                       +----------------------------+
                       |    return address (R1)     |
                       +----------------------------+
   real FP (R30) ----> |     previous FP (R30)      |
                       +----------------------------+
                       | arguments for next routine | (1)
                       |           . . .            |
                       +----------------------------+

   (1) When a subroutine is entered, the entire frame is created, with 36 bytes
       allocated for this area.  This is enough to home all the argument
       registers (as specified by the OCS).  It will extend this area, if
       needed, before a lower level subroutine is called.  */

/* FRAME_CHAIN takes a frame's nominal address and produces the frame's
   chain-pointer -- the address of the next older stack frame.

   FRAME_CHAIN_COMBINE takes the chain pointer and the frame's nominal address
   and produces the nominal address of the caller frame.

   However, if FRAME_CHAIN_VALID returns zero,
   it means the given frame is the outermost one and has no caller.
   In that case, FRAME_CHAIN_COMBINE is not used.  */

#define FRAME_CHAIN(thisframe) m88k_frame_chain(thisframe)

#define EXTRA_FRAME_INFO \
	CORE_ADDR subr_entry; \
        unsigned framesize; /* Size of this stack frame in bytes -rcb 3/90 */\
	CORE_ADDR sp; /* current stack pointer for this frame */

#define INIT_EXTRA_FRAME_INFO(fid) (m88k_init_extra_frame_info (fid))

/* If we are cross-debugging, be more open-minded about what a valid frame
   looks like.  We can't assume anything about the address, not even that
   it is in the downloaded program's text region. -rcb */
extern remote_debugging;
#define FRAME_CHAIN_VALID(chain, thisframe) \
	((chain) != 0 && \
	 (remote_debugging || \
	  (FRAME_SAVED_PC (thisframe) >= first_object_file_end)))

#define FRAME_CHAIN_COMBINE(chain, thisframe) (chain)

/* Define other aspects of the stack frame.  */

#define FRAME_SAVED_PC(frame) (m88k_find_return_address(frame))

#ifdef USEDGCOFF
#define FRAME_ARGS_ADDRESS(fi)  \
	synthesize_previous_sp((fi)->sp, (fi)->subr_entry, (fi)->pc)
#else
#define FRAME_ARGS_ADDRESS(fi) ((fi)->frame)
#endif

#ifdef USEDGCOFF
#define FRAME_LOCALS_ADDRESS(fi)  \
	synthesize_previous_sp((fi)->sp, (fi)->subr_entry, (fi)->pc)
#else
#define FRAME_LOCALS_ADDRESS(fi) ((fi)->frame)
#endif

/* Return number of args passed to a frame.
   Can return -1, meaning no way to tell.  */

#define FRAME_NUM_ARGS(numargs, fi)  (numargs) = -1

/* Return number of bytes at start of arglist that are not really args.  */

#define FRAME_ARGS_SKIP 8

/* Put here the code to store, into a struct frame_saved_regs,
   the addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special: the address we return
   for it IS the sp for the next frame.  Look at the comments in frame.h near
   the definition of frame_saved_regs for all the details. */

#define FRAME_FIND_SAVED_REGS(frame_info, frame_saved_regs) \
  m88k_frame_find_saved_regs ((frame_info), &(frame_saved_regs))

/* This next macro is similar to the previous one, except it does the job
   for only one register. The address is just returned. */

#define FRAME_FIND_SINGLE_SAVED_REG(fi, regnum) \
  m88k_frame_find_single_saved_reg ((fi), (regnum))

/* Things needed for making the inferior call functions.  */

/* Push an empty stack frame, to record the current PC, etc.  */

#define PUSH_DUMMY_FRAME { m88k_push_dummy_frame (); }

/* Discard from the stack the innermost frame, restoring all registers.  */

#define POP_FRAME  { m88k_pop_frame (); }

/*
	or.u	r10,r0,hi16(funcaddr)
	or	r10,r10,lo16(funcaddr)
	jsr	r10
	tb0	0,r0,129	* break point *
*/

#define CALL_DUMMY {0x5d400000,0x594a0000,0xf400c80a,0xf000d081}
#define REMOTE_CALL_DUMMY {0x5d400000,0x594a0000,0xf400c80a,0xf000d0fe}

#define CALL_DUMMY_LENGTH 16

#define CALL_DUMMY_START_OFFSET 0  /* Start execution at beginning of dummy */

/* Insert the specified number of args and function address
   into a call sequence of the above form stored at DUMMYNAME.  */

#define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, type)   \
	{ \
        int addr; \
	addr = (fun); \
	/* copy upper 16 bits of function address */ \
	bcopy(&addr,(char *)(&(dummyname)[0])+2, sizeof(short)); \
	/* copy lower 16 bits of function address */ \
	bcopy((char *)(&addr)+2,(char *)(&(dummyname)[1])+2, sizeof(short)); \
	}
@


1.23
log
@Made FRAME_ARGS_ADDRESS() and FRAME_LOCALS_ADDRESS() work with
DG debugging info and DG frames.
@
text
@d13 2
a14 2
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/m-m88k.h,v 1.22 90/11/01 12:55:13 robertb Exp $
   $Locker:  $
d66 4
a69 1
/* #define READ_DBX_FORMAT */
d71 3
@


1.22
log
@Defined BITS_BIG_ENDIAN to make bit fields work.  I wonder why this
was not set ealier.
@
text
@d13 2
a14 2
   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/m-m88k.h,v 1.21 90/10/30 23:55:21 robertb Exp Locker: robertb $
   $Locker: robertb $
d442 4
d447 1
d449 4
d454 1
@


1.21
log
@switched back to COFF
@
text
@d13 1
a13 1
   $Header: /home/bigbird/Usr.U6/robertb/g88/RCS/m-m88k.h,v 1.20 90/08/19 21:22:28 robertb Exp Locker: robertb $
d149 3
@


1.20
log
@Turned on dbx mode, turned off coff mode.
@
text
@d13 2
a14 2
   $Header: /home/vlsi/u2/cs568/g88/RCS/m-m88k.h,v 1.19 90/08/06 09:51:53 robertb Exp $
   $Locker:  $
d66 2
a67 2
#define READ_DBX_FORMAT
/* #DEFine COFF_FORMAT */
@


1.19
log
@deleted useless header.
@
text
@d13 2
a14 2
   $Header: /home/vlsi/u2/cs568/g88/RCS/m-m88k.h,v 1.18 90/06/30 17:37:40 robertb Exp Locker: robertb $
   $Locker: robertb $
d66 2
a67 2
/* #define READ_DBX_FORMAT */
#define COFF_FORMAT
@


1.18
log
@Removed reference to USRSTACK, put questionable constant in
instead.
@
text
@d13 1
a13 1
   $Header: /home/bigbird/Usr.U6/robertb/gdb/RCS/m-m88k.h,v 1.17 90/03/28 14:29:50 robertb Exp Locker: robertb $
d21 1
a21 15
This file is part of GDB.

GDB is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 1, or (at your option)
any later version.

GDB is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GDB; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.17
log
@Added Added IS_PARAM_REG().
Added REMOTE_BREAKPOINT and REMOTE_CALL_DUMMY to support cross debugging.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.16 90/03/16 08:03:32 andrew Exp $
   $Locker:  $
d114 1
a114 1
#define STACK_END_ADDR ((CORE_ADDR)USRSTACK)	/* defined in <sys/param.h> */
@


1.16
log
@Implement Paul's TEK_HACK_OF_THE_FUTURE: the FRAME_SAVED_PC macro
now uses a heuristic to find a frame's return address, rather than assume
that every routine saves it in a stack frame (which isn't true of most
assembly code).
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.15 90/03/15 09:10:21 andrew Exp $
   $Locker: andrew $
d128 1
d251 3
d433 1
d500 1
@


1.15
log
@Remove lots of confusing #ifdefs which are irrelevant to system V 88k.
(This is a machine-dependent file, after all.)
Fix the ABOUT_TO_RETURN macro.
Fix macro definitions so that argument uses are fully parenthesized.
Fix lots of comment errors.
Complete register rework.
@
text
@d13 1
a13 1
   $Header: m-m88k.h,v 1.14 90/02/02 16:05:54 marvinw Exp $
d446 1
a446 7
#ifdef TEK_HACK_OF_THE_FUTURE
/* Would fix the case where someone sets a breakpoint at the entry point of a
   subroutine. */
#define FRAME_SAVED_PC(frame) (m88k_frame_saved_pc(frame))
#else /* not TEK_HACK_OF_THE_FUTURE */
#define FRAME_SAVED_PC(framep) (read_memory_integer ((framep)->frame+4, 4))
#endif /* not TEK_HACK_OF_THE_FUTURE */
@


1.14
log
@Changed trap instruction in CALL_DUMMY to tb0	0,r0,129.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.13 90/02/02 14:24:35 andrew Exp $
   $Locker: marvinw $
a36 44


/* 
 * Changes made by Tektronix are marked by TEK_HACK, TEK_PROG_HACK, 
 * and GHSFORTRAN.
 * Changes made by Data General are marked by DG_HACK.  Compiling without these
 * #defines should be equivalent to compiling vanilla 3.2, more or less.
 *
 * The changes done by Tektronix fit into three catagories:
 *	TEK_HACK -- these were done just to get GDB to work in our environment,
 *		    including work done to support the Green Hills C compiler.
 *	TEK_PROG_HACK -- These were done to extend GDB by adding programming
 *			 support: things like if-elif-else-endif, while, and
 *			 arguments to user defined commands.
 *	GHSFORTRAN -- These changes make (will make) GDB work with the Green
 *		      Hills Fortran compiler.
 *
 *
 * In addition, I/O routines were renamed so that I/O could be directed
 * to/from the X interface if used.  See the files ui.c and ui.h for
 * more information.  Here are the routines renamed:
 *    Old name:			Renamed to:
 *	fprintf			ui_fprintf
 *	printf			ui_fprintf(stdout
 *	putchar			ui_putchar
 *	putc			ui_putc
 *	fputc			ui_putc
 *	fputs			ui_fputs
 *	puts			ui_puts
 *	gets			ui_gets
 *	fgets			ui_fgets
 *	fflush			ui_fflush
 *	system			ui_system
 *	wait			ui_wait
 *	error			ui_badnews(-1
 *	fatal			ui_badnews(1
 *	getc, fgetc		replaced with ui_gets, ui_fgets
 * These changes are not demarcated by ifdef.   
 *
 *					November 16, 1989
 */



d46 1
a46 1
#ifndef MAXPATHLEN 
d55 1
a55 1
#define COFF_NO_LONG_FILE_NAMES 
d60 2
a61 2
#define NBPG NBPC
#define UPAGES USIZE
a68 2


d83 2
a84 2
/* number of traps that happen between exec'ing the shell 
 * to run an inferior, and when we finally get to 
d94 2
a95 2
/* Advance PC across any function entry prologue instructions
   to reach some "real" code.  */
d97 1
a97 1
#define SKIP_PROLOGUE(frompc)   0
d104 1
a104 2
#define SAVED_PC_AFTER_CALL(frame) \
  (read_register (SRP_REGNUM))
d107 2
a108 1
   to get the offset in the core file of the register values.  */
d110 1
a110 3
/* Since registers r0 through r31 are stored directly in the struct ptrace_user,
   (for m88k BCS)
   the ptrace_user offsets are sufficient and KERNEL_U_ADDRESS can be 0 */
a111 2
#define KERNEL_U_ADDR 0

d114 1
a114 1
#define STACK_END_ADDR ((CORE_ADDR)(0xF0000000))
d121 2
a122 2
#define BAD_STACK_ADDR(addr) (((CORE_ADDR)(addr) >= STACK_END_ADDR) || \
                        ((CORE_ADDR)(addr) < read_register (SP_REGNUM)))
d125 2
a126 6
/* Sequence of bytes for breakpoint instruction.  */

/* instruction 0xF000D081 is 'tb0 0,r0,129'
   If Bit bit 0 of r0 is clear (always true),
   initiate exception processing (trap).
 */
a128 2


d131 9
a139 1
   but not always.  */
d141 1
a141 1
#define DECR_PC_AFTER_BREAK 0 
d143 3
a145 2
/* Nonzero if instruction at PC is a return instruction.  */
/* 'jmp r1' or 'jmp.n r1' is used to return from a subroutine. */
d147 2
a148 1
#define ABOUT_TO_RETURN(pc) (read_memory_integer (pc, 2) == 0xF800)
d153 1
a153 1
#define INVALID_FLOAT(p, len) IEEE_isNAN(p,len)
a164 77
/* Number of machine registers */

/* #define NUM_REGS 64 */
#define NUM_REGS 39

/* Initializer for an array of names of registers.
   There should be NUM_REGS strings in this initializer.  */

 /* this table must match regmap in m88k-pinsn.c. */
#define REGISTER_NAMES {\
 	"zero",\
	"srp",\
	"r2",\
	"r3",\
	"r4",\
	"r5",\
	"r6",\
	"r7",\
	"r8",\
	"r9",\
	"r10",\
	"r11",\
	"r12",\
	"r13",\
	"r14",\
	"r15",\
	"r16",\
	"r17",\
	"r18",\
	"r19",\
	"r20",\
	"r21",\
	"r22",\
	"r23",\
	"r24",\
	"r25",\
	"linker26",\
	"linker27",\
	"linker28",\
	"linker29",\
	"fp",\
	"sp",\
	"psr",\
	"fpsr",\
	"fpcr",\
	"pid",\
	"sxip",\
	"snip",\
	"sfip",\
	"vbr",\
	"dmt0",\
	"dmd0",\
	"dma0",\
	"dmt1",\
	"dmd1",\
	"dma1",\
	"dmt2",\
	"dmd2",\
	"dma2",\
	"sr0",\
	"sr1",\
	"sr2",\
	"sr3",\
	"fpecr",\
	"fphs1",\
	"fpls1",\
	"fphs2",\
	"fpls2",\
	"fppt",\
	"fprh",\
	"fprl",\
	"fpit",\
	"fpsr",\
	"fpcr",\
	};


d172 8
a179 10
#define SRP_REGNUM 1		/* contains subroutine return pointer */
#define FP_REGNUM 30		/* Contains address of executing stack frame */
#define SP_REGNUM 31		/* Contains address of top of stack */
#define SXIP_REGNUM 36		/* Contains Shadow Execute Instruction Pointer */
#define SNIP_REGNUM 37		/* Contains Shadow Next Instruction Pointer */
#define PC_REGNUM SXIP_REGNUM	/* Program Counter */
#define NPC_REGNUM SNIP_REGNUM	/* Next Program Counter */
#define PSR_REGNUM 32           /* Process Status Register KLUDGE */ 
#define FPSR_REGNUM 33		/* Floating Point Status Register */
#define FPCR_REGNUM 34		/* Floating Point Control Register */
d181 2
a182 7
/*** Definition of PID_REGNUM commented out.
 *** I think the original GNU-88k porters were confused by this symbol;
 *** there is a "pid" register in the 88k which contains the PROCESSOR id.
 *** This has nothing at all to do with PROCESS id or PARENT id.
 ***  -=- andrew@@frip.wv.tek.com
 *** #define PID_REGNUM  35		Process ID of parent of debuggee
 ***/
d184 6
a189 4
#define SFIP_REGNUM 38		/* Contains Shadow Fetched Intruction pointer */
#ifdef	TEK_HACK
#define REGISTER_U_ADDR(addr, blockend, regno) \
	(addr) = m88k_register_u_addr ((blockend),(regno));
d191 24
a214 4
#else /* not TEK_HACK */
#define REGISTER_U_ADDR(addr, blockend, regno) \
	(addr) = m88k_register_u_addr ((blockend),(regnum));
#endif	/* not TEK_HACK */
d216 51
d268 1
a268 1
   register state, the array `registers'.  */
d271 3
d275 1
a275 1
   register N.  */
d277 1
a277 1
#define REGISTER_BYTE(N) ((N)*sizeof(REGISTER_TYPE))
d280 1
a280 1
   for register N.  */
d282 1
a282 1
#define REGISTER_RAW_SIZE(N) (sizeof(REGISTER_TYPE))
d285 1
a285 1
   for register N. */
d287 1
a287 1
#define REGISTER_VIRTUAL_SIZE(N) (sizeof(REGISTER_TYPE))
d291 1
a291 1
#define MAX_REGISTER_RAW_SIZE (sizeof(REGISTER_TYPE)) 
d293 1
a293 2
/* Largest value REGISTER_VIRTUAL_SIZE can have. 
/* Are FPS1, FPS2, FPR "virtual" regisers? */
d300 1
a300 1
#define REGISTER_CONVERTIBLE(N) (0)
d302 2
a303 2
/* Convert data from raw format for register REGNUM
   to virtual format for register REGNUM.  */
d305 2
a306 1
#define REGISTER_CONVERT_TO_VIRTUAL(REGNUM,FROM,TO) {bcopy ((FROM), (TO), (sizeof(REGISTER_TYPE)));}
d308 2
a309 2
/* Convert data from virtual format for register REGNUM
   to raw format for register REGNUM.  */
d311 2
a312 1
#define REGISTER_CONVERT_TO_RAW(REGNUM,FROM,TO) {bcopy ((FROM), (TO), (sizeof(REGISTER_TYPE)));}
d317 1
a317 1
#define REGISTER_VIRTUAL_TYPE(N) (builtin_type_int)
d319 1
a319 1
/* Store the address of the place in which to copy the structure the
d322 3
a324 3
#define STORE_STRUCT_RETURN(ADDR, SP) \
  { (SP) -= sizeof (ADDR);		\
    write_memory ((SP), &(ADDR), sizeof (ADDR)); }
d326 3
a328 3
/* Extract from an array REGBUF containing the (raw) register state
   a function return value of type TYPE, and copy that, in virtual format,
   into VALBUF.  */
d330 2
a331 2
#define EXTRACT_RETURN_VALUE(TYPE,REGBUF,VALBUF) \
  bcopy (REGBUF + 8, VALBUF, TYPE_LENGTH (TYPE))
d333 1
a333 7
/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  */

#define STORE_RETURN_VALUE(TYPE,VALBUF) \
  write_register_bytes (0, VALBUF, TYPE_LENGTH (TYPE))

/* Extract from an array REGBUF containing the (raw) register state
d337 1
a337 1
#define EXTRACT_STRUCT_VALUE_ADDRESS(REGBUF) (*(int *)(REGBUF))
d339 2
d345 2
a346 2
/* GreenHillsStyle: The Green Hills compiler seldom produces a frame pointer.
   The VAL field in the stabs for variables allocated on the stack are 
d354 1
a354 1
   psuedo FP ---->     |          not used          | (1)
d369 2
a370 1
       pointer (R30), then the previous value of R30 be saved in this field.
d373 1
a373 1
       save other registers, if needed.  If possible, the first eight words of
d377 3
a379 2
       this area of the frame.  This is called "homeing".  If the compiler
       needs to save any other registers, this area is used for that purpose.
d381 1
a381 1
       other retister, this portion of the frame is ommited, otherwise it is
d384 1
a384 2
   (3) If, when the next subroutine is called, all of its arguments can not be
       passed in registers, then storage is allocated for all the arguments
d391 1
a391 1
         the stack will be relitive to the psuedo frame pointer.
d393 4
a396 12
   BUG: This convension, used by C-88000 1.8.4, appears to violate the
        Object Compatiblity Standard (OCS) of the of the 88open Consortium.
        To be in conformance, the field labeled (3) above must always be
        allocated 32 bytes.  It could be temporarily grown, if needed, before
        the next subroutine call.  If this were done, then the field labeld (2)
        above would not be need because argument registers could be homed in
        field (3) of the previous frame (see GnuStyle below).
                   
/* GnuStyle: The GNU compiler(s) always produce frame pointers.  The VAL field
    of the stabs for variables allocaded on the stack are offsets relitive to
    the frame pointer (R30) and are positive.  A GnuStyle frame looks like
    this:
d415 2
a416 2
/* FRAME_CHAIN takes a frame's nominal address
   and produces the frame's chain-pointer.
a424 1
#ifdef TEK_HACK
a425 1
/* FRAME_ADDR m88k_frame_chain(); */
d428 2
a429 2
CORE_ADDR subr_entry; \
CORE_ADDR sp; /* current stack pointer for this frame */
a431 3
#else
#define FRAME_CHAIN(thisframe) (read_memory_integer ((thisframe)->frame, 4))
#endif /* TEK_HACK */
d433 1
a433 1
/* If we are cross-debugging be more open-minded about what a valid frame
d438 3
a440 2
              (chain != 0 && (remote_debugging || \
                   (FRAME_SAVED_PC (thisframe) >= first_object_file_end)))
d451 1
a451 1
#define FRAME_SAVED_PC(FRAME) (read_memory_integer ((FRAME)->frame+4, 4))
d477 1
a477 1
/* This next macro is the simular to the previous one, except it does the job
a486 1
#ifdef TEK_HACK
d502 1
a502 1
#define CALL_DUMMY_LENGTH 16 
d512 1
a512 1
	addr = fun; \
d514 1
a514 1
	bcopy(&addr,(char *)(&dummyname[0])+2, sizeof(short)); \
d516 1
a516 1
	bcopy((char *)(&addr)+2,(char *)(&dummyname[1])+2, sizeof(short)); \
a517 74
#else
#define PUSH_DUMMY_FRAME {/* m88k_push_dummy_frame ();  */}

/* Discard from the stack the innermost frame, restoring all registers.  */

#define POP_FRAME  { /* m88k_pop_frame ();*/ }

/* this is 
 *   call 11223344 (32 bit relative)
 *   int3
 */

#define CALL_DUMMY { 0x223344e8, 0xcc11 }

#define CALL_DUMMY_LENGTH 8

#define CALL_DUMMY_START_OFFSET 0  /* Start execution at beginning of dummy */

/* Insert the specified number of args and function address
   into a call sequence of the above form stored at DUMMYNAME.  */

#define FIX_CALL_DUMMY(dummyname, pc, fun, nargs, type)   \
{ \
	int from, to, delta, loc; \
	loc = (int)(read_register (SP_REGNUM) - CALL_DUMMY_LENGTH); \
	from = loc + 5; \
	to = (int)(fun); \
	delta = to - from; \
	*(int *)((char *)(dummyname) + 1) = delta; \
}
#endif


#if 0
/* Interface definitions for kernel debugger KDB.  */

/* Map machine fault codes into signal numbers.
   First subtract 0, divide by 4, then index in a table.
   Faults for which the entry in this table is 0
   are not handled by KDB; the program's own trap handler
   gets to handle then.  */

#define FAULT_CODE_ORIGIN 0
#define FAULT_CODE_UNITS 4
#define FAULT_TABLE    \
{ 0, 0, 0, 0, 0, 0, 0, 0, \
  0, 0, 0, 0, 0, 0, 0, 0, \
  0, 0, 0, 0, 0, 0, 0, 0}

/* Start running with a stack stretching from BEG to END.
   BEG and END should be symbols meaningful to the assembler.
   This is used only for kdb.  */

#define INIT_STACK(beg, end)  {}

/* Push the frame pointer register on the stack.  */
#define PUSH_FRAME_PTR        {}

/* Copy the top-of-stack to the frame pointer register.  */
#define POP_FRAME_PTR  {}

/* After KDB is entered by a fault, push all registers
   that GDB thinks about (all NUM_REGS of them),
   so that they appear in order of ascending GDB register number.
   The fault code will be on the stack beyond the last register.  */

#define PUSH_REGISTERS        {}

/* Assuming the registers (including processor status) have been
   pushed on the stack in order of ascending GDB register number,
   restore them and return to the address in the saved PC register.  */

#define POP_REGISTERS      {}
#endif
@


1.13
log
@Change breakpoint exception from 511 to 129.  That is, the breakpoint
instruction has changed from 'tb0 0,r0,511' to 'tb0 0,r0,129'.
This is because the BCS rigidly requires that exceptions 504 through 511
not back up the instruction pointers (by setting SFIP=SNIP; SNIP=SXIP),
bug gdb expects this behavior of the kernel when a breakpoint is taken.
The BCS isn't quite so rigid about trap 129.  (In fact, it requires
that this trap send signal SIGSYS, but the BCS verification suite
doesn't check it), so the kernel will continue to back up the IPs
for trap 129.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.12 90/01/02 16:58:39 robertb Exp $
   $Locker: andrew $
d177 1
a177 1
/* instruction 0xF000D1FF is 'tb0 0,r0,129'
d566 1
a566 1
	tb0	0,r0,511	* break point *
d569 1
a569 1
#define CALL_DUMMY {0x5d400000,0x594a0000,0xf400c80a,0xf000d1ff}
@


1.12
log
@Added type coercions to macro BAD_STACK_ADDR().  Code in m88k-dep.c
had been passing a signed integer to this macro and that was
causing a bug.  I also fixed the declaration of the value passed
to the macro.  A belt-and-suspenders fix.

I made FRAME_CHAIN_VALID more openminded about what a valid frame
pointer looks like when cross-debugging.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.11 89/12/18 17:19:56 andrew Exp $
   $Locker: robertb $
d177 1
a177 1
/* instruction 0xF000D1FF is 'tb0 0,r0,511'
d181 1
a181 1
#define BREAKPOINT {0xF0, 0x00, 0xD1, 0xFF}
@


1.11
log
@Delete definitions of USIZE and PID_REGNUM.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.10 89/11/30 14:35:13 marvinw Exp $
   $Locker: andrew $
d164 1
a164 1
#define STACK_END_ADDR 0xF0000000
d171 2
a172 2
#define BAD_STACK_ADDR(addr) (((addr) >= STACK_END_ADDR) || \
                              ((addr) < read_register (SP_REGNUM)))
d502 4
a505 1

d507 2
a508 1
  (chain != 0 && (FRAME_SAVED_PC (thisframe) >= first_object_file_end))
@


1.10
log
@Moved the macro CALL_DUMMY from valops.c back to this file.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.9 89/11/17 08:10:11 davidl Exp $
   $Locker: marvinw $
a103 1
#define USIZE 2048    /* This is a KLUDGE (jfs) */
d305 9
a313 1
#define PID_REGNUM  35		/* Process ID of parent of debuggee */
@


1.9
log
@Added Tek header information.
@
text
@d13 2
a14 2
   $Header: m-m88k.h,v 1.8 89/11/16 13:28:17 davidl Exp $
   $Locker: davidl $
d544 33
d606 1
@


1.8
log
@Standardized GDB header comment in each file so a script to add Tek-specific
commends (regarding ifdef TEK_HACK, etc.) will work.
@
text
@d13 1
a13 1
   $Header: m-m88k.h,v 1.7 89/10/03 12:19:05 marvinw Exp $
d36 42
@


1.7
log
@We no longer define COFF_NO_LONG_FILE_NAMES when TEK_HACK is defined.
@
text
@d13 3
a15 2
   $Header: m-m88k.h,v 1.6 89/09/21 10:18:43 paulg Exp $
   $Locker: marvinw $
d17 2
a18 5
GDB is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY.  No author or distributor accepts responsibility to anyone
for the consequences of using it or for whether it serves any
particular purpose or works at all, unless he says so in writing.
Refer to the GDB General Public License for full details.
a19 6
Everyone is granted permission to copy, modify and redistribute GDB,
but only under the conditions described in the GDB General Public
License.  A copy of this license is supposed to have been given to you
along with GDB so you can know your rights and responsibilities.  It
should be in a file named COPYING.  Among other things, the copyright
notice and this notice must be preserved on all copies.
d21 17
a37 3
In other words, go ahead and share GDB, but don't try to stop
anyone else from sharing it farther.  Help stamp out software hoarding!
*/
@


1.6
log
@add rcsid stuff
@
text
@d13 2
a14 2
   $Header:  $
   $Locker:  $
d50 1
d52 1
@


1.5
log
@moved THE_UNKNOWN to def.h
@
text
@d13 3
@


1.4
log
@Add stuff in support of finding a register value for a given frame.
@
text
@a258 3
/* What to say if you can't find a registers value. */
#define THE_UNKNOWN "???"

@


1.3
log
@1) Changed FRAME_CHAIN to call m88k_frame_chain (new to m88k-dep.c).
2) added new macro BAD_STACK_ADDR.  3) added comments explaining stack
frames on the 88k as produced by the Green Hills and GNU compilers.
@
text
@d258 5
a262 1
#else
d265 1
a265 1
#endif	/* TEK_HACK */
d435 6
d453 5
d459 1
d477 3
a479 2
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */
d482 1
a482 1
{/* m88k_frame_find_saved_regs ((frame_info), &(frame_saved_regs)); */ }
d484 5
@


1.2
log
@merge in Data General stuff: get clean compile.
@
text
@d5 3
d118 5
d341 77
d428 4
d433 2
@


1.1
log
@Initial revision
@
text
@d44 1
a44 1
/*  #define COFF_NO_LONG_FILE_NAMES */ 
d247 1
d249 3
d253 1
@
