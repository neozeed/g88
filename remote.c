/* Memory-access and commands for cross-debugging

   Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.

   $Header: /am/bigbird/home/bigbird/Usr.U6/robertb/m88k/src/g88/RCS/remote.c,v 1.33 91/01/13 23:52:47 robertb Exp $
   $Locker:  $

This file is part of GDB. */


#include <ctype.h>
#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/file.h>
#include <sys/time.h>
#ifdef SYSV
#include <termio.h>
#endif
#include <string.h>
#ifdef SYSV
#include <stropts.h>
#endif
#include <sys/types.h>
#include <sys/timeb.h>

#include "defs.h"
#include "param.h"
#include "frame.h"
#include "inferior.h"
#include "wait.h"
#include "expression.h"
#include "symtab.h"
#include "ui.h"
#include "value.h"

#include "montraps.h"
#include "remote.h"
#include "hmon/mon.h"

#define REMOTE_ENV_BAUD		"REMOTEBAUD"

#define	DEFAULT_RESET_TIMEOUT	(10)	/* Seconds to wait for target to reset*/
boolean resetting_remote;
boolean nmiing_remote;
boolean remote_errno;
boolean ignore_errors;			/* True while interrupting target */

u_char cpu_enabled[MAX_PROCESSORS];

int stop_cause;		/* Is (1 << SIGINT), (1 << SIGTRAP), or the or both */
int simulator;		/* True => we are using simulator.                  */

#define	L_BYTE		(1)
#define	L_SHORT		(2)
#define	L_WORD		(4)
#define	L_QUOTED1	(COMMAND_PREFIX1)
#define	L_QUOTED2	(COMMAND_PREFIX2)

struct compress {
	unsigned pattern;
	unsigned length;
};

#define	SIZEOF_COMPRESS_TABLE (sizeof(struct compress) * 256)

static void comm_err();
extern void request_quit ();
/* Variables for the remote tty line output buffer that we maintain
   in this file. */
static u_long output_buffercnt;
static unsigned char output_buffer[BUFSIZ];
static unsigned char *out_bp;
static void init_input_buffer();

static u_char input_buffer[BUFSIZ];
static u_char *input_buffer_p;
static input_buffer_cnt;
static void init_output_buffer();
static void flush_output_buffer();

jmp_buf controlc_env;
static u_char prev_char;

/* Last instruction to be fetched in preparation for printing the
   effect of the execution of this instruction after a single step. */
u_long last_iword;

/* The address from or to which the instruction in 'last_iword' would access. */
static CORE_ADDR ld_st_addr;

/* Checksum generated by the 'add_to_checksum()' macro in remote.h */
u_long checksum;

/* True if characters received or sent should be "added" to the checksum */
static u_long checksumming;

/* Partial word received from the target.  See 'get_byte()'. */
static u_long partial;

/* Number of bytes (0..3) of 'partial' that are valid. */
static u_long partial_length;

/* Forward declarations of functions in this file.  */

void open_debug_port();
void close_debug_port();
void close_control_port();
static void add_to_text_buffer();
static boolean user_mode_access();
static void interrupt_remote();

static boolean tty_line_init();
static boolean checksum_compress_table();
static unsigned long remote_188syscall();
void remote_select_processor();

/* These values are returned by the target when we first attach. */

u_long mon_compress_table_addr;	/* Only sent by XD-88 monitor                 */
u_long mon_dacc_address_addr;	/* Only sent by tek188mon (Moto)              */
u_long mon_report_comm_errors_addr;  /* Dito */

/* Target address of monitor's register area  for each processor */
u_long mon_register_area_addr[MAX_PROCESSORS];

u_long mon_single_step_trap_addr;  /* Target address of tb0 0,r0,253 instruc. */
u_long mon_date_addr;		   /* Target address of date string           */
u_long mon_time_addr;		   /* Target address of time string           */
u_long mon_panic_code_addr;	/* Target address of word w/ error code       */

u_long bytes_transmitted;
u_long total_bytes_transmitted;
u_long bytes_received;
u_long total_bytes_received;	/* # of bytes received in download process    */
double start_time;		/* Time that last download was started        */
double end_time;		/* Time that last download finished           */
u_long total_bytes_downloaded;  /* Number of bytes sent to target to download */
boolean downloaded;		/* True after download, used to warn user     */

char remote_tty_name[200];	/* File name of remote tty line               */
int remote_fd = -1;		/* File descriptor of remote tty line         */
int current_baud;		/* Current data rate of remote tty line       */
char lock_fname[1000];		/* File name of lock file for remote tty line */
boolean lock_gotten;		/* True if we have the remote tty line lock   */

int *reset_env;

struct compress compress_table[] = {
#include "compress.h"
};

static int direction;		/* 1 or 2 for receiving or transmitting       */

#ifndef _WIN32
static struct itimerval new_timerval;
static struct itimerval old_timerval;
#endif

extern char *malloc();

/* Return true if the parameter is a data rate that we can set the tty
   line to. */
boolean
valid_baud(baud)
  int baud;
{
  switch (baud) {
    case 50:   case 75:    case 110:   case 150:   case 200:   case 300:
    case 600:  case 1200:  case 1800:  case 2400:  case 4800:
    case 9600: case 19200: case 38400:	
      return true;
  }
  return false;
}


/* Make sure that no one else is using the target.  We open a special
   file in /tmp to indicate that we are using it.  If the file already
   exists, perhaps some one else is using the target. */

void get_debug_line_mutex(debug_fname)
  char *debug_fname;
{
  int fd;
  char *p = rindex(debug_fname, '/');  /* Get tail of debug line file name*/

  if (lock_gotten) {
    return;
  }
  strcpy(lock_fname, "/tmp/gdb-lock-");
  if (p) {
    strcat(lock_fname, p + 1);
  }

  fd = open(lock_fname, O_RDONLY);
  if (fd > 0) {
    close(fd);
    rerr("Lock file %s exists, perhaps some one else is using the target?", 
                    lock_fname);
  }
  fd = open(lock_fname, O_CREAT, 0600);
  if (fd < 0) {
    rerr("Can not open lock file %s", lock_fname);
  }
  if (close(fd) != 0) {
    rerr("Error closing lock file %s", lock_fname);
  }
  lock_gotten = 1;
}

/* We are done with the debug line, get rid of the lock file. */

void release_debug_line_mutex()
{
  if (lock_gotten && unlink(lock_fname) != 0) {
    rerr("Error doing unlink of %s", lock_fname);
  }
  lock_gotten = 0;
}

/* Open a connection to a remote debugger.
   NAME is the filename used for communication.  */

void remote_open(name, from_tty)
  char *name;
  int from_tty;
{
  extern stop_after_attach;

  setvar("motomode", 1);  /* Delete this when we might run a Tek target */
  if (remote_debugging && !strcmp(name, remote_tty_name)) {
    rerr("Already attached to %s", remote_tty_name);
  }
  get_debug_line_mutex(name);
  if (!valid_baud(varvalue("baudrate"))) {
    setvar("baudrate", 38400);
  }
  strcpy(remote_tty_name, name);
  open_debug_port();
  spllo();
  if (varvalue("resetonattach")) {
    reset_remote();
  } else { 
    interrupt_remote();
  }

  print_comm_statistics();
  stop_after_attach = 1;

  /* What ptrace reports after attaching a process */
  stop_cause |= (1 << SIGTRAP);

  get_monitor_addresses();
  remote_debugging = 1;
}

/* Close the tty port used to communicate with the target if it is open */

void close_debug_port()
{
  if (remote_fd > 0) {
    if (close(remote_fd) != 0) {
      ui_badnews(-1, "close_debug_port: error closing %s", remote_tty_name);
    }
    remote_fd = -1;
  }
}

/*
 * This closes the tty line that we've been communicating with the target
 * over.  Since we do not have output flow control (DOCTS), we shouldn't
 * block here.
 */
void remote_close(from_tty)
{
  release_debug_line_mutex();
  close_control_port();
  close_debug_port();
}

/* Called when we get an error.  Display the
   error message after turning interrupts back on. */

/*VARARGS1*/
void rerr(fmt, a, b, c, d, e, f, g)
  char *fmt;
{
  spllo();
  ui_badnews(-1, fmt, a, b, c, d, e, f, g);
}

/*
 * This is called when we get an error command from the target.  
 */
void handle_target_rerr(c)
    u_char c;
{
    switch (c) {
        case C_CHECKSUMERR:
            ui_fprintf(stderr, 
                  "Target got checksum error, it expected 0x%x but got 0x%x\n",
                            get_word(), get_word());
            break;

        case C_BADCOMMAND:
            ui_fprintf(stderr, "Target got bad command: %s\n", 
                           comm_name(get_byte(), COMMAND_PREFIX1));
            break;

        case C_COMMERR:
            ui_fprintf(stderr, 
                    "Target got communication error on receive, status=0x%x\n",
                            get_byte());
            break;

        case C_COMPRESSERR:
            ui_fprintf(stderr,
                     "Target got a compression error, it must be quite ill\n");
            break;

        case C_EXPECTEDTOKEN:
            ui_fprintf(stderr, "Target expected %s, but got %s\n", 
                           comm_name(get_byte(), COMMAND_PREFIX1), 
                           comm_name(get_byte(), COMMAND_PREFIX1));
            break;

        default:
          rerr("Case error in handle_target_error()");
    }

    /* If the target is not running, we want to abort the current
       command.  If it was in g88_read() or g88_write(), we want
       to keep listening to the debug port in the hope that the
       target will be ok by the time it hits an exception.  If
       it was running, but got the comm error while trying to
       tell us about its exception, we will erroneously keep
       waiting for the exception. */
    if (!target_running) {
      rerr("");
    }
}

/*
 * Initialize most of the variables used in cross-debugging.
 */
void init_globals()
{
  int i;
  for (i = 0 ; i < MAX_PROCESSORS ; i++) {
    cpu_enabled[i] = 0;
  }
  selected_processor = 0;
  cpu_enabled[0] = 1;
  stop_cause = 0;
  target_running = false;
  downloaded = false;
  resetting_remote = false;
  nmiing_remote = false;
  ignore_errors = false;
  remote_errno = false;
  total_bytes_transmitted = 0;
  total_bytes_received = 0;
  bytes_transmitted = 0;
  bytes_received = 0;
  start_time = 0.0;
  end_time = 0.0;
  partial = 0;
  partial_length = 0;
  checksumming = 0;
  checksum = 0;
  current_baud = 0;  /* Force it to be set next time setbaud() is called */
  invalidate_mem_cache();
  init_output_buffer();
  init_input_buffer();
  init_buffers();
}

#define BUFFERSIZE	(200)

struct buffer *receive_buffer, *transmit_buffer;

/* We store the last BUFFERSIZE (or $buffersize, if it is set) lines that
   were or would have been displayed by having $traceremote set. This
   supports the lasta command. */

char **text_buffer_base, **text_buffer;
int text_buffer_index, text_buffer_size;

/* Set up a buffer for transmitted and received characters so that
   the user can look look at a transactions w/ the target after it
   has happened. */
void init_buffers()
{
  int buffersize = varvalue("buffersize");
  if (buffersize == 0) {
    setvar("buffersize", buffersize = BUFFERSIZE);
  }
  if (receive_buffer != (struct buffer *)0) {
    free((char *)receive_buffer);
  }
  receive_buffer = (struct buffer *)malloc(sizeof(struct buffer));
  receive_buffer->data = (u_char *)malloc(buffersize);
  receive_buffer->size = buffersize;
  receive_buffer->head = 0;

  if (transmit_buffer != (struct buffer *)0) {
    free((char *)transmit_buffer);
  }
  transmit_buffer = (struct buffer *)malloc(sizeof(struct buffer));
  transmit_buffer->size = buffersize;
  transmit_buffer->data = (u_char *)malloc(buffersize);
  transmit_buffer->head = 0;

  /* Free any storage that the previous text buffer had been using. */
  if (text_buffer_base != (char **)0) {
    int i;
    text_buffer = text_buffer_base;
    for (i = 0 ; text_buffer && *text_buffer && i < text_buffer_size ; i++) {
      free(*text_buffer++);
    }
    free((char *)text_buffer_base);
  }
  text_buffer_size = buffersize;
  text_buffer_base = (char **)malloc(sizeof(char *) * text_buffer_size);
  bzero((char *)text_buffer_base, sizeof(char *) * text_buffer_size);
  text_buffer = text_buffer_base;
  text_buffer_index = 0;
}

/* Take the passed line of text and copy into to some newly malloc'd
   memory and make the current text buffer slot point to it. */

static void add_to_text_buffer(text)
  char *text;
{
  if (*text_buffer != (char *)0) {
    free(*text_buffer);
  }
  *text_buffer = malloc(strlen(text) + 1);
  strcpy(*text_buffer, text);
  text_buffer++;
  text_buffer_index++;
  if (text_buffer_index == text_buffer_size) {
    text_buffer = text_buffer_base;
    text_buffer_index = 0;
  }
}

/* Add the passed character to the passed buffer. */

static void add_to_buffer(buffer, c)
  struct buffer *buffer;
  u_char c;
{
  buffer->data[buffer->head] = c;
  buffer->head = (buffer->head + 1) % buffer->size;
}


/* This is called by functions that interact with the target.  They pass
   printf-like arguments that describe what they are doing with the target
   and what the target is reponding with.  If $traceremote is set, we
   display the string.  In any case, we save the string in a text buffer
   that can be displayed with the lasta command. */

/*VARARGS1*/
void traceremote(fmt, a, b, c, d, e, f, g, h)
  char *fmt;
{
  char buf[1000];
  if (varvalue("traceremote")) {
    ui_fprintf(stderr, fmt, a, b, c, d, e, f, g, h);
  }
  sprintf(buf, fmt, a, b, c, d, e, f, g, h);
  add_to_text_buffer(&buf[0]);
}

/* This flushes any crud that might be waiting for us.  */

void flush_tty_line()
{
#define FBUFSIZE (1000)		/* Size of flush buffer.                  */
#define SHOWCNT	 (300)		/* Number of flushed chars to display     */

    u_char buf[FBUFSIZE], prev_char;
    int  cnt, i, first_time = 1;
    int  overall_cnt = 0;

    prev_char = '\0';
    init_output_buffer();
    while ((cnt = read(remote_fd, (char *)&buf[0], FBUFSIZE)) > 0) {
        int i, show_in_ascii = 1;
        overall_cnt += cnt;
	for (i = 0 ; i < cnt ; i++) {
          if  (buf[i] > 127) {
            show_in_ascii = 0;
            break;
          }
        }
        if (first_time || varvalue("traceremote")) {
          first_time = 0;
          ui_fprintf(stderr, "flushed: ");
          if (show_in_ascii) {
            ui_fprintf(stderr, "%s", buf);
          } else {
            for (i = 0 ; i < cnt && i < SHOWCNT ; i++) {
              ui_fprintf(stderr, "%s ", comm_name(buf[i], prev_char));
              prev_char = buf[i];
            }
          }
          ui_fprintf(stderr, "\n");
        }
        if (overall_cnt > 2000) {
            ui_fprintf(stderr, "Target is going wild, reset it? (y/n)");
            if (getchar() == 'y') {
                send_reset_signal();
                flush_output_buffer();
                invalidate_mem_cache();
                sleep(1);
            }
            overall_cnt = 0;
        }
    if (!first_time) {
      ui_fprintf(stderr, "<end of flushing>\n");
    }
  }
}


/*
 * This looks for the passed command from the remote.  It returns
 * true if the thing being waited for was the next character, false
 * otherwise.
 */
int wait_for_token(token1, token2, timeout_action, timeout)
    u_char token1, token2;
    timeout_action_t timeout_action;
    int     timeout;
{
  u_char c;

  do {
    c = get_remote_char(timeout_action, timeout);
    if (c != COMMAND_PREFIX1) {
      if (c == '\r' && varvalue("motomode")) {
        ui_fprintf(stderr,
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
        resetting_remote = false;
        do_pass_command("", true, true);
        flush_tty_line();
        rerr("");
      } 
      if (!ignore_errors) {
        rerr("Received %s instead of COMMAND_PREFIX1", comm_name(c, 0));
      }
      return 0;
    }

    c = get_remote_char(timeout_action, timeout);
  } while (c == C_SYNC && token1 != C_SYNC && token2 != C_SYNC);
    
  if (c != token1 && c != token2) {
    unsigned exception_code, new_processor;

    switch (c) {
      case C_EXCEPTION:
        invalidate_mem_cache();
        new_processor = get_word();
        exception_code = get_word();
        remote_select_processor(new_processor, true);
        ui_fprintf(stderr, "\nCPU %d took ", new_processor);
        if (exception_code < 512) {
          ui_fprintf(stderr, "%s", exception_name(exception_code));
        } else {
          ui_fprintf(stderr, "an exception, but the code was garbled.\n");
        }
        ui_fprintf(stderr, ".  This happened while waiting for a %s or a %s\n",
                                    comm_name(token1, COMMAND_PREFIX1), 
                                    comm_name(token2, COMMAND_PREFIX2));
        break;

      case C_CHECKSUMERR:
      case C_COMMERR:
      case C_BADCOMMAND:
      case C_COMPRESSERR:
      case C_EXPECTEDTOKEN:
        handle_target_rerr(c);
        break;

      default:
        if (c == '\r' && varvalue("motomode")) {
          ui_fprintf(stderr, 
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
          resetting_remote = false;
          do_pass_command("", true, true);
          flush_tty_line();
          rerr("");
        } 
        flush_tty_line();
        rerr("Received %s instead of %s or a %s", 
              comm_name(c, COMMAND_PREFIX1),
              comm_name(token1, COMMAND_PREFIX1), 
              comm_name(token2, COMMAND_PREFIX1));
        break;
    }
    return C_NONE;
  }
  return c;
}

/* Return true if the processor is currently in the target debug 
   monitor. */

boolean in_monitor(processor)
  int processor;
{
  struct all_vars v;	/* For soff() macro */
  invalidate_mem_cache();	/* In case it is stale. */
  return read_remote_w(mon_register_area_addr[processor] + soff(dm_in_mon), 
                       M_SUPERVISOR) == IN_MON_MAGIC;
}

/* Return the exception code for the processor. */

int processor_exception_code(processor)
  int processor;
{
  struct all_vars v;	/* For soff() macro */
  invalidate_mem_cache();	/* In case it is stale. */
  return read_remote_w(mon_register_area_addr[processor] + 
                       soff(dm_exception_code), M_SUPERVISOR);
}


/* Make the passed processor number be the new current  processor
   number and copy its registers to the working registers. */

void remote_select_processor(processor, force)
  int processor;
  int force;   /* True => do it anyway */
{
  char buf[100];

  if (force || in_monitor(processor)) {
    selected_processor = processor;
    sprintf(buf, "[%d] (gdb)", selected_processor);
    set_either_prompt_command (0, buf);
    if (varvalue("showswitch")) {
      ui_fprintf(stdout, "MP:%d ", processor);
      ui_fflush(stdout);
    }
  } else {
    rerr("CPU %d is not stopped in the monitor, cannot select it", processor);
  }
}

/*
 * This listens to the remote, waiting for an exception to
 * occur.
 */
boolean wait_for_exception(expected_exception, timeout_action, timeout)
  unsigned expected_exception;
  timeout_action_t timeout_action;
  int     timeout;
{
  u_char c;
  char *buf;
  unsigned i, new_processor;
  u_long actual_length;	/* # of characters read to satisfy db_read */
  u_long length;		/* Length of target's db_read buffer       */
#ifdef SYSV
  struct termio t, old_t;
#endif
  boolean ioctl_flag;
  static int terminal_fd = 0;		/* We do ioctl's on this             */

  while (1) {
    init_checksum();
    while ((c = get_remote_char(timeout_action, timeout)) != COMMAND_PREFIX1) {
      if (!ignore_errors) {
        ui_fprintf(stderr, "w-f-e: expected P1, got instead: %s\n", 
                                                         comm_name(c, 0));
        if (c == '\r' && varvalue("motomode")) {
          ui_fprintf(stderr, 
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
          resetting_remote = false;
          do_pass_command("", true, true);
          flush_tty_line();
          rerr("");
        } 
      }
      init_checksum();
    }

    splhi();
    c = get_remote_char(timeout_action, timeout);
    switch (c) {
      unsigned exception_code;

      case C_EXCEPTION:
        target_running = false;
        invalidate_mem_cache();
        new_processor = get_word();
        exception_code = get_word();
        if (!cpu_enabled[new_processor]) {
          if (expected_exception != TR_INT) {
            ui_fprintf(stderr, "Idle processor saw unexpected abort interrupt.\n");
          }
          ui_fprintf(stdout, 
   "Running processor(s) didn't see the interrupt, idle processor took over\n");
        }
	remote_select_processor(new_processor, true);
        spllo();
        if (exception_code == expected_exception) {
          traceremote("Expected and received the exception: %s\n",
                             exception_name(exception_code));
          return true;
        }
        switch (expected_exception) {
          case TR_TRC:
            rerr("Target got %s while trying to single step.",
                            exception_name(exception_code));

          case TR_BPT:
            rerr("Target got %s.", exception_name(exception_code));
            break;

          default:
            if (exception_code < 512) {
              rerr("While waiting for %s, target got %s",
                                   exception_name(expected_exception),
                                   exception_name(exception_code));
            } else {
              rerr(
     "While waiting for %s, target got an exception, but the code was garbled.",
                                      exception_name(expected_exception));
            }
            break;
          }
          return false;
        break;

      case C_DBREAD:
        length = get_word();
        verify_checksum();
        if (length > 1024*1024) {
          rerr("Received outrageous length, %d on dbread.", length);
          break;
        }
        traceremote("reading %d character string for remote.\n", length);
        length++;	/* Extra byte for the null */
        if (!(buf = malloc((unsigned)length))) {
          rerr("dbread: unable to malloc a %d bytes", length);
        }
        ioctl_flag = 0;
        switch (varvalue("showinput")) {
          case 0: break;
          case 1: 
            ui_fprintf(stdout, "g88_input(%d)> ", length); 
            ui_fflush(stdout);
            break;;

          case 2: 
            save_terminal_mode();
            init_terminal_mode();
            ioctl_flag = 1;
            break;

          default:
            fprintf(stderr, "$showinput has invalid value, now set to 0\n");
            setvar("showinput", 0);
            break;
        }
        actual_length = read(terminal_fd, &buf[0], length);
        if (actual_length < 0 || actual_length > length) {
          fprintf(stderr, "dbread: error doing read(), length=%d", length);
        }
        if (ioctl_flag) {
          restore_terminal_mode();
        }
        init_checksum();
        send_command(C_DATASTART);
        send_word(actual_length);
        for (i = 0 ; i < actual_length ; i++) {
          send_byte((u_char)buf[i]);
        }
        free(buf);
        send_command(C_DATAEND);
        send_checksum();
        spllo();
        break;

      case C_DBWRITE:
        length = get_word();
        if (length > 1024*1024) {
          rerr("Received outrageous length, %d on dbwrite.", length);
          break;
        }
        traceremote("receiving %d character string from remote.\n", length);
        switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
          case C_DATASTART:
            for (i = 0 ; i < length ; i++) {
              ui_putchar(get_byte());
              ui_fflush(stdout);
            }
            if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
              ui_fprintf(stderr, "\nDidn't find C_DATAEND in DBWRITE\n");
              break;
            }
            verify_checksum();
            break;

          case C_DATAERROR:
            dacc_rerr("fetching characters for DBWWRITE");

          default:
            rerr("Didn't find C_DATASTART in DBWRITE");
            break;
        }
        spllo();
        break;

      case C_CHECKSUMERR:
      case C_COMMERR:
      case C_BADCOMMAND:
      case C_COMPRESSERR:
      case C_EXPECTEDTOKEN:
        handle_target_rerr(c);
        return false;

      default:
        if (c == '\r' && varvalue("motomode")) {
          ui_fprintf(stderr, 
   "Entering pass-through mode, type '*c<ret>' to cold-start debug monitor\n");
          resetting_remote = false;
          do_pass_command("", true, true);
          flush_tty_line();
          rerr("");
        } 
        if (!ignore_errors) {
          rerr("wait_for_exception: got %s", comm_name(c, COMMAND_PREFIX1));
        }
        break;
    }
  }
}

/*
 * Send the 0x81 code to the target in order to reset it.  The kludge
 * board will see this code and pull 88k's reset line.  
 */
void reset_remote()
{
  int timeout;
  jmp_buf timeout_env;

  reset_env = &timeout_env[0];	/* So code in motomode can longjmp to us */

  init_globals();
  resetting_remote = true;
  if (varvalue("resettimeout") <= 0) {
    setvar("resettimeout", DEFAULT_RESET_TIMEOUT);
  }

  /* The user may be resetting the target because power was
     cycled.  If this happens, we will start getting parity errors
     when gdb tries to access target memory unless we tell the
     target monitor to initialize parity before reading.  */

  setvar("noparityinit", 0);

  if (setjmp(timeout_env)) {
      resetting_remote = false;
      if (remote_debugging) {
        rerr("Timeout trying to reset target.");
      } else {
        rerr("\n\
Error while trying to reset target.  Try the attach command again.\n\
You may use the init command.  The flush command may also be useful.\n");
      }
  } else {
    flush_tty_line();
    invalidate_mem_cache();
    if (varvalue("motomode")) {
      char *init_string;
      switch (varvalue("baudrate")) {
        case 9600:
          init_string = "*r\r*e\r*W188-Bug>\r*c\r";
          break;

        case 19200:
          init_string = "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b \
19200\r*W188-Bug>\r*c\r";
          break;

        case 38400:
          init_string = "*r\r*e\r*W188-Bug>\rpf 0\r19200\r.\ry\r*b \
19200\r*W188-Bug>\rmm fff82013;nb\r*p\r40\r*b 38400\r.\r*W188-Bug>\r*c\r";
          break;

        default:
          ui_badnews(-1, "$baudrate only supported for values of 9600, \
19200, and 38400 in motomode");
      }
      do_pass_command(init_string, 
                      false, 
                      varvalue("traceremote"));
    } else {
      send_reset_signal();
    }
    timeout = varvalue("resettimeout");
    
    if (setjmp(timeout_env)) {
      resetting_remote = false;
      if (remote_debugging) {
        rerr("Timeout trying to reset target, while waiting for reset exception.");
      } else {
        rerr("\n\
Error while trying to reset target while waiting for the reset exception\n\
report from the target.  Try the attach command again.\n\
You may use the init command.  The flush command may also be useful.\n");
      }
    } else {
      if (wait_for_exception(TR_RESET, timeout_env, timeout)) {
        traceremote("Target received reset signal.\n");
        stop_cause = 0;
      } else {
        resetting_remote = false;
        rerr("Unable to reset remote.");
      }
    }
  }
  resetting_remote = false;
}

/* Send an interrupt signal to the target and wait for the target to
   report an interrupt exception.  If we think the target is already
   in the target debug monitor, just send it a C_SYNC and see if we
   get a C_SYNC back, don't interrupt it. */

static void interrupt_remote()
{
  static boolean trying_to_sync = false;
  jmp_buf timeout_env;

  if (!trying_to_sync && !target_running) {
    trying_to_sync = true;
    if (setjmp(timeout_env) == 0) {
      traceremote("sending C_SYNC to target...\n");
      flush_tty_line();
      send_command(C_SYNC);
      flush_output_buffer();
      if (wait_for_token(C_SYNC, C_NONE, timeout_env, 1) == C_SYNC) {
        trying_to_sync = false;
        stop_cause |= (1 << SIGINT);
        return;
      }
    }
  }

  trying_to_sync = false;
  nmiing_remote = true;
  if (setjmp(timeout_env)) {
    nmiing_remote = false;
    rerr("Timeout trying to interrupt target.");
  } else {
    traceremote("Interrupting target ...\n");
    flush_tty_line();
    send_interrupt_signal();
    fflush(stdout);
    ignore_errors = true;
    invalidate_mem_cache();
    if (wait_for_exception(TR_INT, timeout_env, 2 /* seconds */)) {
      stop_cause |= (1 << SIGINT);
      traceremote("Target received debug interrupt.\n");
      check_for_delay_slot_after_interrupt();

      if ((remote_read_register(DMT0_REGNUM) & 1)) {
          ui_fprintf(stdout, 
                      "Warning: DMU fault: DMT0=0x%x DMD0=0x%x DMA0=0x%x\n",
                         remote_read_register(DMT0_REGNUM), 
                         remote_read_register(DMD0_REGNUM),
                         remote_read_register(DMA0_REGNUM));
      }
    } else {
      nmiing_remote = false;
      rerr("Unable to interrupt target\n");
    }
    ignore_errors = false;
  }
  nmiing_remote = false;
  fflush(stdout);
}


/*
 * Get the pointers to various monitor data structures by
 * asking the monitor.
 */
void get_monitor_addresses()
{
    u_long addr;
    int     i, c;
    char buf[100];
    char *periodp;

    init_checksum();
    splhi();
    send_command(C_RETPTRS);
    send_command(C_END);
    send_checksum();

    init_checksum();
    switch (wait_for_token(C_DATASTART, C_DATAERROR, ta_warning, 1)) {
        case C_DATASTART:
            break;

        case C_DATAERROR:
            rerr("Target got error while sending monitor addresses");

        default:
            rerr("Didn't find C_DATASTART in get_monitor_addresses");
    }

    if (!varvalue("motomode")) {
      mon_compress_table_addr = get_word();
      traceremote("mon_compress_table_addr=0x%x\n", mon_compress_table_addr);
    }

    for (i = 0 ; i < MAX_PROCESSORS ; i++) {
      mon_register_area_addr[i] = get_word();
      traceremote("mon_register_area_addr[%d]=0x%x\n", 
                   i, mon_register_area_addr[i]);
      if ((mon_register_area_addr[i] & 7) != 0) {
        ui_fprintf(stderr, "WARNING: monitor's register area is misaligned.\n");
      }
    }

    mon_single_step_trap_addr = get_word();
    traceremote("mon_single_step_trap_addr=0x%x\n", mon_single_step_trap_addr);

    mon_date_addr = get_word();
    traceremote("mon_date_addr=0x%x\n", mon_date_addr);

    mon_time_addr = get_word();
    traceremote("mon_time_addr=0x%x\n", mon_time_addr);

    mon_report_comm_errors_addr = get_word();

    traceremote("mon_report_comm_errors_addr=0x%x\n", 
                 mon_report_comm_errors_addr);

    if (wait_for_token(C_DATAEND, C_NONE, ta_warning, 1) != C_DATAEND) {
        rerr("Didn't find C_DATAEND in get_monitor_addresses\n");
    }
    verify_checksum();

    addr = mon_date_addr;
    i = 0;
    while ((c = read_remote_b(addr++, M_SUPERVISOR)) != 0 && 
           i < (sizeof(buf) - 1)) {;
        buf[i++] = c;
    }
    buf[i++] = ' ';
    addr = mon_time_addr;
    while ((c = read_remote_b(addr++, M_SUPERVISOR)) != 0 && 
           i < (sizeof(buf) - 1)) {;
        buf[i++] = c;
    }
    buf[i] ='\0';
    ui_fprintf(stdout, "Tek/HRI Target debug monitor alive  version: %s\n", buf);
    spllo();
}

/*
 * Set the data rate of the remote tty line.
 */
void setbaud(new_baud)
  int new_baud;
{
#ifdef SYSV
  struct termio t;
#endif
  int baud_code;

  if (new_baud == current_baud) {
    return;
  }
  switch (new_baud) {
#ifdef SYSV
    case 50:	baud_code = B50;	break;
    case 75:	baud_code = B75;	break;
    case 110:	baud_code = B110;	break;
    case 150:	baud_code = B150;	break;
    case 200:	baud_code = B200;	break;
    case 300:	baud_code = B300;	break;
    case 600:	baud_code = B600;	break;
    case 1200:	baud_code = B1200;	break;
    case 1800:	baud_code = B1800;	break;
    case 2400:	baud_code = B2400;	break;
    case 4800:	baud_code = B4800;	break;
    case 9600:	baud_code = B9600;	break;
    case 19200:	baud_code = EXTA;	break;

    case 0:
    case 38400:	baud_code = EXTB;	break;
#else
#endif
    default:
      rerr("Can't set remote tty line to %d baud", new_baud);
  }
#ifdef SYSV
  if (ioctl(remote_fd, TCGETA, &t) < 0) {
    rerr("setbaud: Error in doing TCGETA ioctl to %s", remote_tty_name);
  }

  t.c_cflag = (t.c_cflag & ~CBAUD) | baud_code;

  if (ioctl(remote_fd, TCSETAW, &t) < 0) {
        rerr("setbaud: Error in doing TCSETAW ioctl to %s", remote_tty_name);
  }
#else
#endif
  current_baud = new_baud == 0 ? 38400 : new_baud;
}

/*
 * This initializes the remote communication line.
 * This was *not* lifted from targ_init.c in remote adb.
 */
void open_debug_port()
{
#ifndef _WIN32
#ifdef SYSV
  struct termio t;
#endif
  char *env_tty_name;
  char *getenv();

  /*
   * If we already have a tty line open, close it to conserve
   * on file descriptors.
   */
  if (remote_fd > 0) {
    close_debug_port();
  }

  if ((remote_fd = open(remote_tty_name, O_RDWR | O_NDELAY)) < 0) {
    remote_fd = -1;
    rerr("Cannot open %s", remote_tty_name);
  }

#ifdef SYSV
  if (ioctl(remote_fd, TCGETA, &t) < 0) {
    rerr("open_debug_port: Error in doing TCGETA ioctl");
  }

  t.c_oflag = 0;

  /* Attempt to turn on hardware flow control (seems like SUN-OS
     isn't doing this). */

  t.c_cflag = CRTSCTS | CS8 | CREAD | (t.c_cflag & CBAUD);
  t.c_line = 0;

  /* Have the system send control-S/control-Q to throttle the target.
     Ignore breaks and parity errors. */

  t.c_iflag = IXOFF | IGNBRK | IGNPAR;
  t.c_lflag = 0;
  t.c_cc[VMIN] = 0;
  t.c_cc[VTIME] = 0;
  t.c_cc[VSTART] = 0x81;
  t.c_cc[VSTOP] = 0x82;
  if (ioctl(remote_fd, TCSETA, &t) < 0) {
    rerr("open_debug_port: Error in doing TCSETA ioctl");
  }
#else
#endif
  setbaud(varvalue("baudrate"));

#ifdef	SIGIO_WORKS	/* Doesn't work in SUN-OS   91.1.1 */
  /* Request a SIGIO when there is data ready (this appears not to work) */

  if (fcntl(remote_fd, F_SETFL, FASYNC) < 0) {
    rerr("open_debug_port: Error doing fcntl to set flags on %s", 
                                                             remote_tty_name);
  }
#endif

  /* Make I/O asynchronous (this should not be necessary because we
     specified (O_NDELAY in the open, but this appears not to work) */

  if (fcntl(remote_fd, F_SETFL, FNDELAY) < 0) {
    rerr("open_debug_port: Error doing fcntl to set flags on %s", 
                                                             remote_tty_name);
  }
#else
#endif
}

/*
 * Lookup the name as a convenience variable, return it's value.
 */
u_long varvalue(varname) 
    char *varname;
{
  struct internalvar *var;

  var = lookup_internalvar(varname);
  if (TYPE_CODE(VALUE_TYPE(var->value)) != TYPE_CODE_INT) {
    return 0;
  }
  return value_as_long(var->value);
}

/*
 * This an internal variable (now used only for setting "noparityinit"
 * to 0 and 1.
 */
void setvar(varname, newvalue)
    char *varname;
    int newvalue;
{
  struct internalvar *var = lookup_internalvar(varname);
  set_internalvar(var, value_from_long(builtin_type_int, newvalue));
}

/* This is called when the process in which this program is running
   receives a SIGINT, which is usually the result of the user hitting 
   control-c.  */
void remote_request_quit()
{
  /* True if the target was running before we interrupted it */
  boolean target_was_running;	

  if (resetting_remote || nmiing_remote) {
    resetting_remote = false;
    nmiing_remote = false;
    return_to_top_level();
  }

  /* If we have not yet successfully attached, 'remote_debugging' will
     be false.  But 'resetting_remote' might be true, so we test it first. */
    
  if (!remote_debugging) {
    return;
  }
  if (simulator) {
    sim_interrupt();
    quit_flag = 0;
    return;
  }

  target_was_running = target_running;

  /* Attempt to interrupt the target.  If we are successful, unwind
     the stack and let go_remote return to its caller.  */

  interrupt_remote();
  quit_flag = 0;
  if ((stop_cause & (1 << SIGINT)) && target_was_running) {
    ui_fprintf(stdout, "Target interrupted\n");
    longjmp(controlc_env, 1);	/* Return to go_remote()              */
  }

  if (!target_was_running) {
    traceremote("Target alive and was already in debug monitor");
  }

  if (!(stop_cause & (1 << SIGINT)) && target_was_running) {
    ui_fprintf(stdout, 
    "Target hit breakpoint while we were trying to interrupt it\n");
  }
}

/*
 * This returns the string corresponding to the passed command.  
 * 'prev_char' is the previous character.  This helps comm_name 
 * determine whether 'c' is a command or not.
 */
char *comm_name(c, prev_char)
    u_char c;
    u_char prev_char;
{
  static char str[100];
  static char *comm_names[] = 
    { "C_DOWNLOAD", "C_UPLOAD", "C_CHECKSUM", "C_END", "C_GO",
      "C_DATASTART", "C_CHECKSUMERR", "C_ACK", "C_DATAEND", "C_FILL",
      "C_RETPTRS", "C_EXCEPTION", "C_DBWRITE", "C_DBREAD", 
      "C_SYNC", "C_DATAERROR", "C_UPLOADNOINIT", "C_CHECKSUMNOINIT",
      "C_SEARCH", "C_COPYMEM", "C_UPLOADUSER", "C_UPLOADNOINITUSER",
      "C_DOWNLOADUSER", "C_EXPECTEDTOKEN", "C_COMMERR", 
      "C_COMPPRESSERR", "C_BADCOMMAND", "C_188SYSCALL" }; 

  if (passthroughmode) {
    switch (c) {
      case C_RESET:          return "C_RESET"; break;
      case C_NMI:            return "C_NMI";   break;
    }
    sprintf(str, "%02X", c);
      return str;
  }
        
  switch (c) {
    case C_RESET:          return "C_RESET"; break;
    case C_NMI:            return "C_NMI";   break;
    case COMMAND_PREFIX1:  return "P1";      break;
    case COMMAND_PREFIX2:  return "P2";      break;

    case C_DOWNLOAD:  case C_UPLOAD:     case C_CHECKSUM:  case C_END:
    case C_GO:        case C_DATASTART:  case C_CHECKSUMERR:
    case C_ACK:
    case C_DATAEND:   case C_FILL:       case C_RETPTRS:   case C_EXCEPTION:
    case C_DBWRITE:   case C_DBREAD:     case C_SYNC:      
    case C_DATAERROR: case C_UPLOADNOINIT: case C_CHECKSUMNOINIT:
    case C_SEARCH:    case C_COPYMEM:    case C_UPLOADUSER:
    case C_UPLOADNOINITUSER:             case C_DOWNLOADUSER:
    case C_EXPECTEDTOKEN:                case C_COMPRESSERR:
    case C_COMMERR:   case C_BADCOMMAND: case C_188SYSCALL:
      if (prev_char == COMMAND_PREFIX1) {
        return comm_names[c - C_DOWNLOAD];
      }
      break;

    default:
      break;
  }
            
  sprintf(str, "%02X", c);
  return str;
}

/*
 * Returns true if the passed token indicates the target detected an
 * error.
 */
static boolean iserrtoken(token)
    u_char token;
{
  return token == C_CHECKSUMERR   ||
         token == C_EXPECTEDTOKEN ||
         token == C_COMPRESSERR   ||
         token == C_COMMERR       ||
         token == C_BADCOMMAND;
}

/*
 * This resets our output buffer, the one we use for sending bytes
 * to the target.
 */
static void init_output_buffer()
{
  output_buffercnt = 0;
  out_bp = &output_buffer[0];
}


/*
 * Sends the passed command to the other agent.
 */
void send_command(command)
  u_char command;
{
  put_remote_char(COMMAND_PREFIX1);
  put_remote_char(command);
}

/*
 * This initializes the checksum
 */
void init_checksum()
{
  checksum = 0;
  checksumming = true;
}

/*
 * Sends the checksum to the other agent.
 */
void send_checksum()
{
	checksumming = false;
	send_word(checksum);
}

/*
 * This sends the passed word to the other agent.  It does the
 * data compression.
 */
void send_word(word)
    u_long word;
{
	struct compress *ct = &compress_table[0];

	while (ct->length == 4 || ct->length == 0) {
		if (ct->pattern == word && ct->length == 4) {
			put_remote_char((u_char)(ct - &compress_table[0]));
			return;
		}
		ct++;
	}
	send_short((u_short)((word >> 16) & 0xffff));
	send_short((u_short)(word & 0xffff));
}

/*
 * This sends a short to the other agent.
 */
void send_short(s)
	u_short s;
{
	struct compress *ct = &compress_table[SHORT_OFFSET];

	while (ct->length == 2 || ct->length == 0) {
		if (ct->pattern == s && ct->length == 2) {
			put_remote_char((u_char)(ct - &compress_table[0]));
			return;
		}
		ct++;
	}
	send_byte((s >> 8) & 0xff);
	send_byte(s & 0xff);
}

/*
 * This sends a byte to the other agent.
 */
void send_byte(byte)
	u_char byte;
{
	struct compress *ct = &compress_table[BYTE_OFFSET];

	while (ct < &compress_table[256]) {
		if (ct->pattern == byte && ct->length == 1) {
			put_remote_char((u_char)(ct - &compress_table[0]));
			return;
		}
		ct++;
	}
	/*
	 * We couldn't compress the byte.  Send it using the two byte
	 * sequence.
	 */
	if (byte & 0x80) {
		put_remote_char(COMMAND_PREFIX2);
	} else {
		put_remote_char(COMMAND_PREFIX1);
	}
	put_remote_char(byte & 0x7f);
}

/*
 * This returns an unsigned word from the comm port (from other agent).
 */
unsigned get_word()
{
	unsigned t = 0;
	unsigned i;

	for (i = 0 ; i < 4 ; i++) {
		t <<= 8;
		t |= get_byte();
	}
	return t;
}

/*
 * This returns an unsigned short from the comm port (from other agent).
 */
unsigned get_short()
{
        unsigned w = get_byte();

	return (w << 8) | get_byte();
}

/*
 * This returns a decode byte from the comm port (from other agent).
 */
unsigned get_byte()
{
	unsigned c;
	struct compress *ct;

	if (partial_length) {
		partial_length--;
		c = (partial >> 24) & 0xff;
		partial <<= 8;
		return c;
	}

	c = get_remote_char(ta_warning, 1 /* second */);
	ct = &compress_table[c];
	switch (ct->length) {
		case L_QUOTED1:
			c = get_remote_char(ta_warning, 1 /* second */);
                        if (c > 0x7f) {
                            switch (c) {
                                case C_DATAERROR:
                                    dacc_rerr("in get_byte()");

                                case C_CHECKSUMERR:
                                case C_COMMERR:
                                case C_BADCOMMAND:
                                case C_COMPRESSERR:
                                case C_EXPECTEDTOKEN:
                                    handle_target_rerr(c);
                                    break;

                                default:
                                    rerr("Unexpected: %s", 
                                            comm_name(c, L_QUOTED1));
                            }
                        }
			return c;

		case L_QUOTED2:
			c = get_remote_char(ta_warning, 1 /* second */);
                        if (c > 0x7f) {
                            rerr("Unexpected value after L_QUOTED2: %d", c);
                        }
			return c + 0x80;

		case L_BYTE:
			return ct->pattern;

		case L_SHORT:
			partial_length = 1;
			partial = ct->pattern << 24;
			return (ct->pattern >> 8) & 0xff;

		case L_WORD:
			partial_length = 3;
			partial = ct->pattern << 8;
			return (ct->pattern >> 24) & 0xff;

		default:
			rerr("Case error in get_byte()");
			/*NOTREACHED*/
	}
	/*NOTREACHED*/
}

/*
 * This reads the checksum from the comm line and compares it
 * with the value in the global 'checksum'.
 */
void verify_checksum()
{
	u_long received_checksum;

	checksumming = false;
	received_checksum = get_word();
	if (checksum != received_checksum) {
		rerr("Checksum error, expected=0x%x received=0x%x",
                                              checksum, received_checksum);
	}
}

/*
 * This sends the passed character without any compression or
 * interpretation to the target.
 */
void put_remote_char(c)
    u_char c;
{
  static u_char prev_char;

  if (out_bp == nil) {
    rerr("put_remote_char: output buffer not initialized\n");
  }
  if (checksumming) {
    add_to_checksum(c);
  }
  *out_bp++ = c;
  output_buffercnt++;
  add_to_buffer(transmit_buffer, c);

  if (output_buffercnt == BUFSIZ) {
    flush_output_buffer();
  }
  if (varvalue("tracetransmit")) {
    if (direction != transmitting) {
      ui_fprintf(stderr, "\ntransmitting:\n");
      direction = transmitting;
    }
    ui_fprintf(stderr, "%s ", comm_name(c, prev_char));
    prev_char = c;
  }
}

/*
 * This sends any bytes that are in the output buffer to the remote.
 */
static void flush_output_buffer()
{
#ifndef _WIN32
  int cnt;
  struct timeval tv;
  fd_set fdset;

  if (output_buffercnt == 0) {
    return;
  }
  tv.tv_sec = 2;
  tv.tv_usec = 0;
  FD_ZERO(&fdset);
  FD_SET(remote_fd, &fdset);
  if (select(FD_SETSIZE, (int *)0, &fdset, (int *)0, &tv) < 0) {
    ui_badnews(-1, "f-o-b: Select returns error code, errno=%d", errno);
  }
  cnt = write(remote_fd, (char *)&output_buffer[0], output_buffercnt);
  if (cnt != output_buffercnt) {
    rerr("Error: tried to write %d bytes, wrote %d to remote on %s", 
                                    output_buffercnt, cnt, remote_tty_name);
  } else {
    bytes_transmitted += output_buffercnt;
  }
  init_output_buffer();
#else
#endif
}

/* Reset the variables associated with the input buffer. */

static void init_input_buffer()
{
  input_buffer_cnt = 0;
  input_buffer_p = &input_buffer[0];
}

/* Fetech a character from the input buffer.  It is an error to
   call this when there are not characters in the input buffer.  */
  
u_char char_from_input_buffer()
{
  u_char c;

  if (input_buffer_cnt <= 0) {
    ui_badnews(-1, "Attempt to remove a character from empty buffer");
  }
  input_buffer_cnt--;
  bytes_received++;
  c = *input_buffer_p++;
  add_to_buffer(receive_buffer, c);
  if (checksumming) {
     add_to_checksum(c);
  }
  if (varvalue("tracereceive")) {
    if (direction != receiving) {
      ui_fprintf(stderr, "\nreceiving:\n");
      direction = receiving;
    }
    ui_fprintf(stderr, "%s ", comm_name(c, prev_char));
    prev_char = c;
  }
  return c;
}

#ifdef	SIGIO_WORKS	/* Doesn't work in SUN-OS   91.1.1 */

/* This is called when our process has the possibility of doing I/O.
   This serves to interrupt the pause() call below */

void sigio_handler()
{
  if (varvalue("traceremote")) {
    ui_fprintf(stderr, "<SIGIO>\n");
  }
}
#endif

/*
 * Returns a character from the remote device.
 */
u_char get_remote_char(timeout_action, timeout)
  timeout_action_t timeout_action;
  int timeout;
{
#ifndef _WIN32
  int firsttime = true;

  if (input_buffer_cnt > 0) {
    return char_from_input_buffer();
  }
  init_input_buffer();
  flush_output_buffer();
  for (;;) {
    time_t start_time = time((time_t *)0);
    do {
      struct timeval tv;
      fd_set fdset;

#ifdef	SIGIO_WORKS	/* Doesn't work in SUN-OS   91.1.1 */
      signal(SIGIO, sigio_handler);
      pause();
#else
      /* We call select as an alternative to spin-waiting for characters.
         If select wakes up when it shouldn't, that's ok. */

      tv.tv_sec = timeout;
      tv.tv_usec = 0;
      FD_ZERO(&fdset);
      FD_SET(remote_fd, &fdset);
      if (select(FD_SETSIZE, &fdset, (int *)0, (int *)0, &tv) < 0) {
        ui_badnews(-1, "Select returns error code, errno=%d", errno);
      }
#endif

      input_buffer_cnt = read(remote_fd, input_buffer, BUFSIZ);
      if (input_buffer_cnt > 0) {
        if (!firsttime && timeout_action == ta_warning) {
          ui_fprintf(stderr, "\n");
        }
        return char_from_input_buffer();
      }
      spllo();
    } while (start_time + timeout > time((time_t *)0));
      
#ifdef SYSV
    switch (timeout_action) {
      case ta_none:
        break;

      case ta_warning:
        if (firsttime) {
          firsttime = false;
          ui_fprintf(stderr, "\nWaiting for target");
        } else {
          ui_fprintf(stderr, ".");
        }
        break;

      default:
        longjmp(timeout_action, 1);
     }
#endif
  }
#else
#endif
}

/*
 * Disable interrupts (i.e., control-C).
 */
void splhi()
{
    (void)sigblock(1 << (SIGINT - 1));
}

/*
 * Enable interrupts (i.e., control-C).
 */
void spllo()
{
  signal(SIGINT, passthroughmode ? pass_siginthandler : request_quit);
  sigsetmask(sigblock(0) & ~(1 << (SIGINT - 1)));
}

/* Return a pointer to the string that names the tty poosrt that has
   the reset/abort hardware on it */

char *reset_tty_name()
{
  static char buf[200];
  char *s, *getenv();

  if (s = getenv("G88_CONTROL_PORT")) {
    return s;
  }
  strcpy(buf, remote_tty_name);
  buf[strlen(buf)-1]--;
  return buf;
}

static control_fd = -1;

/* Open the control port if it isn't already. */

static void open_control_port()
{
#ifndef _WIN32
  if (control_fd == -1) {
    if ((control_fd = open(reset_tty_name(), O_RDWR|O_NDELAY)) < 0) {
      ui_badnews(-1, "cannot open %s, err code = %d", 
                                  reset_tty_name(), control_fd);
    }
  }
#else
#endif
}

/* Close the control port if it is open */

void close_control_port()
{
  if (control_fd > 0) {
    if (close(control_fd) < 0) {
      ui_badnews(-1, "error in close_control_port");
    }
    control_fd = -1;
  }
}

/* Reset the target */
void send_reset_signal()
{
#ifdef SYSV
  struct termio t;
#endif
  int i,flags;

  open_control_port();
#ifdef SYSV
  ioctl(control_fd,I_POP,0);
  ioctl(control_fd,I_POP,0);

  ioctl(control_fd,TIOCMGET,&flags);
  i =  flags & ~TIOCM_DTR;			/* set DTR bit */
  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
  i = flags | TIOCM_DTR;	/* reset DTR bit */

  /* For some reason SUN-OS delays for 3 seconds with DTR active.  So
     there is no need to delay here. */

  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
#else
#endif
}

/* Interrupt the target */
void send_interrupt_signal()
{
#ifdef SYSV
  struct termio t;
#endif
  int i,flags;
  
  open_control_port();
#ifdef SYSV
  ioctl(control_fd,I_POP,0);
  ioctl(control_fd,I_POP,0);

  ioctl(control_fd,TIOCMGET,&flags);
  i =  flags & ~TIOCM_RTS;
  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
  i = flags | TIOCM_RTS;	/* reset RTS bit */
  sleep(1);
  if(ioctl(control_fd,TIOCMSET,&i) < 0) {
    ui_badnews(-1, "Error performing TIOCMSET on control port");
  }
#else
#endif
}

_initialize_remote()
{
  _initialize_simgdb();
  init_globals();
}
