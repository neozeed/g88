head     1.2;
access   ;
symbols  ;
locks    ; strict;
comment  @@;


1.2
date     88.05.14.15.41.45;  author robertb;  state Exp;
branches ;
next     1.1;

1.1
date     88.05.03.11.15.31;  author robertb;  state Exp;
branches ;
next     ;


desc
@changes made in the last few days.
@


1.2
log
@added rcsid's and copyrights
@
text
@
/*
 * (c) 1987, 1988 Tektronix
 *
 * "$Header: runtime.c,v 1.15 88/05/06 10:42:32 robertb Exp $";
 */

To: 88tools
Cc: miker@@porkface.GWD
Fcc: outbox
Subject: There is an execution tracing facility in d88 and preserved registers
-------

[I'm resending this because most people didn't get it]

STACK DISPLAY:

There is no more wherei command.  The where command now works most
of the time.  I'll be tweaking it in the next few days to make work
more and I hope all of the time.

LOCAL VARIABLES ON THE STACK:

Display of automatics allocated on the stack now works.  I worked 
around the strange information generated by the GH compiler.  This
is no longer a GH issue for me.

PRESERVED REGISTERS:

With the GH-generated code is used to be the case that d88 did not
display the values of local variables that were allocated to
preserved registers if the variable was in any stack frame
except the current one.  That is, d88 didn't used to know
how to restore unwind stacks to get saved preserved registers.
Now it does.

EXECUTION TRACE:

I put this in at the request of John Theus and Jeff Beachy.

It is enabled and disabled by writing a 1 or 0 to the word at location
0xffff0010.  So you can do it under program control or from the front
end.  Here are two aliases to do it from the front end:

alias on "assign *((0ffff0010)\\&int) = 1"
alias off "assign *((0ffff0010)\\&int) = 0"

When it is turned on, d88 opens a file whose name is in SIMETRACE
(there was already an environment variable called SIMTRACE, the 'E'
is for "execution").

This file is appended to with records that look like this:

struct etrace {
    u_long physical_address;
    u_short      size : 3,   /* 1 - byte, 2 - half, 4 - word                 */
                fetch : 1,   /* True if this is an instruction fetch.        */
               usmode : 1,   /* True if a supervisor space access, 0 for user*/
                 lock : 1,   /* True if this is an xmem, 0 otherwise         */
                write : 1,   /* True if this is a st or xmem, 0 otherwise    */
               global : 1,   /* or of global bits in area, segment, page desc*/
         cacheinhibit : 1,   /* or of cacheinhibit bits                      */
            writethru : 1,   /* or of writethru bits                         */
              lowdata : 6;   /* Bottom 6 bits of data in transaction         */

};

Each record takes two words.  

There is a program //cupcake/UTek/tools/bin/trace that will print
an execution trace file in ascii.  Here's some sample output:

00001330 4 SF-I-- 08
00001334 4 SF-I-- 04
0007ffd4 4 SW-I-- 1c
00001338 4 SF-I-- 00
0007ffd0 4 SW-I-- 00
0000133c 4 SF-I-- 00
00001340 4 SF-I-- 07
0000135c 4 SF-I-- 28
00001360 4 SF-I-- 24
0007ffcc 4 SW-I-- 04

At first I had trace be more verbose:

[0x000027f4] 4 super fetch      ci       [0x00]
[0x000027f8] 4 super fetch      ci       [0x03]

But when I ran it on a a file generated by doing 500 Dhyrstone loops,
the resulting ascii file was 20 MB.  The new format is also easier
to grep.

To get a key do "trace -H":

    First field is address of access in hex.
    Second field is size of access, 1, 2, or 4
    Flags:
            S - supervisor space access 
            U - user space access 
            W - data write
            R - data read
            F - instruction fetch
            L - locked access (xmem)
            I - cache inhibit bit set
            T - write through bit set
            G - global bit set
    Bottom six bits of data at the end of the line in hex.

To skip n records before starting the decoding say "trace trfile <n>"

When tracing is on d88 runs a 3 Dhyrstones/sec, that's about 90
times slower than what it normally runs at (211/sec).  I think that
the speed isn't so bad considering the relatively short time it
takes to fill a 300 MB disk with a trace file.

Because tracing slows down the simulator, and because the timer
simulator uses the process virtual timer, you may want to set the
SIMSLOW environment variable to a value around 90 to compensate.

There are certainly improvements that could be made to make the
trace files more compact, have more information, and to make
less of a slow-down in execution.  But I thought it would be
best to do this first implementation and see how people like it
before going further with this feature.

The reason that just the bottom 6 bits of the data are displayed
is that this is all you need to detect cache flush/invalidate
commands (along with the address) and to put all 32 bits in 
would make the trace file much larger.

Some people might find this feature useful as a debugging aid
as it is like having a logic analyizer connected to some point
in the CMMU after address translation but before the cache and
MBUS.

It is possible that the real hardware generates references in a slightly
different order than the trace from d88.  I doubt this matters for
the purpose of debugging or cache design analysis.

	Rob
@


1.1
log
@Initial revision
@
text
@d1 7
@
